{"posts":[{"title":"高级程序开发组件 Jetpack","content":" Jetpack Jetpack 简介 ViewModel ViewModel 的基本用法 向 ViewModel 传递参数 Lifecycles LiveData LiveData 的基本用法 map 和 switchMap Room 使用 Room 进行增删改查 Room 的数据库升级 WorkManager WorkManager 的基本用法 使用 WorkManager 处理复杂的任务 Jetpack Jetpack 简介 长久以来，Android 官方并没有制定一个项目架构的规范，只要能够实现功能，代码怎么编写都是开发者的自由。但是不同的人技术水平不同，最终编写出来的代码质量是千差万别的。 于是在 2017 年，Google 推出了一个官方的架构组件库——Architecture Components，旨在帮助开发者编写出更加符合高质量代码规范、更具有架构设计的应用程序。2018年，Google 又推出了一个全新的开发组件工具集Jetpack，并将 Architecture Components 作为 Jetpack 的一部分纳入其中。 ViewModel 在传统的开发模式下，Activity 的任务实在是太重了，既要负责逻辑处理，又要控制UI展示，甚至还得处理网络回调。 而ViewModel的一个重要作用就是可以帮助 Activity 分担一部分工作，它是专门用于存放与界面相关的数据的。也就是说，只要是界面上能看得到的数据，它的相关变量都应该存放在 ViewModel 中，而不是 Activity 中，这样可以在一定程度上减少 Activity 中的逻辑。 ViewModel还有一个非常重要的特性。我们都知道，当手机发生横竖屏旋转的时候， Activity 会被重新创建，同时存放在 Activity 中的数据也会丢失。而 ViewModel 的生命周期和 Activity 不同，它可以保证在手机屏幕发生旋转的时候不会被重新创建，只有当 Activity 退出的时候才会跟着 Activity 一起销毁。 因此，将与界面相关的变量存放在ViewModel当中，这样即使旋转手机屏幕，界面上显示的数据也不会丢失。 ViewModel 的基本用法 通常来讲，比较好的编程规范是给每一个 Activity 和 Fragment 都创建一个对应的ViewModel。下面实现一个简单计数器的功能 因此这里为 MainActivity 创建一个对应的MainViewModel类，并让它继承自ViewModel，同时加入一个counter变量用于计数，代码如下所示： class MainViewModel : ViewModel() { var counter = 0 } 在界面上添加一个按钮，每点击一次按钮就让计数器加 1，并且把最新的计数显示在界面上。修改activity_main.xml中的代码，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;TextView android:id=&quot;@+id/infoText&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_horizontal&quot; android:textSize=&quot;32sp&quot; /&gt; &lt;Button android:id=&quot;@+id/plusOneBtn&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_horizontal&quot; android:text=&quot;Plus One&quot; android:textAllCaps=&quot;false&quot; /&gt; &lt;/LinearLayout&gt; 下面实现计数器的逻辑，修改 MainActivity 中的代码，如下所示： class MainActivity : AppCompatActivity() { lateinit var viewModel: MainViewModel override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) viewModel = ViewModelProvider(this).get(MainViewModel::class.java) plusOneBtn.setOnClickListener { viewModel.counter++ refreshCounter() } refreshCounter() } private fun refreshCounter() { infoText.text = viewModel.counter.toString() } } 绝对不可以直接去创建ViewModel的实例，而是一定要通过ViewModelProvider来获取 ViewModel 的实例 ViewModel有其独立的生命周期，并且其生命周期要长于 Activity。如果在onCreate()方法中创建 ViewModel 的实例，那么每次 onCreate() 方法执行的时候， ViewModel 都会创建一个新的实例，这样当手机屏幕发生旋转的时候，就无法保留其中的数据了。 向 ViewModel 传递参数 向MainViewModel的构造函数中传递参数需要借助ViewModelProvider.Factory来实现。 由于退出程序之后再重新打开，之前的计数会被清零，因此需要在退出程序的时候对当前的计数进行保存，然后再次打开程序的时候读取之前保存的计数，并传递给 MainViewModel。 因此，这里修改MainViewModel中的代码，如下所示： class MainViewModel(countReserved: Int) : ViewModel() { var counter = countReserved } countReserved参数，这个参数用于记录之前保存的计数值，并在初始化的时候赋值给counter变量。 新建一个MainViewModelFactory类，并让它实现ViewModelProvider.Factory接口，代码如下所示： class MainViewModelFactory(private val countReserved: Int) : ViewModelProvider.Factory { override fun &lt;T : ViewModel&gt; create(modelClass: Class&lt;T&gt;): T { return MainViewModel(countReserved) as T } } MainViewModelFactory的构造函数中接收了一个countReserved参数。 ViewModelProvider.Factory 接口要求我们必须实现create()方法。 在create()方法中创建MainViewModel的实例，并传入countReserved参数。 注意，这里create()方法的执行时机和 Activity 的生命周期无关。 在界面上添加一个清零按钮，方便用户手动将计数器清零。修改 activity_main.xml 中的代码，如下所示： &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; ... &lt;Button android:id=&quot;@+id/clearBtn&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_horizontal&quot; android:text=&quot;Clear&quot;/&gt; &lt;/LinearLayout&gt; 最后修改 MainActivity 中的代码，如下所示： class MainActivity : AppCompatActivity() { lateinit var viewModel: MainViewModel lateinit var sp: SharedPreferences override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) sp = getPreferences(Context.MODE_PRIVATE) val countReserved = sp.getInt(&quot;count_reserved&quot;, 0) viewModel = ViewModelProvider(this, MainViewModelFactory(countReserved)) .get(MainViewModel::class.java) ... clearBtn.setOnClickListener { viewModel.counter = 0 refreshCounter() } refreshCounter() } override fun onPause() { super.onPause() sp.edit { putInt(&quot;count_reserved&quot;, viewModel.counter) } } ... } onCreate() 获取到的SharedPreferences实例用于读取之前保存的计数值，在ViewModelProvider中，额外传入了一个MainViewModelFactory参数，并将读取到的计数值传给了它的构造函数。 注意，只有用这种写法才能将计数值最终传递给MainViewModel的构造函数。 在onPause()方法中对当前的计数进行保存，这样可以保证不管程序是退出还是进入后台，计数都不会丢失。 Lifecycles Lifecycles组件可以让任何一个类都能轻松感知到 Activity 的生命周期，同时又不需要在 Activity 中编写大量的逻辑处理。 新建一个MyObserver类，并让其实现DefaultLifecycleObserver接口，然后重写相关方法，代码如下所示： class MyObserver : DefaultLifecycleObserver { //此方法会感知到Activity的onStart方法后执行 下面同理 override fun onStart(owner: LifecycleOwner) { super.onStart(owner) Log.d(&quot;MyObserver&quot;, &quot;onStart&quot;) } override fun onStop(owner: LifecycleOwner) { super.onStop(owner) Log.d(&quot;MyObserver&quot;, &quot;onStop&quot;) } } 不过现在当 Activity 的生命周期发生变化时，是无法通知到MyObserver的，因此我们需要借助LifecycleOwner来让 MyObserver 得到通知，相关语法结构如下： lifecycleOwner.lifecycle.addObserver(MyObserver()) 首先调用LifecycleOwner的getLifecycle()方法，得到一个Lifecycle对象，然后调用它的addObserver()方法来观察 LifecycleOwner 的生命周期，并把 MyObserver 的实例传进去即可。 只要我们的 Activity 是继承自AppCompatActivity，那么它本身就是一个LifecycleOwner的实例，因为 AndroidX 库自动帮我们完成了这部分工作。 同理，若 Fragment 是继承自androidx.fragment.app.Fragment，那么它本身也是一个LifecycleOwner的实例。 因此，在 MainActivity 当中写法如下： class MainActivity : AppCompatActivity() { ... override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) ... lifecycle.addObserver(MyObserver()) } ... } 目前MyObserver虽然能够自动感知到 Activity 的生命周期发生了变化，却无法主动去获取当前的生命周期状态。 可以在MyObserver的构造函数中将Lifecycle对象传进来，如下所示： class MyObserver(val lifecycle: Lifecycle) : DefaultLifecycleObserver { /*返回值是一个枚举类型 共五种：INITIALIZED、DESTROYED、CREATED、STARTED、RESUMED if(owner.lifecycle.currentState.isAtLeast(Lifecycle.State.CREATED)){ }*/ ... } 然后可以在任何地方调用lifecycle.currentState来主动获知当前的生命周期状态。 当获取的生命周期状态是CREATED时，说明onCreate()方法已经执行了，但是onStart()方法还没有执行，以此类推。 LiveData LiveData是 Jetpack 提供的一种响应式编程组件，它可以包含任何类型的数据，并在数据发生变化的时候通知给观察者，另外 LiveData 特别适合与ViewModel结合在一起使用。 LiveData 的基本用法 如果在ViewModel的内部开启了线程去执行一些耗时逻辑，那么以之前的写法，响应相关事件后就直接去获取数据，是无法得到最新的数据的。 之前一直都是在 Activity 中手动获取ViewModel中的数据，比如在refreshCounter()方法中获取 ViewModel 里的counter变量值来更新界面，ViewModel 是无法将数据的变化主动通知给 Activity 的。 如果将之前计数器的计数使用LiveData来包装，然后在 Activity 中去观察它，就可以主动将数据变化通知给 Activity 了。首先修改MainViewModel中的代码，如下所示： /** * MutableLiveData可以包含任何类型的数据，并在数据发生变化的时候通知给观察者 具有三种读取数据的写法： * getValue()方法用于获取LiveData中包含的数据。 * setValue()方法用于给LiveData设置数据，但是只能在主线程中调用。 * postValue()方法用于在非主线程中给LiveData设置数据。 * */ class MainViewModel(countReserved: Int) : ViewModel() { //countReserved用于记录之前保存的计数值 val counter = MutableLiveData&lt;Int&gt;() //MutableLiveData是一种可变的LiveData init { //语法糖写法 counter.value = countReserved //使之前保存的计数值就可以在初始化的时候得到恢复 } fun plusOne() { //先获取counter中包含的数据，然后给它加1 val count = counter.value ?: 0 //getValue()方法所获得的数据可能为空 counter.value = count + 1 } fun clear() { counter.value = 0 } } 然后修改 MainActivity 中的代码，如下所示： class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { ... plusOneBtn.setOnClickListener { //增加计数 viewModel.plusOne() } clearBtn.setOnClickListener { //清零计数 viewModel.clear() } /** * counter现在是一个LiveData对象 任何LiveData对象都可以调用它的observe()方法来观察数据的变化 * observe()方法接收两个参数： * 第一个参数是一个LifecycleOwner对象 Activity本身就是一个LifecycleOwner对象，因此直接传this即可 * 第二个参数是一个Observer接口 当counter中包含的数据发生变化时就会回调到这里 将最新的计数更新到界面上即可。 */ viewModel.counter.observe(this, Observer { infoText.text = it.toString() }) } override fun onPause() { super.onPause() sp.edit { //对当前的计数进行保存 保证不管程序是退出还是进入后台 计数都不会丢失 putInt(&quot;count_reserved&quot;, viewModel.counter.value ?: 0) } } } 这里调用了viewModel.counter的observe()方法来观察数据的变化。经过对MainViewModel的改造，现在counter变量已经变成了一个LiveData对象。 现在也不用担心 ViewModel 的内部会不会开启线程执行耗时逻辑了·。 注意，如果需要在子线程中给LiveData设置数据，一定要调用postValue()方法，而不能再使用setValue()方法，否则会发生崩溃。 不过上面的写法仍然不是最规范的LiveData用法，问题就在于将counter这个可变的 LiveData 暴露给了外部。这样即使是在ViewModel的外面也是可以给 counter 设置数据的，从而破坏了 ViewModel 数据的封装性，同时也可能带来一定的风险。 比较推荐的做法是，永远只暴露不可变的LiveData给外部。这样在非ViewModel中就只能观察 LiveData 的数据变化，而不能给 LiveData 设置数据。 再次修改MainViewModel中的代码，如下所示： class MainViewModel(countReserved: Int) : ViewModel() { private val _counter = MutableLiveData&lt;Int&gt;() /** * 当外部调用counter变量时 实际上获得的就是_counter的实例 * 但是无法给counter设置数据 从而保证了ViewModel的数据封装性*/ val counter: LiveData&lt;Int&gt; //不可变的LiveData get() = _counter //返回_counter变量 init { _counter.value = countReserved } fun plusOne() { val count = _counter.value ?: 0 _counter.value = count + 1 } fun clear() { _counter.value = 0 } } 这里先将原来的 counter 变量改名为_counter变量，并给它加上private修饰符，这样_counter变量对于外部就是不可见的了。 目前这种写法可以说是非常规范的，也是 Android 官方最为推荐的写法。 map 和 switchMap LiveData 为了能够应对各种不同的需求场景，提供了两种转换方法：map()和switchMap()方法。 map()方法的作用是将实际包含数据的LiveData和仅用于观察数据的LiveData进行转换。 比如说有一个User类，其中包含用户的姓名和年龄，定义如下： data class User(var firstName: String, var lastName: String, var age: Int) 然后可以在ViewModel中创建一个相应的LiveData来包含User类型的数据，如下所示： class MainViewModel(countReserved: Int) : ViewModel() { val userLiveData = MutableLiveData&lt;User&gt;() ... } 如果 MainActivity 中明确只会显示用户的姓名，而完全不关心用户的年龄，那么这个时候还将整个User类型的 LiveData 暴露给外部，就显得不合适了。 而map()方法就是专门用于解决这种问题的，它可以将User类型的LiveData自由地转型成任意其他类型的 LiveData，写法如下： class MainViewModel(countReserved: Int) : ViewModel() { //private声明以保证数据的封装性 private val userLiveData = MutableLiveData&lt;User&gt;() val userName: LiveData&lt;String&gt; = Transformations.map(userLiveData) { user -&gt; &quot;${user.firstName} ${user.lastName}&quot; //将User对象转换成一个只包含用户姓名的字符串 } ... } 这里调用Transformations的map()方法来对LiveData的数据类型进行转换。 map()方法接收两个参数：第一个参数是原始的 LiveData 对象；第二个参数是一个转换函数，在转换函数里编写具体的转换逻辑即可。 当userLiveData的数据发生变化时，map()方法会监听到变化并执行转换函数中的逻辑，然后再将转换之后的数据通知给userName的观察者。 之前所使用的LiveData对象的实例都是在 ViewModel 中创建的，而它也是有可能调用外部的方法获取的。 下面就来模拟一下这种情况，新建一个Repository单例类，代码如下所示： object Repository { fun getUser(userId: String): LiveData&lt;User&gt; { val liveData = MutableLiveData&lt;User&gt;() liveData.value = User(userId, userId, 0) return liveData } } 这里在 Repository 类中添加了一个getUser()方法，这个方法接收一个userId参数。按照正常的编程逻辑，我们应该根据传入的 userId 参数去服务器请求或者到数据库中查找相应的User对象，但这里只是模拟示例，因此每次将传入的 userId 当作用户姓名来创建一个新的 User 对象即可。 需要注意的是，getUser()方法返回的是一个包含User数据的LiveData对象，而且每次调用 getUser() 方法都会返回一个新的 LiveData 实例。 然后在MainViewModel中也定义一个getUser()方法，并且让它调用 Repository 的 getUser() 方法来获取LiveData对象，如下： class MainViewModel(countReserved: Int) : ViewModel() { ... fun getUser(userId: String): LiveData&lt;User&gt; { return Repository.getUser(userId) } } 注意我们不能直接在 MainActivity 中使用如下写法来观察 LiveData 的数据变化： viewModel.getUser(userId).observe(this) { user -&gt; } 因为每次调用getUser()方法返回的都是一个新的LiveData实例，而上述写法会一直观察之前的 LiveData 实例，从而根本无法观察到数据的变化。 此时就需要使用到switchMap()方法，它的使用场景非常固定：如果ViewModel中的某个LiveData对象是调用另外的方法获取的，那么就可以借助switchMap()方法，将这个 LiveData 对象转换成另外一个可观察的 LiveData 对象。 修改MainViewModel中的代码，如下所示： class MainViewModel(countReserved: Int) : ViewModel() { ... private val userIdLiveData = MutableLiveData&lt;String&gt;() //Transformations.switchMap()对另一个可观察的LiveData对象进行转换 val user: LiveData&lt;User&gt; = Transformations.switchMap(userIdLiveData) { userId -&gt; Repository.getUser(userId) } fun getUser(userId: String) { userIdLiveData.value = userId } } 这里定义了一个新的userIdLiveData对象，用来观察userId的数据变化。 switchMap()方法同样接收两个参数： 第一个参数传入新增的userIdLiveData，switchMap() 方法会对它进行观察。 第二个参数是一个转换函数，必须在这个转换函数中返回一个LiveData对象，因为switchMap()方法的工作原理就是要将转换函数中返回的 LiveData 对象转换成另一个可观察的 LiveData 对象。 switchMap()的整体工作流程： 首先，当外部调用 MainViewModel 的getUser()方法来获取用户数据时，并不会发起任何请求或者函数调用，只会将传入的userId值设置到userIdLiveData当中。 一旦 userIdLiveData 的数据发生变化，那么观察 userIdLiveData 的switchMap()方法就会执行，并且调用我们编写的转换函数。然后在转换函数中调用Repository.getUser()方法获取真正的用户数据。同时，switchMap()方法会将 Repository.getUser() 方法返回的LiveData对象转换成一个可观察的 LiveData 对象，对于 Activity 而言，只要去观察这个 LiveData 对象即可。 在上面的例子中，我们调用 MainViewModel 的getUser()方法时传入了一个userId参数，为了能够观察这个参数的数据变化，又构建了一个userIdLiveData，然后在switchMap()方法中再去观察这个 LiveData 对象。但是ViewModel中某个获取数据的方法有可能是没有参数的。 因此，在没有可观察数据的情况下，需要创建一个空的LiveData对象，写法如下： class MyViewModel : ViewModel() { private val refreshLiveData = MutableLiveData&lt;Any?&gt;() val refreshResult = Transformations.switchMap(refreshLiveData) { Repository.refresh() // 假设Repository中已经定义了refresh()方法 } fun refresh() { refreshLiveData.value = refreshLiveData.value } } 这里定义了一个不带参数的refresh()方法，又对应地定义了一个refreshLiveData，但是它不需要指定具体包含的数据类型，因此这里将 LiveData 的泛型指定成Any?即可。 在refresh()方法中，我们只是将refreshLiveData原有的数据取出来（默认是空），再重新设置到 refreshLiveData 当中，这样就能触发一次数据变化。 LiveData 内部不会判断即将设置的数据和原有数据是否相同，只要调用了setValue()或postValue()方法，就一定会触发数据变化事件。 然后在 Activity 中观察refreshResult这个 LiveData 对象即可，这样只要调用了refresh()方法，观察者的回调函数中就能够得到最新的数据。 最后想说的是，LiveData 之所以能够成为Activity与ViewModel之间通信的桥梁，并且还不会有内存泄漏的风险，靠的是Lifecycles组件。 LiveData 在内部使用了Lifecycles组件来自我感知生命周期的变化，从而可以在 Activity 销毁的时候及时释放引用，避免产生内存泄漏的问题。 由于要减少性能消耗，当 Activity 处于不可见状态的时候（比如手机息屏，或者被其他的 Activity 遮挡），如果LiveData中的数据发生了变化，是不会通知给观察者的。只有当 Activity重新恢复可见状态时，才会将数据通知给观察者，而 LiveData 之所以能够实现这种细节的优化，依靠的还是 Lifecycles 组件。 另外，如果在 Activity 处于不可见状态的时候，LiveData发生了多次数据变化，当 Activity 恢复可见状态时，只有最新的那份数据才会通知给观察者，前面的数据在这种情况下相当于已经过期了，会被直接丢弃。 Room ORM 也叫对象关系映射。简单来讲，我们使用的编程语言是面向对象语言，而使用的数据库则是关系型数据库，将面向对象的语言和面向关系的数据库之间建立一种映射关系，即 ORM。 使用 ORM 框架有就可以用面向对象的思维来和数据库进行交互，绝大多数情况下不用再和 SQL 语句打交道了，同时也不用担心操作数据库的逻辑会让项目的整体代码变得混乱。 Android 官方推出了一个 ORM 框架，并将它加入了 Jetpack 当中，即Room。 使用 Room 进行增删改查 Room主要由Entity、Dao和Database这 3 部分组成，每个部分都有明确的职责，详细说明如下： Entity：用于定义封装实际数据的实体类，每个实体类都会在数据库中有一张对应的表，并且表中的列是根据实体类中的字段自动生成的。 Dao：Dao 是数据访问对象的意思，通常会在这里对数据库的各项操作进行封装，在实际编程的时候，逻辑层就不需要和底层数据库打交道了，直接和 Dao 层进行交互即可。 Database：用于定义数据库中的关键信息，包括数据库的版本号、包含哪些实体类以及提供 Dao 层的访问实例。 使用Room，需要在app/build.gradle文件中添加如下的依赖： plugins { ... id 'kotlin-kapt' } ... dependencies { //room def room_version = &quot;2.2.3&quot; implementation &quot;androidx.room:room-runtime:$room_version&quot; kapt &quot;androidx.room:room-compiler:$room_version&quot; ... } 这里新增了一个kotlin-kapt插件，同时在dependencies闭包中添加了两个Room的依赖库。 由于 Room 会根据我们在项目中声明的注解来动态生成代码，因此这里一定要使用kapt引入 Room 的编译时注解库，而启用编译时注解功能则一定要先添加kotlin-kapt插件。 注意，kapt只能在 Kotlin 项目中使用，如果是 Java 项目的话，使用annotationProcessor即可。 首先是定义Entity，也就是实体类。JetpackTest 项目中已经存在一个实体类了，然而User类目前只包含firstName、lastName和age这 3 个字段，但是一个良好的数据库编程建议是，给每个实体类都添加一个id字段，并将这个字段设为主键。 于是对User类进行如下改造，并完成实体类的声明： @Entity data class User(var firstName: String, var lastName: String, var age: Int) { @PrimaryKey(autoGenerate = true) var id: Long = 0 } 这里在User的类名上使用@Entity注解，将它声明成了一个实体类，然后在 User 类中添加了一个id字段，并使用@PrimaryKey注解将它设为了主键，再把autoGenerate参数指定成true，使得主键的值是自动生成的。 这样实体类部分就定义好了，不过这里简单起见，只定义了一个实体类，在实际项目当中，我们需要根据具体的业务逻辑定义很多个实体类。当然，每个实体类定义的方式都是差不多的，最多添加一些实体类之间的关联。 接下来开始定义Dao，这部分也是Room用法中最关键的地方，因为所有访问数据库的操作都是在这里封装的。Dao 要做的事情就是覆盖所有的业务需求，使得业务方永远只需要与 Dao层进行交互，而不必和底层的数据库打交道。 新建一个UserDao接口，注意必须使用接口，这点和Retrofit是类似的，然后在接口中编写如下代码： @Dao interface UserDao { //将参数中传入的User对象插入数据库中 插入完成后将自动生成的主键id值返回 @Insert fun insertUser(user: User): Long //将参数中传入的User对象更新到数据库当中 @Update fun updateUser(newUser: User) //从数据库中查询所有的用户 @Query(&quot;select * from User&quot;) fun loadAllUsers(): List&lt;User&gt; //查询所有年龄大于指定参数的用户 @Query(&quot;select * from User where age &gt; :age&quot;) fun loadUserOlderThan(age: Int): List&lt;User&gt; //会将参数传入的User对象从数据库中删除 @Delete() fun deleteUser(user: User) //使用非实体类参数来增删改数据 @Query(&quot;delete from User where lastName = :lastName&quot;) fun deleteUserByLastName(lastName: String): Int } UserDao接口的上面使用了一个@Dao注解，这样Room才能进行识别。数据库操作通常有增删改查这 4 种，因此 Room 也提供了@Insert、@Delete、@Update和@Query这 4 种相应的注解。 需要注意的是，如果想要从数据库中查询数据，或者使用非实体类参数来增删改数据，那么就必须编写 SQL 语句，不然 Room 将无法知道用户想要操作哪些数据，Room 是支持在编译时动态检查 SQL 语句语法的。 最后来定义Database。这部分内容的写法是非常固定的，只需要定义好 3 个部分的内容：数据库的版本号、包含哪些实体类，以及提供Dao层的访问实例。 新建一个AppDatabase.kt文件，代码如下所示： @Database(version = 1, entities = [User::class]) //多个实体类之间用逗号隔开即可 abstract class AppDatabase : RoomDatabase() { abstract fun userDao(): UserDao companion object { private var instance: AppDatabase? = null //缓存AppDatabase的实例 @Synchronized fun getDatabase(context: Context): AppDatabase { //返回一个AppDatabase对象 instance?.let { //instance变量不为空就直接返回 return it } return Room.databaseBuilder( context.applicationContext, AppDatabase::class.java, &quot;app_database&quot; ) .build().apply { instance = this //this:AppDatabase } } } } AppDatabase类必须继承自RoomDatabase类，并且一定要使用abstract关键字将它声明成抽象类，然后提供相应的抽象方法，用于获取之前编写的Dao的实例，比如这里提供的userDao()方法。不过只需要进行方法声明就可以了，具体的方法实现是由Room在底层自动完成的。 在companion object结构体中编写了一个单例模式，因为原则上全局应该只存在一份AppDatabase的实例。需要注意的是，当instance变量为空时，调用了Room.databaseBuilder()方法来构建一个 AppDatabase 的实例。 databaseBuilder()方法接收 3 个参数： 第一个参数一定要使用applicationContext，而不能使用普通的context，否则容易出现内存泄漏的情况。 第二个参数是AppDatabase的Class类型。 第三个参数是数据库名。 最后调用build()方法完成构建，并将创建出来的实例赋值给instance变量，然后返回当前实例即可。 这样就定义好了 Room 所需要的一切，在布局文件中自行添加删改查四个按钮对它进行测试，然后修改 MainActivity 中的代码，分别在这四个按钮的点击事件中实现增删改查的逻辑，如下： class MainActivity : AppCompatActivity() { ... override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) ... val userDao = AppDatabase.getDatabase(this).userDao() //创建两个User对象 val user1 = User(&quot;Tom&quot;, &quot;Brady&quot;, 40) val user2 = User(&quot;Tom&quot;, &quot;Hanks&quot;, 63) addDataBtn.setOnClickListener { thread { //将insertUser()方法返回的主键id值赋值给原来的User对象 user1.id = userDao.insertUser(user1) user2.id = userDao.insertUser(user2) } } updateDataBtn.setOnClickListener { thread { user1.age = 42 userDao.updateUser(user1) } } deleteDataBtn.setOnClickListener { thread { //删除所有lastName是Hanks的用户 userDao.deleteUserByLastName(&quot;Hanks&quot;) } } queryDataBtn.setOnClickListener { thread { //查询并打印数据库中所有的用户 for (user in userDao.loadAllUsers()) { Log.d(&quot;MainActivity&quot;, user.toString()) } } } } } 需要注意的是，这里将insertUser()方法返回的主键id值赋值给原来的User对象，是因为使用@Update和@Delete注解去更新和删除数据时都是基于这个id值来操作的。 另外，由于数据库操作属于耗时操作，Room默认是不允许在主线程中进行数据库操作的。不过为了方便测试，Room 还提供了一个更加简单的方法，如下所示： Room.databaseBuilder(context.applicationContext, AppDatabase::class.java,&quot;app_database&quot;) .allowMainThreadQueries() .build() 这里加入了一个allowMainThreadQueries()方法，这样Room就允许在主线程中进行数据库操作了，但这个方法建议只在测试环境下使用。 Room 的数据库升级 随着需求和版本的变更，数据库也是需要升级的。不过Room在数据库升级方面设计得非常烦琐，每一次升级都需要手动编写升级逻辑。 若应用程序目前还只是在开发测试阶段，不想编写那么烦琐的数据库升级逻辑，Room提供了一个简单粗暴的方法，如下所示： Room.databaseBuilder(context.applicationContext, AppDatabase::class.java,&quot;app_database&quot;) .fallbackToDestructiveMigration() .build() 在构建AppDatabase实例时，加入了一个fallbackToDestructiveMigration()方法。这样只要数据库进行了升级，Room 就会将当前的数据库销毁，然后再重新创建，随之而来的副作用就是之前数据库中的所有数据就全部丢失了。因此下面使用Room升级数据库的正规写法。 随着业务逻辑的升级，现在要在数据库中添加一张Book表，那么首先要做的就是创建一个 Book 的实体类，如下所示： @Entity data class Book(var name: String, var pages: Int) { //书名、页数 @PrimaryKey(autoGenerate = true) //主键id var id: Long = 0 } 然后创建一个BookDao接口，并在其中随意定义一些 API： @Dao interface BookDao { @Insert fun insertBook(book: Book): Long @Query(&quot;select * from Book&quot;) fun loadAllBooks(): List&lt;Book&gt; } 接下来修改AppDatabase中的代码，在里面编写数据库升级的逻辑，如下所示： @Database(version = 2, entities = [User::class, Book::class]) //多个实体类之间用逗号隔开即可 abstract class AppDatabase : RoomDatabase() { abstract fun userDao(): UserDao abstract fun bookDao(): BookDao companion object { private val MIGRATION_1_2 = object : Migration(1, 2) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL( &quot;create table Book (id integer primary key autoincrement not null,name text not null,pages integer not null)&quot; ) } } private var instance: AppDatabase? = null //缓存AppDatabase的实例 @Synchronized fun getDatabase(context: Context): AppDatabase { //返回一个AppDatabase对象 instance?.let { //instance变量不为空就直接返回 return it } return Room.databaseBuilder( context.applicationContext, AppDatabase::class.java, &quot;app_database&quot; ) .addMigrations(MIGRATION_1_2) .build().apply { instance = this //this:AppDatabase } } } } 这里在@Database注解中，将版本号升级成了 2，并将Book类添加到了实体类声明中，然后又提供了一个bookDao()方法用于获取BookDao的实例。 在companion object结构体中，实现了一个Migration的匿名类，并传入了 1 和 2 这两个参数，表示当数据库版本从 1 升级到 2 的时候就执行这个匿名类中的升级逻辑。 由于要新增一张Book表，所以需要在migrate()方法中编写相应的建表语句。另外必须注意的是，Book 表的建表语句必须和 Book 实体类中声明的结构完全一致，否则Room就会抛出异常。 最后在构建AppDatabase实例的时候，加入一个addMigrations()方法，并把MIGRATION_1_2传入即可。 现在当我们进行任何数据库操作时，Room就会自动根据当前数据库的版本号执行这些升级逻辑，从而让数据库始终保证是最新的版本。 不过，每次数据库升级并不一定都要新增一张表，也有可能是向现有的表中添加新的列。这种情况只需要使用alter语句修改表结构。 现在Book的实体类中只有id、书名、页数这几个字段，而我们想要再添加一个作者字段，代码如下所示： @Entity data class Book(var name: String, var pages: Int, var author: String) { @PrimaryKey(autoGenerate = true) var id: Long = 0 } 既然实体类的字段发生了变动，那么对应的数据库表也必须升级了，所以修改AppDatabase中的代码，如下所示： @Database(version = 3, entities = [User::class, Book::class]) abstract class AppDatabase : RoomDatabase() { ... companion object { ... val MIGRATION_2_3 = object : Migration(2, 3) { override fun migrate(database: SupportSQLiteDatabase) { database.execSQL(&quot;alter table Book add column author text not null default 'unknown'&quot;) } } private var instance: AppDatabase? = null fun getDatabase(context: Context): AppDatabase { ... return Room.databaseBuilder( context.applicationContext, AppDatabase::class.java, &quot;app_database&quot; ) .addMigrations(MIGRATION_1_2, MIGRATION_2_3) .build().apply { instance = this } } } } 这里先将版本号升级成了 3，然后编写一个MIGRATION_2_3的升级逻辑并添加到addMigrations()方法中即可。 WorkManager 如何编写后台代码才能保证应用程序在不同系统版本上的兼容性呢？为了解决这个问题， Google 推出了WorkManager组件。 WorkManager很适合用于处理一些要求定时执行的任务，它可以根据操作系统的版本自动选择底层是使用AlarmManager实现还是JobScheduler实现，从而降低了使用成本。另外，它还支持周期性任务、链式任务处理等功能。 不过WorkManager和Service并不相同，也没有直接的联系。Service 是 Android 系统的四大组件之一，在没有被销毁的情况下是一直保持在后台运行。而 WorkManager 只是一个处理定时任务的工具，它保证即使在应用退出甚至手机重启的情况下，之前注册的任务仍然将会得到执行，因此 WorkManager 很适合用于执行一些定期和服务器进行交互的任务，比如周期性地同步数据。 另外，使用WorkManager注册的周期性任务不能保证一定会准时执行，这并不是 bug，而是系统为了减少电量消耗，可能会将触发时间临近的几个任务放在一起执行，这样可以大幅度地减少 CPU 被唤醒的次数，从而有效延长电池的使用时间。 WorkManager 的基本用法 想要使用 WorkManager，需要先在app/build.gradle文件中添加如下的依赖： dependencies { ... implementation &quot;androidx.work:work-runtime:2.2.0&quot; } WorkManager的基本用法其实比较简单，主要分为以下 3 步： 定义一个后台任务，并实现具体的任务逻辑。 配置该后台任务的运行条件和约束信息，并构建后台任务请求。 将该后台任务请求传入WorkManager的enqueue()方法中，系统会在合适的时间运行。 第一步要定义一个后台任务，这里创建一个SimpleWorker类，代码如下所示： class SimpleWorker(context: Context, params: WorkerParameters) : Worker(context, params) { override fun doWork(): Result { Log.d(&quot;SimpleWorker&quot;, &quot;do work in SimpleWorker&quot;) return Result.success() } } 首先每一个后台任务都必须继承自Worker类并调用它唯一的构造函数。然后重写父类中的doWork()方法，在这个方法中编写具体的后台任务逻辑即可。 doWork()方法不会运行在主线程当中，因此可以在这里执行耗时逻辑，这里简单地打印了一行日志。doWork() 方法要求返回一个Result对象，用于表示任务的运行结果，成功就返回Result.success()，失败就返回Result.failure()。除此之外，还有一个Result.retry()方法，它其实也代表着失败，只是可以结合WorkRequest.Builder的setBackoffCriteria()方法来重新执行任务 这样一个后台任务就定义好了。然后配置该后台任务的运行条件和约束信息。 可配置的内容非常多，这里只进行最基本的配置，代码如下所示： val request = OneTimeWorkRequest.Builder(SimpleWorker::class.java).build() 只需要把刚才创建的后台任务所对应的Class对象传入OneTimeWorkRequest.Builder的构造函数中，然后调用build()方法即可完成构建。 OneTimeWorkRequest.Builder是WorkRequest.Builder的子类，用于构建单次运行的后台任务请求。WorkRequest.Builder 还有另外一个子类PeriodicWorkRequest.Builder，可用于构建周期性运行的后台任务请求，但是为了降低设备性能消耗，PeriodicWorkRequest.Builder 构造函数中传入的运行周期间隔不能短于 15 分钟，示例代码如下： val request = PeriodicWorkRequest.Builder(SimpleWorker::class.java, 15, TimeUnit.MINUTES).build() 最后一步，将构建出的后台任务请求传入WorkManager的enqueue()方法中，系统就会在合适的时间去运行了： WorkManager.getInstance(context).enqueue(request) 可以在布局文件中添加一个doWorkBtn按钮用于测试，然后修改 MainActivity 中的代码，如下所示： class MainActivity : AppCompatActivity() { ... override fun onCreate(savedInstanceState: Bundle?) { ... doWorkBtn.setOnClickListener { val request = OneTimeWorkRequest.Builder(SimpleWorker::class.java).build() WorkManager.getInstance(this).enqueue(request) } } ... } 后台任务的具体运行时间是由我们所指定的约束以及系统自身的一些优化所决定的，由于这里没有指定任何约束，因此后台任务基本上会在点击按钮之后立刻运行。 使用 WorkManager 处理复杂的任务 上面虽然成功运行了一个后台任务，但是我们没有设置相关方法来控制它的具体运行时间。事实上除了运行时间之外，WorkManager还允许我们控制许多其他方面的东西。 比如借助setInitialDelay()方法让后台任务在指定的延迟时间后运行，代码如下所示： val request = OneTimeWorkRequest.Builder(SimpleWorker::class.java) .setInitialDelay(5, TimeUnit.MINUTES) .build() 这里表示希望让SimpleWorker这个后台任务在 5 分钟后运行，我们可以自由选择时间的单位。 可以控制运行时间之后，可以再增加一些别的功能，比如说给后台任务请求添加标签： val request = OneTimeWorkRequest.Builder(SimpleWorker::class.java) ... .addTag(&quot;simple&quot;) .build() 标签的主要功能在于我们可以通过标签来取消后台任务请求： WorkManager.getInstance(this).cancelAllWorkByTag(&quot;simple&quot;) 当然，即使没有标签，也可以通过id来取消后台任务请求： WorkManager.getInstance(this).cancelWorkById(request.id) 但是，使用id只能取消单个后台任务请求，而使用标签的话，则可以将同一标签名的所有后台任务请求全部取消，这个功能在逻辑复杂的场景下尤其有用。 除此之外，我们也可以使用如下代码来一次性取消所有后台任务请求： WorkManager.getInstance(this).cancelAllWork() 另外，若后台任务的doWork()方法返回Result.retry()，那么可以结合setBackoffCriteria()方法来重新执行任务，具体代码如下所示： val request = OneTimeWorkRequest.Builder(SimpleWorker::class.java) ... .setBackoffCriteria(BackoffPolicy.LINEAR, 10, TimeUnit.SECONDS) .build() setBackoffCriteria()方法接收 3 个参数：第二个和第三个参数用于指定在多久之后重新执行任务，时间最短不能少于 10 秒钟，第一个参数则用于指定如果任务再次执行失败，下次重试的时间应该以什么样的形式延迟。 假如任务一直执行失败，不断地重新执行似乎并没有什么意义，只会徒增设备的性能消耗。而随着失败次数的增多，下次重试的时间也应该进行适当的延迟，这才是更加合理的机制。第一个参数的可选值有两种，分别是LINEAR和EXPONENTIAL，前者代表下次重试时间以线性的方式延迟，后者代表下次重试时间以指数的方式延迟。 doWork()的返回值其实就是用于通知任务运行结果的，我们可以使用如下代码对后台任务的运行结果进行监听： WorkManager.getInstance(this) .getWorkInfoByIdLiveData(request.id) //传入后台任务请求的id，会返回一个LiveData对象 .observe(this) { workInfo -&gt; //调用LiveData对象的observe()观察数据变化以监听后台任务的运行结果 if (workInfo.state == WorkInfo.State.SUCCEEDED) { Log.d(&quot;MainActivity&quot;, &quot;do work succeeded&quot;) } else if (workInfo.state == WorkInfo.State.FAILED) { Log.d(&quot;MainActivity&quot;, &quot;do work failed&quot;) } } 另外，也可以调用getWorkInfosByTagLiveData()方法，监听同一标签名下所有后台任务请求的运行结果。 WorkManager中有一个比较有特色的功能——链式任务。假设这里定义了 3 个独立的后台任务：同步数据、压缩数据和上传数据。现在想要实现先同步、再压缩、最后上传的功能，就可以借助链式任务来实现，代码示例如下： val sync = ... val compress = ... val upload = ... WorkManager.getInstance(this) .beginWith(sync) .then(compress) .then(upload) .enqueue() beginWith()方法用于开启一个链式任务，至于后面要接上什么样的后台任务，只需要使用then()方法来连接即可。另外WorkManager还要求，必须在前一个后台任务运行成功之后，下一个后台任务才会运行。也就是说，如果某个后台任务运行失败，或者被取消了，那么接下来的后台任务就都得不到运行了。 可能由于有太多的恶意应用总是想要无限占用后台，绝大多数的国产手机厂商在进行 Android 系统定制的时候会增加一个一键关闭的功能，允许用户一键杀死所有非白名单的应用程序。而被杀死的应用程序既无法接收广播，也无法运行WorkManager的后台任务。 因此，我们不要依赖WorkManager去实现什么核心功能，因为它在国产手机上可能会非常不稳定。 ","link":"https://Petrichoroo.github.io/post/gao-ji-cheng-xu-kai-fa-zu-jian-jetpack/"},{"title":"Kotlin：编写好用的工具方法","content":" Kotlin 求 N 个数的最大最小值 简化 Toast 的用法 简化 Snackbar 的用法 Kotlin Kotlin 提供的丰富语法特性给我们提供了无限扩展的可能，各种复杂的 API 经过特殊的 封装处理之后都能变得简单易用。 求 N 个数的最大最小值 Java 中规定，所有类型的数字都是可比较的，因此必须实现Comparable接口，这个规则在 Kotlin 中也同样成立。那么我们就可以借助泛型，将max()函数修改成接收任意多个实现 Comparable 接口的参数，代码如下所示： fun &lt;T : Comparable&lt;T&gt;&gt; max(vararg nums: T): T { if (nums.isEmpty()) throw RuntimeException(&quot;Params can not be empty.&quot;) var maxNum = nums[0] for (num in nums) { if (num &gt; maxNum) { maxNum = num } } return maxNum } 这里max()函数的参数声明中使用了vararg关键字，也就是说现在它可以接收任意多个整型参数。并将泛型T的上界指定成了Comparable&lt;T&gt;，那么参数 T 就必然是Comparable&lt;T&gt;的子类型。 接下来，判断nums参数列表是否为空，若为空的话就主动抛出一个异常，提醒调用者max()函数必须传入参数。紧接着将maxNum的值赋值成 nums 参数列表中第一个参数的值，然后遍历参数列表，如果发现了更大的值就对 maxNum 进行更新。 现在可以更加灵活地使用max()函数，比如求 3 个浮点型数字的最大值，如下： val a = 3.5 val b = 3.8 val c = 4.1 val largest = max(a, b, c) 现在不管是双精度浮点型、单精度浮点型，还是短整型、整型、长整型，只要是实现Comparable接口的子类型，max()函数全部支持获取它们的最大值。 获取 N 个数的最小值的实现方式也是类似的，只需要定义一个min()函数即可。 简化 Toast 的用法 Toast的标准用法： Toast.makeText(context, &quot;This is Toast&quot;, Toast.LENGTH_SHORT).show() Toast 的makeText()方法接收 3 个参数： 第一个参数是 Toast 显示的上下文环境，必不可少。 第二个参数是 Toast 显示的内容，需要由调用方进行指定，可以传入字符串和字符串资源id两种类型。 第三个参数是 Toast 显示的时长，只支持Toast.LENGTH_SHORT和Toast.LENGTH_LONG这两种值。 因此可以给String类和Int类各添加一个扩展函数，并在里面封装弹出Toast的具体逻辑。这样以后每次想要弹出 Toast 提示时，只需调用它们的扩展函数即可。 新建一个Toast.kt文件，并在其中编写如下代码： fun String.showToast(context: Context, duration: Int = Toast.LENGTH_SHORT) { Toast.makeText(context, this, duration).show() } fun Int.showToast(context: Context, duration: Int = Toast.LENGTH_SHORT) { Toast.makeText(context, this, duration).show() } 这里分别给String类和Int类新增了一个showToast()函数，并让它们都接收一个Context参数和显示时长的参数，后者指定了一个参数默认值。 因此使用showToast()函数时默认会使用Toast.LENGTH_SHORT类型的显示时长，如下： &quot;This is Toast&quot;.showToast(context) 而如果想要使用Toast.LENGTH_LONG的显示时长，只需要这样写即可： &quot;This is Toast&quot;.showToast(context, Toast.LENGTH_LONG) 简化 Snackbar 的用法 Snackbar的常规用法如下所示： Snackbar.make(view, &quot;This is Snackbar&quot;, Snackbar.LENGTH_SHORT) .setAction(&quot;Action&quot;) { // 处理具体的逻辑 } .show() 由于make()方法接收一个View参数，Snackbar 会使用这个 View 自动查找最外层的布局，用于展示 Snackbar。 因此，我们就可以给View类添加一个扩展函数，并在里面封装显示Snackbar的具体逻辑。新建一个 Snackbar.kt 文件，并编写如下代码： fun View.showSnackbar( text: String, actionText: String? = null, duration: Int = Snackbar.LENGTH_SHORT, block: (() -&gt; Unit)? = null ) { val snackbar = Snackbar.make(this, text, duration) if (actionText != null &amp;&amp; block != null) { snackbar.setAction(actionText) { block() } } snackbar.show() } fun View.showSnackbar( resId: Int, actionResId: Int? = null, duration: Int = Snackbar.LENGTH_SHORT, block: (() -&gt; Unit)? = null ) { val snackbar = Snackbar.make(this, resId, duration) if (actionResId != null &amp;&amp; block != null) { snackbar.setAction(actionResId) { block() } } snackbar.show() } Snackbar 和 Toast 类似，显示的内容也是支持传入字符串和字符串资源id两种类型的，因此这里给showSnackbar()函数进行了两种参数类型的函数重载。 首先将扩展函数添加到了View类中，并且参数列表中依次声明了Snackbar要显示的内容、用于传递给setAction()方法的字符串或字符串资源id、显示的时长以及一个函数类型参数。 这里需要将第二和第四个参数都设置成可为空的类型，并将默认值都设置成空，然后只有当两个参数都不为空的时候，我们才去调用Snackbar的setAction()方法来设置额外的点击事件，若触发了点击事件，只需要调用函数类型参数将事件传递给外部的 Lambda 表达式即可。 现在可以使用如下写法来使用 Snackbar： view.showSnackbar(&quot;This is Snackbar&quot;, &quot;Action&quot;) { // 处理具体的逻辑 } ","link":"https://Petrichoroo.github.io/post/kotlinbian-xie-hao-yong-de-gong-ju-fang-fa/"},{"title":"Material Design 设计","content":" Material Design Toolbar 滑动菜单 DrawerLayout NavigationView 悬浮按钮和可交互提示 FloatingActionButton Snackbar CoordinatorLayout 卡片式布局 MaterialCardView AppBarLayout 下拉刷新 可折叠式标题栏 CollapsingToolbarLayout 充分利用系统状态栏空间 Material Design Material Design 是由 Google 的设计工程师们基于传统优秀的设计原则，结合丰富的创意和科学技术所开发的一套全新的界面设计语言，包含了视觉、运动、互动效果等特性。 Toolbar 每个 Activity 最顶部的那个标题栏是ActionBar，而Toolbar的强大之处在于，它不仅继承了 ActionBar 的所有功能，而且灵活性很高，可以配合其它控件完成一些 Material Design 的效果。 任何一个新建的项目，默认都是会显示ActionBar的，这个 ActionBar 其实这是根据项目中指定的主题来显示的。 在AndroidManifest.xml文件中，可以通过android:theme属性指定一个主题，打开res/values/styles.xml文件，可以看到这个主题，如下所示： &lt;resources xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;style name=&quot;Theme.MaterialTest&quot; parent=&quot;Theme.MaterialComponents.DayNight.DarkActionBar&quot;&gt; ... &lt;/style&gt; &lt;/resources&gt; 可以看到，这里的DarkActionBar是一个深色的ActionBar主题，现在需要使用Toolbar来替代 ActionBar，因此需要指定一个不带 ActionBar 的主题。 这里使用Theme.MaterialComponents.Light.NoActionBar，其表示浅色主题，它会将界面的主体颜色设成浅色，陪衬颜色设成深色。 然后修改activity_main.xml中的代码，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;androidx.appcompat.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:background=&quot;@color/design_default_color_primary&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; /&gt; &lt;/FrameLayout&gt; 由于许多 Material 属性是在新系统中新增的，为了能够兼容旧系统，这里使用xmlns:app指定了一个新的命名空间，因此可以使用app:attribute这样的写法。 由于在styles.xml中将程序的主题指定成了浅色主题，因此Toolbar现在也是浅色主题，那么 Toolbar 上面的各种元素就会自动使用深色系，从而和主体颜色区别开。 但为了与主体的浅色区别开，Toolbar中的文字变成黑色会很难看。那么为了能让Toolbar单独使用深色主题，这里使用android:theme将主题指定成ThemeOverlay.AppCompat.Dark.ActionBar。 但是这样指定之后又会出现新的问题，若Toolbar中有菜单按钮，那么弹出的菜单项也会变成深色主题，这样就再次变得十分难看，于是这里又使用了app:popupTheme属性，单独将弹出的菜单项指定成浅色主题。 接下来修改 MainActivity，代码如下所示： class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) setSupportActionBar(toolbar) } } 这里调用setSupportActionBar()方法并将Toolbar的实例传入即可。 下面在AndroidManifest.xml中修改标题栏上显示的文字内容，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.materialtest&quot;&gt; &lt;application ... &lt;activity android:name=&quot;.MainActivity&quot; android:label=&quot;Fruits&quot;&gt; ... &lt;/application&gt; &lt;/manifest&gt; 这里给 activity 增加了一个android:label属性，用于指定在Toolbar中显示的文字内容，如果没有指定的话，会默认使用 application 中指定的label内容，即应用名称。 下面在Toolbar上添加一些 action 按钮，将图片资源放在drawable-xxhdpi中，然后在res目录下创建一个menu文件夹，接着在 menu 下创建一个toolbar.xml文件，并编写如下代码： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;item android:id=&quot;@+id/backup&quot; android:icon=&quot;@drawable/ic_backup&quot; android:title=&quot;Backup&quot; app:showAsAction=&quot;always&quot; /&gt; &lt;item android:id=&quot;@+id/delete&quot; android:icon=&quot;@drawable/ic_delete&quot; android:title=&quot;Delete&quot; app:showAsAction=&quot;ifRoom&quot; /&gt; &lt;item android:id=&quot;@+id/settings&quot; android:icon=&quot;@drawable/ic_settings&quot; android:title=&quot;Settings&quot; app:showAsAction=&quot;never&quot; /&gt; &lt;/menu&gt; 通过&lt;item&gt;标签来定义action按钮，android:id用于指定按钮的 id，android:icon用于指定按钮的图标，android:title用于指定按钮的文字。 接着使用app:showAsAction来指定按钮的显示位置： always：表示永远显示在Toolbar中，如果屏幕空间不够则不显示。 ifRoom：表示屏幕空间足够的情况下显示在Toolbar中，不够的话就显示在菜单当中。 never：表示永远显示在菜单当中。 注意，Toolbar中的 action 按钮只会显示图标，菜单中的 action 按钮只会显示文字。 下面修改 MainActivity 中的代码，如下所示： class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) setSupportActionBar(toolbar) } override fun onCreateOptionsMenu(menu: Menu?): Boolean { menuInflater.inflate(R.menu.toolbar, menu) return true } override fun onOptionsItemSelected(item: MenuItem): Boolean { when (item.itemId) { R.id.backup -&gt; Toast.makeText( this, &quot;You clicked Backup&quot;, Toast.LENGTH_SHORT ).show() R.id.delete -&gt; Toast.makeText( this, &quot;You clicked Delete&quot;, Toast.LENGTH_SHORT ).show() R.id.settings -&gt; Toast.makeText( this, &quot;You clicked Settings&quot;, Toast.LENGTH_SHORT ).show() } return true } } 在onCreateOptionsMenu()中加载toolbar.xml菜单文件，然后在onOptionsItemSelected()方法中处理各个按钮的点击事件。 运行程序，效果如下： 可以看到，Toolbar上显示了两个 action 按钮，这是因为Backup按钮指定的显示位置是always，Delete按钮指定的显示位置是ifRoom，而现在屏幕空间很充足，因此两个按钮都会显示在 Toolbar 中。另外一个Settings按钮由于指定的显示位置是never，所以不会显示在 Toolbar 中，另外，这些 action 按钮都是可以响应点击事件的。 滑动菜单 DrawerLayout 滑动菜单，就是将一些菜单选项隐藏起来，而不是放置在主屏幕上，然后可以通过滑动的方式将菜单显示出来。 DrawerLayout是一个布局，在其中允许放入两个直接子控件：第一个子控件是主屏幕中显示的内容，第二个子控件是滑动菜单中显示的内容。 修改 activity_main.xml 中的代码，如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;androidx.drawerlayout.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/drawerLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;FrameLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;androidx.appcompat.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; android:background=&quot;@color/design_default_color_primary&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:popupTheme=&quot;@style/ThemeOverlay.AppCompat.Light&quot; /&gt; &lt;/FrameLayout&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;start&quot; android:background=&quot;#FFF&quot; android:text=&quot;This is menu&quot; android:textSize=&quot;30sp&quot; /&gt; &lt;/androidx.drawerlayout.widget.DrawerLayout&gt; 最外层的控件使用了DrawerLayout。其中放置了两个直接子控件：第一个子控件是FrameLayout，用于作为主屏幕中显示的内容，里面是之前定义的Toolbar；第二个子控件是一个TextView，用于作为滑动菜单中显示的内容，其实使用什么都可以，DrawerLayout 并没有限制只能使用固定的控件。 第二个子控件的layout_gravity这个属性是必须指定的，因为需要告诉滑动菜单是在屏幕的左边还是右边，这里指定的start表示会根据系统语言进行判断，如果系统语言是从左往右的，比如英语、汉语，滑动菜单就在左边，如果系统语言是从右往左的，比如阿拉伯语，滑动菜单就在右边。 运行程序，效果如下： 在屏幕的左侧边缘向右拖动，就可以让滑动菜单显示出来了。 不过有个问题，因为只有在屏幕的左侧边缘进行拖动时才能将菜单拖出来，而很多用户可能根本就不知道有这个功能，那么该怎么提示他们呢？ Material Design 建议的做法是在Toolbar的最左边加入一个导航按钮，点击按钮也会将滑动菜单的内容展示出来。 修改 MainActivity 中的代码，如下所示： class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) ... supportActionBar?.let { it.setDisplayHomeAsUpEnabled(true) //让导航按钮显示出来 it.setHomeAsUpIndicator(R.drawable.ic_menu) //设置导航按钮图标 } } ... override fun onOptionsItemSelected(item: MenuItem): Boolean { when (item.itemId) { ... android.R.id.home -&gt; drawerLayout.openDrawer(GravityCompat.START) } return true } } 调用getSupportActionBar()方法得到了ActionBar的实例，虽然这个 ActionBar 的具体实现是由Toolbar来完成的。 实际上，Toolbar最左侧的这个按钮就叫作Home按钮，它默认的图标是一个返回的箭头，含义是返回上一个 Activity。很明显，这里将它默认的样式和作用都进行了修改。 对Home按钮的点击事件进行处理，其 id 永远都是android.R.id.home。然后调用DrawerLayout的openDrawer()方法将滑动菜单展示出来。 注意，openDrawer()方法要求传入一个Gravity参数，为了保证这里的行为和 XML 中定义的一致，传入了GravityCompat.START。 运行程序，效果如下： 可以看到，在 Toolbar 的最左边出现了一个导航按钮。 NavigationView 上面菜单页面仅仅使用了一个TextView，非常单调并且比较难看。可以使用NavigationView来对页面进行优化。 NavigationView是 Material 库中提供的一个控件，它不仅是严格按照 Material Design 的要求来设计的，而且可以将滑动菜单页面的实现变得非常简单。 在app/build.gradle文件的 dependencies 闭包中添加如下内容： dependencies { implementation 'de.hdodenhof:circleimageview:3.0.1' //实现图片圆形化 ... } 在开始使用NavigationView之前，需要准备好两个东西：menu和headerLayout。 menu用来在 NavigationView 中显示具体的菜单项，headerLayout则用来在 NavigationView 中显示头部布局。 在menu文件夹下创建一个nav_menu.xml文件，并编写如下代码： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;group android:checkableBehavior=&quot;single&quot;&gt; &lt;item android:id=&quot;@+id/navCall&quot; android:icon=&quot;@drawable/nav_call&quot; android:title=&quot;Call&quot; /&gt; &lt;item android:id=&quot;@+id/navFriends&quot; android:icon=&quot;@drawable/nav_friends&quot; android:title=&quot;Friends&quot; /&gt; &lt;item android:id=&quot;@+id/navLocation&quot; android:icon=&quot;@drawable/nav_location&quot; android:title=&quot;Location&quot; /&gt; &lt;item android:id=&quot;@+id/navMail&quot; android:icon=&quot;@drawable/nav_mail&quot; android:title=&quot;Mail&quot; /&gt; &lt;item android:id=&quot;@+id/navTask&quot; android:icon=&quot;@drawable/nav_task&quot; android:title=&quot;Tasks&quot; /&gt; &lt;/group&gt; &lt;/menu&gt; 首先在&lt;menu&gt;中嵌套了一个&lt;group&gt;标签，然后将 group 的checkableBehavior属性指定为single。group 表示一个组，checkableBehavior 指定为single表示组中的所有菜单项只能单选。 接下来应该准备headerLayout了，这是一个可以随意定制的布局。简单起见，只在其中放置头像、用户名、邮箱地址这 3 项内容。 在layout文件夹下创建一个nav_header.xml文件。修改其中的代码，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;180dp&quot; android:background=&quot;@color/design_default_color_primary&quot; android:padding=&quot;10dp&quot;&gt; &lt;de.hdodenhof.circleimageview.CircleImageView android:id=&quot;@+id/iconImage&quot; android:layout_width=&quot;70dp&quot; android:layout_height=&quot;70dp&quot; android:layout_centerInParent=&quot;true&quot; android:src=&quot;@drawable/nav_icon&quot; /&gt; &lt;TextView android:id=&quot;@+id/mailText&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_alignParentBottom=&quot;true&quot; android:text=&quot;tony@gmail.com&quot; android:textColor=&quot;#FFF&quot; android:textSize=&quot;14sp&quot; /&gt; &lt;TextView android:id=&quot;@+id/userText&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_above=&quot;@+id/mailText&quot; android:text=&quot;Tony Purple&quot; android:textColor=&quot;#FFF&quot; android:textSize=&quot;14sp&quot; /&gt; &lt;/RelativeLayout&gt; 在RelativeLayout中我们放置了 3 个控件，CircleImageView是一个用于将图片圆形化的控件，这里给它指定了一张图片作为头像，然后设置为居中显示。另外两个TextView分别用于显示用户名和邮箱地址。 现在menu和headerLayout都准备好了，可以使用NavigationView了。修改activity_main.xml中的代码，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;androidx.drawerlayout.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/drawerLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; ... &lt;com.google.android.material.navigation.NavigationView android:id=&quot;@+id/navView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;start&quot; app:headerLayout=&quot;@layout/nav_header&quot; app:menu=&quot;@menu/nav_menu&quot; /&gt; &lt;/androidx.drawerlayout.widget.DrawerLayout&gt; 这里将之前的 TextView 换成NavigationView，又通过app:menu和app:headerLayout属性将刚才准备好的menu和headerLayout设置进去，这样就完成 NavigationView 的定义。 然后处理NavigationView中菜单项的点击事件。修改 MainActivity 中的代码，如下所示： class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) setSupportActionBar(toolbar) ... navView.setCheckedItem(R.id.navCall) //将Call菜单项设置为默认选中 navView.setNavigationItemSelectedListener { //当用户点击了任意菜单项时 就会回调到Lambda表达式当中 可以在这里写相应的逻辑处理 /*when(it.itemId){ R.id.navCall -&gt; ... R.id.navFriends -&gt; ... }*/ drawerLayout.closeDrawers() //这里简单起见 无论点击那个按钮 都将滑动菜单关闭 true //表示此事件已被处理 } ... } } 运行程序，效果如下： 悬浮按钮和可交互提示 立面设计是 Material Design 中一条非常重要的设计思想，也就是说，按照 Material Design 的理念，应用程序的界面不仅仅是一个平面，而应该是有立体效果的。 FloatingActionButton FloatingActionButton是 Material 库中提供的一个控件，这个控件可以比较轻松地实现悬浮按钮的效果。 修改activity_main.xml中的代码，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;androidx.drawerlayout.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/drawerLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;FrameLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; ... &lt;com.google.android.material.floatingactionbutton.FloatingActionButton android:id=&quot;@+id/fab&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;bottom|right&quot; android:layout_margin=&quot;16dp&quot; android:src=&quot;@drawable/ic_done&quot; /&gt; &lt;/FrameLayout&gt; ... &lt;/androidx.drawerlayout.widget.DrawerLayout&gt; 运行程序，效果如下： 修改 MainActivity 中的代码，处理FloatingActionButton的点击事件，如下所示： class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) ... fab.setOnClickListener { Toast.makeText(this, &quot;FAB clicked&quot;, Toast.LENGTH_SHORT).show() } } } FloatingActionButton也是调用setOnClickListener()方法来设置按钮的点击事件，这里简单地弹出了一个Toast。 Snackbar Snackbar并不是Toast的替代品，它们有着不同的应用场景。Toast 的作用是告诉用户现在发生了什么事情，但用户只能被动接收这个事情。而Snackbar则在这方面进行了扩展，它允许在提示中加入一个可交互按钮，当用户点击按钮的时候，可以执行一些额外的逻辑操作。 修改 MainActivity 中的代码，如下所示： class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) ... fab.setOnClickListener { view -&gt; Snackbar.make(view, &quot;Data deleted&quot;, Snackbar.LENGTH_SHORT) .setAction(&quot;Undo&quot;) { Toast.makeText(this, &quot;Data resorted&quot;, Toast.LENGTH_SHORT).show() } .show() } } } 这里调用了Snackbar的make()方法来创建一个 Snackba r对象。make() 方法的第一个参数需要传入一个View，只要是当前界面布局的任意一个 View 即可，Snackbar 会使用这个 View 自动查找最外层的布局，用于展示提示信息；第二个参数就是 Snackbar 中显示的内容；第三个参数是 Snackbar 显示的时长。 接着又调用了一个setAction()方法来设置一个动作，从而让 Snackbar 不仅仅是一个提示，而是可以和用户进行交互的。。 运行程序，并点击悬浮按钮，效果如下： 可以看到，Snackbar从屏幕底部出现了，上面有设置的提示文字，还有一个“Undo”按钮，并且可以点击。 不过问题是这个Snackbar将悬浮按钮给遮挡住了。虽说 Snackbar 过一会儿就会自动消失，但这种用户体验总归是不友好的。可以借助CoordinatorLayout来解决这个问题。 CoordinatorLayout CoordinatorLayout可以说是一个加强版的FrameLayout它在普通情况下的作用和 FrameLayout 基本一致，但是它拥有一些额外的 Material 能力。 CoordinatorLayout可以监听其所有子控件的各种事件，并自动帮助我们做出最为合理的响应。比如刚才弹出的Snackbar提示将悬浮按钮遮挡住了，而如果能让 CoordinatorLayout 监听到 Snackbar 的弹出事件，那么它会自动将内部的FloatingActionButton向上偏移，从而确保不会被 Snackbar 遮挡。 至于CoordinatorLayout的使用也非常简单，只需要将原来的FrameLayout替换即可。修改 activity_main.xml 中的代码，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;androidx.drawerlayout.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/drawerLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;androidx.coordinatorlayout.widget.CoordinatorLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;androidx.appcompat.widget.Toolbar .../&gt; &lt;com.google.android.material.floatingactionbutton.FloatingActionButton ... /&gt; &lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt; ... &lt;/androidx.drawerlayout.widget.DrawerLayout&gt; 由于CoordinatorLayout本身就是一个加强版的FrameLayout，因此这种替换不会有任何的副作用。重新运行程序，并点击悬浮按钮，效果如下： 可以看到，悬浮按钮自动向上偏移了Snackbar的同等高度，从而确保不会被遮挡。当Snackbar消失的时候，悬浮按钮会自动向下偏移回到原来的位置。 在Snackbar的make()方法中传入的第一个参数用来指定 Snackbar 是基于哪个View触发的，刚才传入的是FloatingActionButton本身，而 FloatingActionButton 是CoordinatorLayout中的子控件，因此 Snackbar 这个事件就理所应当能被监听到。 若给Snackbar的make()方法传入一个DrawerLayout，那么 Snackbar 就会再次遮挡悬浮按钮，因为 DrawerLayout 不是CoordinatorLayout的子控件。 卡片式布局 MaterialCardView MaterialCardView是用于实现卡片式布局效果的重要控件，由 Material 库提供。实际上，它也是一个FrameLayout，只是额外提供了圆角和阴影等效果，看上去会有立体的感觉。 MaterialCardView 用法非常简单，如下所示： &lt;com.google.android.material.card.MaterialCardView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:cardCornerRadius=&quot;4dp&quot; app:elevation=&quot;5dp&quot;&gt; &lt;TextView android:id=&quot;@+id/infoText&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt; &lt;/com.google.android.material.card.MaterialCardView&gt; 这里定义了一个MaterialCardView布局，我们可以通过app:cardCornerRadius属性指定卡片圆角的弧度，数值越大，圆角的弧度也越大。 另外，还可以通过app:elevation属性指定卡片的高度：高度值越大，投影范围也越大，但是投影效果越淡；高度值越小，投影范围也越小，但是投影效果越浓。这一点和FloatingActionButton是一致的。 然后，我们在MaterialCardView布局中放置了一个TextView，那么这个 TextView 就会显示在一张卡片当中。 但是显然不可能在如此宽阔的一块空白区域内只放置一张卡片。为了能够充分利用屏幕的空间，这里使用RecyclerView填充主界面部分。 首先添加一个 Glide 库的依赖，在app/build.gradle文件中声明如下： dependencies { implementation 'com.github.bumptech.glide:glide:4.9.0' //实现复杂的图片加载功能 ... } Glide 是一个超级强大的开源图片加载库，它不仅可以用于加载本地图片，还可以加载网络图片、GIF 图片甚至是本地视频。最重要的是，Glide 的用法非常简单，只需几行代码就能轻松实现复杂的图片加载功能，因此这里使用它来加载水果图片。 接下来开始具体的代码实现，修改 activity_main.xml 中的代码，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;androidx.drawerlayout.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/drawerLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;androidx.coordinatorlayout.widget.CoordinatorLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;androidx.appcompat.widget.Toolbar .../&gt; &lt;androidx.recyclerview.widget.RecyclerView android:id=&quot;@+id/recyclerView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;com.google.android.material.floatingactionbutton.FloatingActionButton ... /&gt; &lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt; ... &lt;/androidx.drawerlayout.widget.DrawerLayout&gt; 这里在CoordinatorLayout中添加了一个RecyclerView，并使其占满整个布局的空间。 接着定义一个实体类Fruit，代码如下所示： class Fruit(val name: String, val imageId: Int) Fruit类中只有两个字段：name表示水果的名字，imageId表示水果对应图片的资源id。 然后为RecyclerView的子项指定一个自定义的布局，在layout目录下新建fruit_item.xml，代码如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;com.google.android.material.card.MaterialCardView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;5dp&quot; app:cardCornerRadius=&quot;4dp&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt; &lt;ImageView android:id=&quot;@+id/fruitImage&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;100dp&quot; android:scaleType=&quot;centerCrop&quot; /&gt; &lt;TextView android:id=&quot;@+id/fruitName&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_horizontal&quot; android:layout_margin=&quot;5dp&quot; android:textSize=&quot;16sp&quot; /&gt; &lt;/LinearLayout&gt; &lt;/com.google.android.material.card.MaterialCardView&gt; 这里使用了MaterialCardView来作为子项的最外层布局，从而使得RecyclerView中的每个元素都是在卡片当中的。 注意，在ImageView中使用了一个scaleType属性，这个属性可以指定图片的缩放模式。由于各张水果图片的长宽比例可能会不一致，为了让所有的图片都能填充满整个 ImageView，这里使用centerCrop模式，它可以让图片保持原有比例填充满 ImageView，并将超出屏幕的部分裁剪掉。 接下来需要为RecyclerView准备一个适配器，新建FruitAdapter类，代码如下所示： class FruitAdapter(val context: Context, val fruitList: List&lt;Fruit&gt;) : RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt;() { inner class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) { val fruitImage: ImageView = itemView.findViewById(R.id.fruitImage) val fruitName: TextView = itemView.findViewById(R.id.fruitName) } override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder { val view = LayoutInflater.from(parent.context).inflate(R.layout.fruit_item, parent, false) return ViewHolder(view) } override fun onBindViewHolder(holder: ViewHolder, position: Int) { val fruit = fruitList[position] holder.fruitName.text = fruit.name Glide.with(context).load(fruit.imageId).into(holder.fruitImage) } override fun getItemCount(): Int { return fruitList.size } } 需要注意的是，在onBindViewHolder()方法中使用了Glide来加载水果图片。 首先调用Glide.with()并传入一个Context、Activity或Fragment参数，然后调用load()方法加载图片，可以是一个 URL 地址，也可以是一个本地路径，或者是一个资源id，最后调用into()方法将图片设置到具体某一个ImageView中即可。 为什么要使用Glide而不是传统的设置图片方式呢？因为如果所使用的水果图片像素非常高的话，不进行压缩就直接展示，很容易引起内存溢出。 而Glide在内部做了许多非常复杂的逻辑操作，其中就包括了图片压缩，我们只需要安心按照 Glide的标准用法去加载图片即可。 这样就将RecyclerView的适配器准备好了，最后修改 MainActivity 中的代码，如下所示： class MainActivity : AppCompatActivity() { private val fruits = mutableListOf( Fruit(&quot;Apple&quot;, R.drawable.apple), Fruit( &quot;Banana&quot;, R.drawable.banana ), Fruit(&quot;Orange&quot;, R.drawable.orange), Fruit( &quot;Watermelon&quot;, R.drawable.watermelon ), Fruit(&quot;Pear&quot;, R.drawable.pear), Fruit( &quot;Grape&quot;, R.drawable.grape ), Fruit(&quot;Pineapple&quot;, R.drawable.pineapple), Fruit( &quot;Strawberry&quot;, R.drawable.strawberry ), Fruit(&quot;Cherry&quot;, R.drawable.cherry), Fruit( &quot;Mango&quot;, R.drawable.mango ) ) private val fruitList = ArrayList&lt;Fruit&gt;() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) ... initFruits() val layoutManager = GridLayoutManager(this, 2) recyclerView.layoutManager = layoutManager val adapter = FruitAdapter(this, fruitList) recyclerView.adapter = adapter } private fun initFruits() { fruitList.clear() repeat(50) { val index = (0 until fruits.size).random() fruitList.add(fruits[index]) } } } 首先定义了一个水果集合，集合里面存放了多个Fruit的实例，每个实例都代表一种水果。然后在initFruits()方法中，从刚才定义的Fruit数组中随机挑选一个水果放入fruitList当中，这样每次打开程序看到的水果数据都会是不同的。 这里使用到了GridLayoutManager布局方式，它的构造函数接收两个参数：第一个是Context，第二个是列数。这里每一行中会有两列数据。 现在重新运行一下程序，效果如下： 可以看到，每个水果都是在一张单独的卡片当中的，并且还拥有圆角和投影。 不过又出现了一个问题，Toolbar被RecyclerView给挡住了，这就需要借助另外一个工具AppBarLayout来解决了。 AppBarLayout 由于RecyclerView和Toolbar都是放置在CoordinatorLayout中的，而CoordinatorLayout 就是一个加强版的FrameLayout，那么 FrameLayout 中的所有控件在不进行明确定位的情况下，默认都会摆放在布局的左上角，从而产生了遮挡的现象。 在传统情况下，使用偏移是唯一的解决办法，即让RecyclerView向下偏移一个Toolbar的高度，从而保证不会遮挡到 Toolbar。 不过这里准备使用 Material 库中提供的另外一个工具——AppBarLayout。AppBarLayout 实际 上是一个垂直方向的LinearLayout，它在内部做了很多滚动事件的封装。 使用AppBarLayout解决前面的遮挡问题只需要两步即可，第一步将Toolbar嵌套到 AppBarLayout 中，第二步给RecyclerView指定一个布局行为。 修改 activity_main.xml 中的代码，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;androidx.drawerlayout.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/drawerLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;androidx.coordinatorlayout.widget.CoordinatorLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;com.google.android.material.appbar.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;androidx.appcompat.widget.Toolbar .../&gt; &lt;/com.google.android.material.appbar.AppBarLayout&gt; &lt;androidx.recyclerview.widget.RecyclerView android:id=&quot;@+id/recyclerView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; /&gt; &lt;com.google.android.material.floatingactionbutton.FloatingActionButton ... /&gt; &lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt; ... &lt;/androidx.drawerlayout.widget.DrawerLayout&gt; 这里首先定义了一个AppBarLayout，并将Toolbar放置在其中，然后在RecyclerView中使用app:layout_behavior属性指定了一个布局行为。其中appbar_scrolling_view_behavior这个字符串也是由Material库提供的。 重新运行程序，效果如下： 当AppBarLayout接收到滚动事件的时候，它内部的子控件其实是可以指定如何去响应这些事件的，通过app:layout_scrollFlags属性就能实现。修改 activity_main.xml中 的代码，如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;androidx.drawerlayout.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/drawerLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;androidx.coordinatorlayout.widget.CoordinatorLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;com.google.android.material.appbar.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;androidx.appcompat.widget.Toolbar ... app:layout_scrollFlags=&quot;scroll|enterAlways|snap&quot; /&gt; &lt;/com.google.android.material.appbar.AppBarLayout&gt; &lt;androidx.recyclerview.widget.RecyclerView android:id=&quot;@+id/recyclerView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; /&gt; ... &lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt; ... &lt;/androidx.drawerlayout.widget.DrawerLayout&gt; 这里在Toolbar中添加了一个app:layout_scrollFlags属性，并将这个属性的值指定成了scroll|enterAlways|snap。 scroll：表示当 RecyclerView 向上滚动的时候，Toolbar 会跟着一起向上滚动并实现隐藏。 enterAlways：表示当 RecyclerView 向下滚动的时候，Toolbar 会跟着一起向下滚动并重新显示。 snap：表示当 Toolbar 还没有完全隐藏或显示的时候，会根据当前滚动的距离，自动选择是隐藏还是显示。 现在重新运行程序，并向上滚动RecyclerView，效果如下： 可以看到，随着我们向上滚动RecyclerView，Toolbar自动消失了！而向下滚动 RecyclerView时，Toolbar 又会重新出现。 下拉刷新 SwipeRefreshLayout是用于实现下拉刷新功能的核心类，把想要实现下拉刷新功能的控件放置其中，就可以迅速让这个控件支持下拉刷新。那么在此项目中，支持下拉刷新功能的控件自然是RecyclerView。 使用SwipeRefreshLayout之前首先需要在app/build.gradle文件中添加如下依赖： dependencies { implementation &quot;androidx.swiperefreshlayout:swiperefreshlayout:1.0.0&quot; //下拉刷新 ... } 然后修改 activity_main.xml 中的代码，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;androidx.drawerlayout.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/drawerLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;androidx.coordinatorlayout.widget.CoordinatorLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; ... &lt;androidx.swiperefreshlayout.widget.SwipeRefreshLayout android:id=&quot;@+id/swipeRefresh&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt; &lt;androidx.recyclerview.widget.RecyclerView android:id=&quot;@+id/recyclerView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;/androidx.swiperefreshlayout.widget.SwipeRefreshLayout&gt; ... &lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt; ... &lt;/androidx.drawerlayout.widget.DrawerLayout&gt; 可以看到，这里在RecyclerView的外面又嵌套了一层SwipeRefreshLayout，这样 RecyclerView 就自动拥有下拉刷新功能了。 注意，由于RecyclerView现在变成了SwipeRefreshLayout的子控件，因此之前使用app:layout_behavior声明的布局行为现在也要移到 SwipeRefreshLayout 中才行。 然后在代码中处理具体的刷新逻辑。修改 MainActivity 中的代码，如下所示： class MainActivity : AppCompatActivity() { ... @SuppressLint(&quot;ResourceAsColor&quot;) override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) ... swipeRefresh.setColorSchemeColors(R.color.design_default_color_primary) swipeRefresh.setOnRefreshListener { refreshFruits(adapter) } } private fun refreshFruits(adapter: FruitAdapter) { thread { Thread.sleep(2000) runOnUiThread { //切回主线程 initFruits() //重新生成水果数据 adapter.notifyDataSetChanged() //通知数据发生变化 swipeRefresh.isRefreshing = false //刷新事件结束，并隐藏刷新进度条 } } } ... } 当当用户进行了下拉刷新操作时，就会回调到Lambda表达式当中，然后在这里去处理具体的刷新逻辑就即可。 通常情况下，当触发了下拉刷新事件，应该是去网络上请求最新的数据，然后再将这些数据展示出来。这里简单起见，没有和网络进行交互，而是调用一个refreshFruits()方法进行本地刷新操作 refreshFruits()方法中先是开启了一个线程，然后将线程沉睡两秒钟。之所以这么做，是因为本地刷新操作速度非常快，如果不将线程沉睡的话，刷新立刻就结束了，从而看不到刷新的过程。 重新运行程序，在屏幕的主界面向下拖动，会有一个下拉刷新的进度条出现，松手后就会自动进行刷新了，效果如下： 下拉刷新的进度条只会停留两秒钟，之后就会自动消失，界面上的水果数据也会随之更新。 可折叠式标题栏 CollapsingToolbarLayout CollapsingToolbarLayout是一个作用于Toolbar基础之上的布局，可以让 Toolbar 的效果变得更加丰富，但它是不能独立存在的，它在设计的时候就被限定只能作为AppBarLayout的直接子布局来使用。而 AppBarLayout 又必须是CoordinatorLayout的子布局。 首先需要一个额外的 Activity 作为水果的详情展示界面，创建一个FruitActivity，并将布局名指定成activity_fruit.xml，然后开始编写水果详情展示界面的布局。 由于整个布局文件比较复杂，这里采用分段编写的方式。activity_fruit.xml中的内容主要分为两部分，一个是水果标题栏，一个是水果内容详情，我们来一步步实现。 首先实现标题栏部分，这里使用CoordinatorLayout作为最外层布局，并在其中嵌套一个AppBarLayout，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;com.google.android.material.appbar.AppBarLayout android:id=&quot;@+id/appBar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;250dp&quot; /&gt; &lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt; 接下来在AppBarLayout中再嵌套一个CollapsingToolbarLayout，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;com.google.android.material.appbar.AppBarLayout android:id=&quot;@+id/appBar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;250dp&quot;&gt; &lt;com.google.android.material.appbar.CollapsingToolbarLayout android:id=&quot;@+id/collapsingToolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:contentScrim=&quot;@color/design_default_color_primary&quot; app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot; /&gt; &lt;/com.google.android.material.appbar.AppBarLayout&gt; &lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt; 为了实现更加高级的Toolbar效果，这里通过android:theme属性将activity_main.xml中给 Toolbar 设置的主题提到上一层来。 app:contentScrim属性用于指定CollapsingToolbarLayout在趋于折叠状态以及折叠之后的背景色。 app:layout_scrollFlags属性所设置的值中，scroll表示CollapsingToolbarLayout会随着水果内容详情的滚动一起滚动，exitUntilCollapsed表示当 CollapsingToolbarLayout 随着滚动完成折叠之后就保留在界面上，不再移出屏幕。 接下来，在CollapsingToolbarLayout中定义标题栏的具体内容，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;com.google.android.material.appbar.AppBarLayout android:id=&quot;@+id/appBar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;250dp&quot;&gt; &lt;com.google.android.material.appbar.CollapsingToolbarLayout android:id=&quot;@+id/collapsingToolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:contentScrim=&quot;@color/design_default_color_primary&quot; app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;&gt; &lt;ImageView android:id=&quot;@+id/fruitImage&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:scaleType=&quot;centerCrop&quot; app:layout_collapseMode=&quot;parallax&quot; /&gt; &lt;androidx.appcompat.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; app:layout_collapseMode=&quot;pin&quot; /&gt; &lt;/com.google.android.material.appbar.CollapsingToolbarLayout&gt; &lt;/com.google.android.material.appbar.AppBarLayout&gt; &lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt; 在CollapsingToolbarLayout中定义了一个ImageView和一个Toolbar，也就意味着，这个高级版的标题栏将是由普通的标题栏加上图片组合而成的。 app:layout_collapseMode用于指定当前控件在CollapsingToolbarLayout折叠过程中的折叠模式。 Toolbar指定成pin：表示在折叠的过程中位置始终保持不变。 ImageView指定成parallax：表示会在折叠的过程中产生一定的错位偏移，这种模式的视觉效果会非常好。 这样就将水果标题栏的界面编写完成了，然后编写水果内容详情部分。继续修改 activity_fruit.xml 中的代码，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;com.google.android.material.appbar.AppBarLayout android:id=&quot;@+id/appBar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;250dp&quot;&gt; ... &lt;/com.google.android.material.appbar.AppBarLayout&gt; &lt;androidx.core.widget.NestedScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; /&gt; &lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt; 水果内容详情的最外层布局使用了一个NestedScrollView，注意它和AppBarLayout是平级的。 ScrollView允许使用滚动的方式来查看屏幕以外的数据，而NestedScrollView在此基础之上还增加了嵌套响应滚动事件的功能。由于CoordinatorLayout本身已经可以响应滚动事件了，因此在它的内部就需要使用 NestedScrollView 或 RecyclerView 这样的布局。 另外，这里还通过app:layout_behavior属性指定了一个布局行为，这和之前在RecyclerView中的用法是一模一样的。 不管是ScrollView还是NestedScrollView，它们的内部都只允许存在一个直接子布局。因此，如果想要在里面放入很多东西的话，通常会先嵌套一个LinearLayout，然后再在 LinearLayout 中放入具体的内容即可，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; ... &lt;androidx.core.widget.NestedScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt; &lt;com.google.android.material.card.MaterialCardView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;15dp&quot; android:layout_marginTop=&quot;35dp&quot; android:layout_marginRight=&quot;15dp&quot; android:layout_marginBottom=&quot;15dp&quot; app:cardCornerRadius=&quot;4dp&quot;&gt; &lt;TextView android:id=&quot;@+id/fruitContentText&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;10dp&quot; /&gt; &lt;/com.google.android.material.card.MaterialCardView&gt; &lt;/LinearLayout&gt; &lt;/androidx.core.widget.NestedScrollView&gt; &lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt; 为了让界面更加美观，这里在MaterialCardView和TextView上都加了一些边距。 这样就把水果标题栏和水果内容详情的界面都编写完了，不过还可以在界面上再添加一个悬浮按钮。这个悬浮按钮并不是必需的，根据具体的需求添加即可，若加入的话，将获得一些额外的动画效果。 这是一个水果详情展示界面，那么可以加入一个表示评论作用的悬浮按钮。修改activity_fruit.xml中的代码，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; ... &lt;androidx.core.widget.NestedScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:orientation=&quot;vertical&quot;&gt; ... &lt;/androidx.core.widget.NestedScrollView&gt; &lt;com.google.android.material.floatingactionbutton.FloatingActionButton android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_margin=&quot;16dp&quot; android:src=&quot;@drawable/ic_comment&quot; app:layout_anchor=&quot;@id/appBar&quot; app:layout_anchorGravity=&quot;bottom|end&quot; /&gt; &lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt; 这里加入了一个FloatingActionButton，它和AppBarLayout以及NestedScrollView是平级的。 app:layout_anchor属性指定了一个锚点，我们将锚点设置为AppBarLayout，这样悬浮按钮就会出现在水果标题栏的区域内，接着又使用app:layout_anchorGravity属性将悬浮按钮定位在标题栏区域的右下角。 完成界面设计后，接下来开始编写功能逻辑，修改FruitActivity中的代码，如下所示： class FruitActivity : AppCompatActivity() { companion object { const val FRUIT_NAME = &quot;fruit_name&quot; const val FRUIT_IMAGE_ID = &quot;fruit_image_id&quot; } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_fruit) val fruitName = intent.getStringExtra(FRUIT_NAME) ?: &quot;&quot; val fruitImageId = intent.getIntExtra(FRUIT_IMAGE_ID, 0) setSupportActionBar(toolbar) supportActionBar?.setDisplayHomeAsUpEnabled(true) collapsingToolbar.title = fruitName Glide.with(this).load(fruitImageId).into(fruitImageView) fruitContentText.text = generateFruitContent(fruitName) } override fun onOptionsItemSelected(item: MenuItem): Boolean { when (item.itemId) { android.R.id.home -&gt; { finish() return true } } return super.onOptionsItemSelected(item) } private fun generateFruitContent(fruitName: String) = fruitName.repeat(500) } 这里通过Intent获取了传入的水果名和水果图片的资源id。接着使用了Toolbar的标准用法，将它作为ActionBar显示，并启用Home按钮。由于 Home 按钮的默认图标就是一个返回箭头，因此就不用额外设置别的图标。 接下来开始填充界面上的内容，调用CollapsingToolbarLayout的setTitle()方法，将水果名设置成当前界面的标题，然后使用Glide加载传入的水果图片，并设置到标题栏的ImageView上面。接着需要填充水果的内容详情，这里只是将水果名循环拼接 500 次，从而生成了一个比较长的字符串，将它设置到了TextView上面。 最后需要处理RecyclerView的点击事件，不然的话，根本就无法打开FruitActivity。修改FruitAdapter中的代码，如下所示： class FruitAdapter(val context: Context, val fruitList: List&lt;Fruit&gt;) : RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt;() { ... override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder { val view = LayoutInflater.from(parent.context).inflate(R.layout.fruit_item, parent, false) val holder = ViewHolder(view) holder.itemView.setOnClickListener { val position = holder.adapterPosition val fruit = fruitList[position] val intent = Intent(context, FruitActivity::class.java).apply { putExtra(FruitActivity.FRUIT_NAME, fruit.name) putExtra(FruitActivity.FRUIT_IMAGE_ID, fruit.imageId) } context.startActivity(intent) } return holder } } 这里给fruit_item.xml的最外层布局注册了一个点击事件监听器，然后在点击事件中获取当前点击项的水果名和水果图片资源id，把它们传入Intent中，然后启动FruitActivity。 重新运行程序，并点击界面上的任意一个水果，效果如下： 这个界面上的内容分为 3 部分：水果标题栏、水果内容详情和悬浮按钮。Toolbar和水果背景图完美地融合到了一起，既保证了图片的展示空间，又不影响 Toolbar 的任何功能，那个向左的箭头就是用来返回上一个 Activity 的。 尝试向上拖动水果内容详情，我们会发现水果背景图上的标题会慢慢缩小，并且背景图会产生一些错位偏移的效果，如图所示： 这是由于用户想要查看水果的内容详情，此时界面的重点在具体的内容上面，因此标题栏就会自动进行折叠，从而节省屏幕空间。 继续向上拖动，直到标题栏变成完全折叠状态，效果如图所示： 可以看到，标题栏的背景图片不见了，悬浮按钮也自动消失了，现在水果标题栏变成了一个最普通的Toolbar。这是由于用户正在阅读具体的内容，需要给他们提供最充分的阅读空间。 而如果这个时候向下拖动水果内容详情，就会执行一个完全相反的动画过程，最终恢复成开始的界面效果。 充分利用系统状态栏空间 虽然现在水果详情展示界面的效果已经非常华丽了，但我们会发现水果的背景图片和系统的状态栏总有一些不搭的感觉，若能将背景图和状态栏融合到一起，那视觉体验绝对能提升几个档次。 想要让背景图能够和系统状态栏融合，需要借助android:fitsSystemWindows这个属性来实现。在CoordinatorLayout、AppBarLayout、CollapsingToolbarLayout这种嵌套结构的布局中，将控件的 android:fitsSystemWindows 属性指定成true，就表示该控件会出现在系统状态栏里。 对应到我们的程序，那就是水果标题栏中的ImageView应该设置这个属性了。不过只给 ImageView 设置这个属性是没有用的，必须将 ImageView 布局结构中的所有父布局都设置上这个属性才可以，修改activity_fruit.xml中的代码，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;androidx.coordinatorlayout.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot;&gt; &lt;com.google.android.material.appbar.AppBarLayout android:id=&quot;@+id/appBar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;250dp&quot; android:fitsSystemWindows=&quot;true&quot;&gt; &lt;com.google.android.material.appbar.CollapsingToolbarLayout android:id=&quot;@+id/collapsingToolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; android:theme=&quot;@style/ThemeOverlay.AppCompat.Dark.ActionBar&quot; app:contentScrim=&quot;@color/design_default_color_primary&quot; app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot;&gt; &lt;ImageView android:id=&quot;@+id/fruitImageView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:fitsSystemWindows=&quot;true&quot; android:scaleType=&quot;centerCrop&quot; app:layout_collapseMode=&quot;parallax&quot; /&gt; &lt;androidx.appcompat.widget.Toolbar android:id=&quot;@+id/toolbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; app:layout_collapseMode=&quot;pin&quot; /&gt; &lt;/com.google.android.material.appbar.CollapsingToolbarLayout&gt; &lt;/com.google.android.material.appbar.AppBarLayout&gt; ... &lt;/androidx.coordinatorlayout.widget.CoordinatorLayout&gt; 然后需要在程序的主题中将状态栏颜色指定成透明色。指定成透明色的方法很简单，在主题中将android:statusBarColor属性的值指定成@android:color/transparent即可。 打开res/values/themes.xml文件，对主题的内容进行修改，如下所示： &lt;resources xmlns:tools=&quot;http://schemas.android.com/tools&quot;&gt; &lt;style name=&quot;Theme.MaterialTest&quot; parent=&quot;Theme.MaterialComponents.Light.NoActionBar&quot;&gt; ... &lt;/style&gt; &lt;style name=&quot;FruitActivityTheme&quot; parent=&quot;Theme.MaterialTest&quot;&gt; &lt;item name=&quot;android:statusBarColor&quot;&gt;@android:color/transparent&lt;/item&gt; &lt;/style&gt; &lt;/resources&gt; 这里定义了一个FruitActivityTheme主题，并将其中状态栏的颜色指定成透明色，它是专门给FruitActivity使用的。 最后，修改 AndroidManifest.xml 中的代码，让FruitActivity使用这个主题，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.materialtest&quot;&gt; &lt;application ... &lt;activity android:name=&quot;.FruitActivity&quot; android:theme=&quot;@style/FruitActivityTheme&quot;&gt;&lt;/activity&gt; ... &lt;/application&gt; &lt;/manifest&gt; 这里使用android:theme属性单独给 FruitActivity 指定了FruitActivityTheme这个主题。 重新运行程序，效果如下： 可以发现，系统状态栏和背景图融合到一起了。 ","link":"https://Petrichoroo.github.io/post/material-design-she-ji/"},{"title":"Kotlin：使用协程编写高效的并发程序","content":" Kotlin 协程的基本用法 更多的作用域构造器 使用协程简化回调的写法 Kotlin 协程的基本用法 线程需要依靠操作系统的调度才能实现不同线程之间的切换，而使用协程可以仅在编程语言的层面就能实现不同协程之间的切换，从而提升了并发编程的运行效率。 Kotlin 没有将协程纳入标准库的 API 当中，而是以依赖库的形式提供，可到Github查看最新版本，然后在app/build.gradle文件当中添加如下依赖库： dependencies { ... implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-core:1.6.4&quot; implementation &quot;org.jetbrains.kotlinx:kotlinx-coroutines-android:1.6.4&quot; //Android项目中使用 } 如何开启一个协程？最简单的方式就是使用Global.launch函数，如下所示： fun main() { GlobalScope.launch { println(&quot;codes run in coroutine scope&quot;) } } GlobalScope.launch函数创建一个协程的作用域，这样传递给launch函数的代码块（Lambda表达式）就是在协程中运行的了。 运行main()函数，我们会发现是没有日志输出的。由于Global.launch函数每次创建的都是一个顶层协程，这种协程当应用程序运行结束时也会跟着一起结束，因此代码块中的代码还没来得及运行时，应用程序就结束了。 runBlocking函数可以应用程序在协程中所有代码都运行完了之后再结束，如下： fun main() { runBlocking { println(&quot;codes run in coroutine scope&quot;) delay(1500) println(&quot;codes run in coroutine scope finished&quot;) } } delay()函数让当前协程延迟指定时间后再运行，但它和Thread.sleep()方法不同。 delay() 函数是一个非阻塞式的挂起函数，它只会挂起当前协程，并不会影响其他协程的运行。而Thread.sleep() 方法会阻塞当前的线程，这样运行在该线程下的所有协程都会被阻塞。 注意，delay() 函数只能在协程的作用域或其他挂起函数中调用。 runBlocking函数会创建一个协程的作用域，它可以保证在协程作用域内的所有代码和子协程没有全部执行完之前一直阻塞当前线程。 需要注意的是，runBlocking函数通常只应该在测试环境下使用，在正式环境中使用容易产生一些性能上的问题。 launch函数可以创建多个协程，如下所示： fun main() { runBlocking { launch { println(&quot;launch1&quot;) delay(1000) println(&quot;launch1 finished&quot;) } launch { println(&quot;launch2&quot;) delay(1000) println(&quot;launch2 finished&quot;) } } } 注意这里的launch函数和刚才所使用的GlobalScope.launch函数不同。首先它必须在协程的作用域中才能调用，其次它会在当前协程的作用域下创建子协程。子协程的特点是如果外层作用域的协程结束了，该作用域下的所有子协程也会一同结束。 不过，随着launch函数中的逻辑越来越复杂，可能需要将部分代码提取到一个单独的函数中。这个时候就产生了一个问题：在 launch 函数中编写的代码是拥有协程作用域的，但是提取到一个单独的函数中就没有协程作用域了，那么该如何调用像delay()这样的挂起函数呢？ 为此 Kotlin 提供了一个suspend关键字，使用它可以将任意函数声明成挂起函数，而挂起函数之间都是可以互相调用的，如下所示： suspend fun printDot() { println(&quot;.&quot;) delay(1000) } suspend关键字只能将一个函数声明成挂起函数，是无法给它提供协程作用域的。 比如尝试在printDot()函数中调用 launch 函数，一定是无法调用成功的，因为 launch 函数要求必须在协程作用域当中才能调用。 这个问题可以借助coroutineScope函数来解决。coroutineScope 函数也是一个挂起函数，因此可以在任何其他挂起函数中调用。它的特点是会继承外部的协程的作用域并创建一个子协程，借助这个特性，我们就可以给任意挂起函数提供协程作用域。示例写法如下： suspend fun printDot() = coroutineScope { launch { println(&quot;.&quot;) delay(1000) } } 另外，coroutineScope函数和runBlocking函数还有点类似，它可以保证其作用域内的所有代码和子协程在全部执行完之前，外部的协程会一直被挂起。示例代码如下： fun main() { runBlocking { coroutineScope { launch { for (i in 1..10) { println(i) delay(1000) } } } println(&quot;coroutineScope finished&quot;) } println(&quot;runBlocking finished&quot;) } 这里先使用runBlocking函数创建了一个协程作用域，然后调用coroutineScope函数创建了一个子协程。在 coroutineScope 的作用域中，又调用 launch 函数创建了一个子协程。 运行main()函数，控制台会以 1 秒钟的间隔依次输出数字 1 到 10，然后才会打印coroutineScope函数结尾的日志，最后打印runBlocking函数结尾的日志。 由此可见，coroutineScope 函数确实是将外部协程挂起了，只有当它作用域内的所有代码和子协程都执行完毕之后，coroutineScope 函数之后的代码才能得到运行。 coroutineScope函数只会阻塞当前协程，既不影响其它协程，也不影响任何线程，因此是不会造成性能上的问题。而runBlocking函数由于会挂起外部线程，若在主线程中当中调用它的话，那么就有可能会导致界面卡死的情况，所以不太推荐在实际项目中使用。 更多的作用域构造器 GlobalScope.launch、runBlocking、launch、coroutineScope这几种作用域构建器，它们都可以用于创建一个新的协程作用域。不过 GlobalScope.launch 和 runBlocking 函数是可以在任意地方调用的，coroutineScope 函数可以在协程作用域或挂起函数中调用，而 launch 函数只能在协程作用域中调用。 如何取消协程呢？其实不管是GlobalScope.launch函数还是launch函数，它们都会返回一个Job对象，只需要调用 Job 对象的cancel()方法就可以取消协程了，实际项目中比较常用的写法如下所示： val job = Job() val scope = CoroutineScope(job) scope.launch { // 处理具体的逻辑 } job.cancel() 这里先创建了一个Job对象，然后把它传入CoroutineScope()函数当中，这个函数会返回一个 CoroutineScope 对象，有了这个对象之后，就可以随时调用它的launch函数来创建一个协程。 现在所有调用CoroutineScope的launch函数所创建的协程，都会被关联在Job对象的作用域下面。这样只需要调用一次cancel()方法，就可以将同一作用域内的所有协程全部取消，从而大大降低了协程管理的成本。 调用launch函数可以创建一个新的协程，但是 launch 函数只能用于执行一段逻辑，却不能获取执行的结果，因为它的返回值永远是一个Job对象。 那么有没有什么办法能够创建一个协程并获取它的执行结果呢？使用async函数就可以实现。 async函数必须在协程作用域当中才能调用，它会创建一个新的子协程并返回一个Deferred对象，如果想要获取 async 函数代码块的执行结果，只需要调用 Deferred 对象的await()方法即可，代码如下所示： fun main() { runBlocking { val result = async { 5 + 5 }.await() println(result) //日志输出10 } } 注意，在调用了async函数之后，代码块中的代码就会立刻开始执行。当调用await()方法时，如果代码块中的代码还没执行完，那么 await() 方法会将当前协程阻塞住，直到可以获得 async 函数的执行结果。 注意，可以不用在每次调用async函数之后就立刻使用await()方法获取结果，而是仅在需要用到 async 函数的执行结果时才调用 await() 方法进行获取，这样两个 async 函数就变成一种并行关系，即两个async函数完全可以同时执行任务从而提高运行效率。 withContext()函数是一个挂起函数，示例写法如下： fun main() { runBlocking { val result = withContext(Dispatchers.Default) { 5 + 5 } println(result) //日志输出10 } } 调用withContext()函数之后，会立即执行代码块中的代码，同时将外部协程挂起。当代码块中的代码全部执行完之后，会将最后一行的执行结果作为 withContext() 函数的返回值返回。 注意，withContext()函数强制要求我们指定一个线程参数。 线程参数主要有以下 3 种值可选： Dispatchers.Default：表示会使用一种默认低并发的线程策略，当要执行的代码属于计算密集型任务时，开启过高的并发反而可能会影响任务的运行效率。 Dispatchers.IO：表示会使用一种较高并发的线程策略，当要执行的代码大多数时间是在阻塞和等待中，比如说执行网络请求时，为了能够支持更高的并发数量。 Dispatchers.Main：表示不会开启子线程，而是在 Android 主线程中执行代码，但是这个值只能在 Android 项目中使用，纯 Kotlin 程序使用这种类型的线程参数会出现错误。 使用协程简化回调的写法 回调机制基本上是依靠匿名类来实现的，但是匿名类的写法通常比较烦琐。比如如下代码： HttpUtil.sendHttpRequest(address, object : HttpCallbackListener { override fun onFinish(response: String) { // 得到服务器返回的具体内容 } override fun onError(e: Exception) { // 在这里对异常情况进行处理 } }) 在多少个地方发起网络请求，就需要编写多少次这样的匿名类实现。而借助suspendCoroutine函数就能将传统回调机制的写法大幅简化。 suspendCoroutine函数必须在协程作用域或挂起函数中才能调用，它接收一个 Lambda 表达式参数，主要作用是将当前协程立即挂起，然后在一个普通的线程中执行 Lambda 表达式中的代码。 Lambda 表达式的参数列表上会传入一个Continuation参数，调用它的resume()方法或resumeWithException()可以让协程恢复执行。 首先定义一个request()函数，代码如下所示： suspend fun request(address: String): String { return suspendCoroutine { continuation -&gt; HttpUtil.sendHttpRequest(address, object : HttpCallbackListener { override fun onFinish(response: String) { continuation.resume(response) } override fun onError(e: Exception) { continuation.resumeWithException(e) } }) } } 可以看到，request()函数是一个挂起函数，并且接收一个address参数。在 request() 函数的内部，调用了suspendCoroutine函数，这样当前协程就会被立刻挂起，而 Lambda 表达式中的代码则会在普通线程中执行。 接着我们在 Lambda 表达式中调用HttpUtil.sendHttpRequest()方法发起网络请求，并通过传统回调的方式监听请求结果。如果请求成功就调用 Continuation 的resume()方法恢复被挂起的协程，并传入服务器响应的数据，该值会成为 suspendCoroutine 函数的返回值。如果请求失败，就调用 Continuation 的resumeWithException()恢复被挂起的协程，并传入具体的异常原因。 之后，不管要发起多少次网络请求，都不需要再重复进行回调实现。比如说获取百度首页的响应数据，可以这样写： suspend fun getBaiduResponse() { try { val response = request(&quot;https://www.baidu.com/&quot;) // 对服务器响应的数据进行处理 } catch (e: Exception) { // 对异常情况进行处理 } } 由于getBaiduResponse()是一个挂起函数，因此当它调用了request()函数时，当前的协程就会被立刻挂起，然后一直等待网络请求成功或失败后，当前协程才能恢复运行。这样即使不使用回调的写法，我们也能够获得异步网络请求的响应数据，而如果请求失败，则会直接进入catch语句当中。 注意，getBaiduResponse()函数被声明成了挂起函数，这样它也只能在协程作用域或其他挂起函数中调用了。但是可以通过合理的项目架构设计，轻松地将各种协程的代码应用到一个普通的项目当中。 事实上，suspendCoroutine函数几乎可以用于简化任何回调的写法，比如之前使用Retrofit来发起网络请求需要这样写： val appService = ServiceCreator.create&lt;AppService&gt;() appService.getAppData().enqueue(object : Callback&lt;List&lt;App&gt;&gt; { override fun onResponse(call: Call&lt;List&lt;App&gt;&gt;, response: Response&lt;List&lt;App&gt;&gt;) { // 得到服务器返回的数据 } override fun onFailure(call: Call&lt;List&lt;App&gt;&gt;, t: Throwable) { // 在这里对异常情况进行处理 } }) 使用suspendCoroutine函数，可以对上述写法进行大幅度的简化。 由于不同的Service接口返回的数据类型也不同，所以这次不能像刚才那样针对具体的类型进行编程了，而是要使用泛型的方式。定义一个await()函数，代码如下所示： suspend fun &lt;T&gt; Call&lt;T&gt;.await(): T { return suspendCoroutine { continuation -&gt; enqueue(object : Callback&lt;T&gt; { override fun onResponse(call: Call&lt;T&gt;, response: Response&lt;T&gt;) { val body = response.body() if (body != null) continuation.resume(body) else continuation.resumeWithException( RuntimeException(&quot;response body is null&quot;) ) } override fun onFailure(call: Call&lt;T&gt;, t: Throwable) { continuation.resumeWithException(t) } }) } } 这里await()函数仍然是一个挂起函数，然后给它声明了一个泛型T，并将 await() 函数定义成了Call&lt;T&gt;的扩展函数，这样所有返回值是Call类型的Retrofit网络请求接口就都可以直接调用 await() 函数了。 接着，await()函数中使用了suspendCoroutine函数来挂起当前协程，并且由于扩展函数的原因，我们现在拥有了Call对象的上下文，那么这里就可以直接调用enqueue()方法让 Retrofit 发起网络请求。接下来，使用同样的方式对 Retrofit 响应的数据或者网络请求失败的情况进行处理即可。 另外还有一点需要注意，在onResponse()回调当中，我们调用body()方法解析出来的对象是可能为空的。如果为空的话，这里的做法是手动抛出一个异常，我们也可以根据自己的逻辑进行更加合适的处理。 有了await()函数之后，调用所有Retrofit的Service接口都会变得极其简单，比如刚才同样的功能就可以使用如下写法进行实现： suspend fun getAppData() { try { val appList = ServiceCreator.create&lt;AppService&gt;().getAppData().await() // 对服务器响应的数据进行处理 } catch (e: Exception) { // 对异常情况进行处理 } } 没有了冗长的匿名类实现，只需要简单调用一下await()函数就可以让Retrofit发起网络请求，并直接获得服务器响应的数据。 每次发起网络请求都要进行一次try catch处理也比较麻烦，其实这里也可以选择不处理。在不处理的情况下，如果发生了异常就会一层层向上抛出，一直到被某一层的函数处理了为止。因此，我们也可以在某个统一的入口函数中只进行一次try catch，从而让代码变得更加精简。 ","link":"https://Petrichoroo.github.io/post/kotlinshi-yong-xie-cheng-bian-xie-gao-xiao-de-bing-fa-cheng-xu/"},{"title":"Retrofit 网络库","content":" Retrofit Retrofit 的基本用法 处理复杂的接口地址类型 Retrofit 构建器的最佳写法 Retrofit Retrofit 的基本用法 OkHttp 侧重的是底层通信的实现，而 Retrofit 侧重的是上层接口的封装。事实上，Retrofit 就是 Square 公司在 OkHttp 的基础上进一步开发出来的应用层网络通信库，使得我们可以用更加面向对象的思维进行网络操作。 Retrofit的基本设计思想。Retrofit 的设计基于以下几个事实： 同一款应用程序中所发起的网络请求绝大多数指向的是同一个服务器域名。 服务器提供的接口通常是可以根据功能来归类的。比如新增用户、修改用户数据等接口可以归为一类，上架新书、销售图书等接口也可以归为一类。将服务器接口合理归类能够让代码结构变得更加合理，从而提高可阅读性和可维护性。 开发者更加习惯于“调用一个接口，获取它的返回值”这样的编码方式，但当调用的是服务器接口时，却很难想象该如何使用这样的编码方式。其实大多数人并不关心网络的具体通信细节，但是传统网络库的用法却需要编写太多网络相关的代码。 而Retrofit的用法就是基于以上几点来设计的，首先我们可以配置好一个根路径，然后在指定服务器接口地址时只需要使用相对路径即可，这样就不用每次都指定完整的URL地址了。 另外，Retrofit允许我们对服务器接口进行归类，将功能同属一类的服务器接口定义到同一个接口文件当中，从而让代码结构变得更加合理。 最后，我们也不用关心网络通信的细节，只需要在接口文件中声明一系列方法和返回值，然后通过注解的方式指定该方法对应哪个服务器接口，以及需要提供哪些参数。当在程序中调用该方法时，Retrofit会自动向对应的服务器接口发起请求，并将响应的数据解析成返回值声明的类型。这就使得我们可以用更加面向对象的思维来进行网络操作。 为了使用Retrofit，我们需要先在项目中添加必要的依赖库，可到GitHub查看最新版本，然后编辑app/build.gradle文件，在dependencies闭包中添加如下内容： dependencies { ... implementation 'com.squareup.retrofit2:retrofit:2.9.0' implementation 'com.squareup.retrofit2:converter-gson:2.9.0' } 由于Retrofit是基于 OkHttp 开发的，因此添加上述第一条依赖会自动将Retrofit、OkHttp 和 Okio这几个库一起下载，我们无须再手动引入OkHttp库。 另外，Retrofit还会将服务器返回的JSON数据自动解析成对象，因此上述第二条依赖就是一个 Retrofit 的转换库，它是借助GSON来解析 JSON 数据的，所以会自动将 GSON 库一起下载下来，这样我们也不用手动引入 GSON 库了。 之前在 Apache 安装目录下的 htdocs 中创建了一个名为get_data.json的文件，里面的数据如下： [{&quot;id&quot;:&quot;5&quot;,&quot;version&quot;:&quot;5.5&quot;,&quot;name&quot;:&quot;Clash of Clans&quot;}, {&quot;id&quot;:&quot;6&quot;,&quot;version&quot;:&quot;7.0&quot;,&quot;name&quot;:&quot;Boom Beach&quot;}, {&quot;id&quot;:&quot;7&quot;,&quot;version&quot;:&quot;3.5&quot;,&quot;name&quot;:&quot;Clash Royale&quot;}] 由于Retrofit会借助 GSON 将 JSON 数据转换成对象，因此这里同样需要新增一个App类，并加入id、name和version这 3 个字段，如下所示： class App(val id: String, val name: String, val version: String) 接下来，我们可以根据服务器接口的功能进行归类，创建不同种类的接口文件，并在其中定义对应具体服务器接口的方法。 不过由于我们的 Apache 服务器上其实只有一个获取JSON数据的接口，因此这里只需要定义一个接口文件，并包含一个方法即可。新建AppService接口，代码如下所示： interface AppService { @GET(&quot;get_data.json&quot;) fun getAppData(): Call&lt;List&lt;App&gt;&gt; } 通常Retrofit的接口文件建议以具体的功能种类名开头，并以Service结尾，这是一种比较好的命名习惯。 上述代码中有两点需要注意。 在getAppData()方法上面添加的注解，这里使用了一个@GET注解，表示当调用 getAppData() 方法时 Retrofit 会发起一条GET请求，请求的地址就是我们在 @GET 注解中传入的具体参数。注意，这里只需要传入请求地址的相对路径即可，根路径我们会在稍后设置。 getAppData()方法的返回值必须声明成 Retrofit 中内置的Call类型，并通过泛型来指定服务器响应的数据应该转换成什么对象。由于服务器响应的是一个包含App数据的 JSON 数组，因此这里我们将泛型声明成List&lt;App&gt;。当然，Retrofit 还提供了强大的Call Adapters功能来允许我们自定义方法返回值的类型。 为了使用AppService接口，我们在界面上添加一个按钮用于简单的测试。修改 activity_main.xml 中的代码，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:id=&quot;@+id/getAppDataBtn&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Get App Data&quot; android:textAllCaps=&quot;false&quot; /&gt; &lt;/LinearLayout&gt; 然后修改 MainActivity 中的代码，如下所示： class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val getAppDataBtn: Button = findViewById(R.id.getAppDataBtn) getAppDataBtn.setOnClickListener { //使用Retrofit.Builder()构建一个Retrofit对象 val retrofit = Retrofit.Builder() .baseUrl(&quot;http://10.0.2.2&quot;) //指定所有Retrofit请求的根路径 .addConverterFactory(GsonConverterFactory.create()) //指定Retrofit在解析数据时所使用的转换库 .build() val appService = retrofit.create(AppService::class.java) //创建一个AppService接口的动态代理对象 appService.getAppData().enqueue(object : Callback&lt;List&lt;App&gt;&gt; { //Retrofit就会根据注解中配置的服务器接口地址去进行网络请求 override fun onResponse(call: Call&lt;List&lt;App&gt;&gt;, response: Response&lt;List&lt;App&gt;&gt;) { val list = response.body() if (list != null) { for (app in list) { Log.d(&quot;MainActivity&quot;, &quot;id is ${app.id}&quot;) Log.d(&quot;MainActivity&quot;, &quot;name is ${app.name}&quot;) Log.d(&quot;MainActivity&quot;, &quot;version is ${app.version}&quot;) } } } override fun onFailure(call: Call&lt;List&lt;App&gt;&gt;, t: Throwable) { t.printStackTrace() } }) } } } 通过Retrofit.Builder构建一个Retrofit对象后，调用它的create()方法并传入具体 Service 接口所对应的Class类型，创建一个该接口的动态代理对象。有了动态代理对象之后，我们就可以随意调用接口中定义的所有方法，而 Retrofit 会自动执行具体的处理。 当调用了 AppService 的getAppData()方法时，会返回一个Call&lt;List&lt;App&gt;&gt;对象，这时我们再调用一下它的enqueue()方法，Retrofit 就会根据注解中配置的服务器接口地址去进行网络请求了，服务器响应的数据会回调到enqueue()方法中传入的Callback实现里面。 需要注意的是，当发起请求的时候，Retrofit 会自动在内部开启子线程，当数据回调到 Callback 中之后，Retrofit 又会自动切换回主线程，整个操作过程中我们都不用考虑线程切换问题。 在 Callback 的onResponse()方法中，调用response.body()方法将会得到 Retrofit 解析后的对象，也就是List&lt;App&gt;类型的数据，最后遍历 List，将其中的数据打印出来即可。 这里使用的服务器接口是 HTTP，因此需要进行网络安全配置，将之前所用到的network_config.xml文件复制到此项目中。然后修改 AndroidManifest.xml 中的代码，如下所示： &lt;manifest xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; package=&quot;com.example.retrofittest&quot;&gt; &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; &lt;application ... android:networkSecurityConfig=&quot;@xml/network_config&quot;&gt; ... &lt;/application&gt; &lt;/manifest&gt; 这里设置了允许使用明文的方式来进行网络请求，同时声明了网络权限。然后运行此项目，然后点击“Get App Data”按钮，观察 Logcat 中的打印日志，如下图所示： 处理复杂的接口地址类型 上面的示例程序只是向一个非常简单的服务器接口地址发送请求，然而在真实的开发环境当中，服务器所提供的接口地址不可能一直如此简单。 为了方便举例，这里先定义一个Data类，并包含id和content这两个字段，如下所示： class Data(val id: String, val content: String) 先从最简单的看起，比如服务器的接口地址如下所示： GET http://example.com/get_data.json 这是最简单的一种情况，接口地址是静态的，永远不会改变。那么对应到 Retrofit 当中，使用如下的写法即可： interface ExampleService { @GET(&quot;get_data.json&quot;) fun getData(): Call&lt;Data&gt; } 但是显然服务器不可能总是给我们提供静态类型的接口，在很多场景下，接口地址中的部分内容可能会是动态变化的，比如如下的接口地址： GET http://example.com/&lt;page&gt;/get_data.json 在这个接口当中，&lt;page&gt;部分代表页数，我们传入不同的页数，服务器返回的数据也会不同。这种接口地址对应到 Retrofit 中写法如下： interface ExampleService { @GET(&quot;{page}/get_data.json&quot;) fun getData(@Path(&quot;page&quot;) page: Int): Call&lt;Data&gt; } 在@GET注解指定的接口地址当中，这里使用了一个{page}的占位符，然后又在getData()方法中添加了一个 page 参数，并使用@Path(&quot;page&quot;)注解来声明这个参数。这样当调用 getData() 方法发起请求时，Retrofit 就会自动将page参数的值替换到占位符的位置，从而组成一个合法的请求地址。 另外，很多服务器接口还会要求我们传入一系列的参数，格式如下： GET http://example.com/get_data.json?u=&lt;user&gt;&amp;t=&lt;token&gt; 这是一种标准的带参数GET请求的格式。接口地址的最后使用问号来连接参数部分，每个参数都是一个使用等号连接的键值对，多个参数之间使用“&amp;”符号进行分隔。 那么很显然，在上述地址中，服务器要求我们传入user和token这两个参数的值。对于这种格式的服务器接口，我们可以使用@Path注解的方式来解决，但是这样会有些麻烦，Retrofit 针对这种带参数的GET请求，专门提供了一种语法支持： interface ExampleService { @GET(&quot;get_data.json&quot;) fun getData(@Query(&quot;u&quot;) user: String, @Query(&quot;t&quot;) token: String): Call&lt;Data&gt; } 这里在getData()方法中添加了user和token这两个参数，并使用@Query注解对它们进行声明。这样当发起网络请求的时候，Retrofit 就会自动按照带参数GET请求的格式将这两个参数构建到请求地址当中。 HTTP有很多种类型，其中比较常用的有GET、POST、PUT、PATCH、DELETE这几种。它们之间的分工也很明确，简单概括的话，GET 请求用于从服务器获取数据，POST 请求用于向服务器提交数据，PUT 和 PATCH 请求用于修改服务器上的数据，DELETE 请求用于删除服务器上的数据。 而 Retrofit 对所有常用的 HTTP 请求类型都进行了支持，使用@GET、@POST、@PUT、@PATCH、@DELETE注解，就可以让 Retrofit 发出相应类型的请求了。 比如服务器提供了如下接口地址： DELETE http://example.com/data/&lt;id&gt; 这种接口通常意味着要根据id删除一条指定的数据，而我们在 Retrofit 当中想要发出这种请求就可以这样写： interface ExampleService { @DELETE(&quot;data/{id}&quot;) fun deleteData(@Path(&quot;id&quot;) id: String): Call&lt;ResponseBody&gt; } 这里使用了@DELETE注解来发出DELETE类型的请求，并使用了@Path注解来动态指定id。 但是在返回值声明的时候，将Call的泛型指定成了ResponseBody，这是什么意思呢？ 由于 POST、PUT 、PATCH、DELETE 这几种请求类型与GET请求不同，它们更多是用于操作服务器上的数据，而不是获取服务器上的数据，所以通常它们对于服务器响应的数据并不关心。 这个时候就可以使用ResponseBody，表示 Retrofit 能够接收任意类型的响应数据，并且不会对响应数据进行解析。 那么如果我们需要向服务器提交数据该怎么写呢？比如如下的接口地址： POST http://example.com/data/create {&quot;id&quot;: 1, &quot;content&quot;: &quot;The description for this data.&quot;} 使用POST请求来提交数据，需要将数据放到 HTTP 请求的body部分，这个功能在 Retrofit 中可以借助@Body注解来完成： interface ExampleService { @POST(&quot;data/create&quot;) fun createData(@Body data: Data): Call&lt;ResponseBody&gt; } 这里在createData()方法中声明了一个Data类型的参数，并加上了@Body注解。这样当 Retrofit 发出POST请求时，就会自动将 Data 对象中的数据转换成 JSON 格式的文本，并放到 HTTP 请求的body部分，服务器在收到请求之后只需要从 body 中将这部分数据解析出来即可。这种写法同样也可以用来给 PUT、PATCH、DELETE 类型的请求提交数据。 最后，有些服务器接口还可能会要求我们在HTTP请求的header中指定参数，比如： GET http://example.com/get_data.json User-Agent: okhttp Cache-Control: max-age=0 这些header参数其实就是一个个的键值对，我们可以在 Retrofit 中直接使用@Headers注解来对它们进行声明。 interface ExampleService { @Headers(&quot;User-Agent: okhttp&quot;, &quot;Cache-Control: max-age=0&quot;) @GET(&quot;get_data.json&quot;) fun getData(): Call&lt;Data&gt; } 但是这种写法只能进行静态header声明，如果想要动态指定 header 的值，则需要使用@Header注解，如下所示： interface ExampleService { @GET(&quot;get_data.json&quot;) fun getData(@Header(&quot;User-Agent&quot;) userAgent: String, @Header(&quot;Cache-Control&quot;) cacheControl: String): Call&lt;Data&gt; } 现在当发起网络请求时，Retrofit 就会自动将参数中传入的值设置到User-Agent和Cache-Control这两个 header 当中，从而实现了动态指定 header 值的功能。 Retrofit 构建器的最佳写法 获取 Service 接口的动态代理对象的写法是比较麻烦的，比如想要得到AppService的动态代理对象，需要先使用Retrofit.Builder构建出一个Retrofit对象，然后再调用它的create()方法创建动态代理对象。 由于构建出的Retrofit对象是全局通用的，只需要在调用create()方法时针对不同的 Service 接口传入相应的Class类型即可。 因此，我们可以将通用的这部分功能封装起来，从而简化获取 Service 接口动态代理对象的过程。 新建一个ServiceCreator单例类，代码如下所示： object ServiceCreator { private const val BASE_URL = &quot;http://10.0.2.2/&quot; private val retrofit = Retrofit.Builder() .baseUrl(BASE_URL) .addConverterFactory(GsonConverterFactory.create()) .build() fun &lt;T&gt; create(serviceClass: Class&lt;T&gt;): T = retrofit.create(serviceClass) } 这里使用object关键字让ServiceCreator成为了一个单例类，并在它的内部定义了一个BASE_URL常量，用于指定 Retrofit 的根路径。 然后同样是在内部使用Retrofit.Builder构建一个 Retrofit 对象，注意这些都是用 private 修饰符来声明的，相当于对于外部而言它们都是不可见的。 最后，提供了一个外部可见的create()方法，并接收一个Class类型的参数。当在外部调用这个方法时，实际上就是调用了 Retrofit 对象的 create() 方法，从而创建出相应Service接口的动态代理对象。 经过这样的封装之后，Retrofit 的用法将会变得异常简单，比如我们想获取一个AppService接口的动态代理对象，只需要使用如下写法即可： val appService = ServiceCreator.create(AppService::class.java) 之后就可以随意调用 AppService 接口中定义的任何方法了 不过上述代码可以通过泛型实化功能来进行优化，修改 ServiceCreator 中的代码，如下所示： object ServiceCreator { ... inline fun &lt;reified T&gt; create(): T = create(T::class.java) } 这里又定义了一个不带参数的create()方法，并使用inline关键字来修饰方法，使用reified关键字来修饰泛型，这是泛型实化的两大前提条件。 接下来就可以使用T::class.java这种语法了，这里调用刚才定义的带有 Class 参数的create()方法即可。 那么现在就又有了一种新的方式来获取AppService接口的动态代理对象，如下所示： val appService = ServiceCreator.create&lt;AppService&gt;() ","link":"https://Petrichoroo.github.io/post/retrofit-wang-luo-ku/"},{"title":"Kotlin：泛型的高级特性","content":" Kotlin 对泛型进行实化 泛型实化的应用 泛型的协变 泛型的逆变 Kotlin 对泛型进行实化 在 JDK 1.5 中，Java 引入了泛型。Java 的泛型功能是通过类型擦除机制来实现的。这种机制就是说泛型对于类型的约束只在编译时期存在，在进入 JVM 之前，与泛型相关的信息会被擦除掉，运行时 JVM 是识别不出来我们在代码中指定的泛型类型的。 类型擦除，是泛型能够与之前的 java 版本代码兼容共存的原因。 例如，假设我们创建了一个List&lt;String&gt;集合，虽然在编译时期只能向集合中添加字符串类型的元素，但是在运行时期 JVM 并不能知道它本来只打算包含哪种类型的元素，只能识别出来它是个List。 所有基于 JVM 的语言，它们的泛型功能都是通过类型擦除机制来实现的，其中当然也包括了 Kotlin。这种机制使得我们不可能使用a is T或者T::class.java这样的语法，因为T的实际类型在运行的时候已经被擦除了。 然而不同的是，Kotlin 提供了一个内联函数的概念。内联函数中的代码会在编译的时候自动被替换到调用它的地方，这样的话也就不存在什么泛型擦除的问题了，因为代码在编译之后会直接使用实际的类型来替代内联函数中的泛型声明，其工作原理如下图所示： 最终代码会被替换成下图所示的样子： 可以看到，bar()是一个带有泛型类型的内联函数，foo()函数调用了 bar() 函数，在代码编译之后，bar() 函数中的代码将可以获得泛型的实际类型。 这就意味着，Kotlin 中是可以将内联函数中的泛型进行实化的。 如何让才能将泛型实化呢？首先，该函数必须是内联函数，即用inline关键字来修饰该函数。其次，在声明泛型的地方必须加上reified关键字来表示该泛型要进行实化。示例代码如下： inline fun &lt;reified T&gt; getGenericType() { } 上述函数中的泛型T就是一个被实化的泛型，下面实现一个获取泛型实际类型的功能，代码如下所示： inline fun &lt;reified T&gt; getGenericType() = T::class.java getGenericType()函数直接返回了当前指定泛型的实际类型。T.class这样的语法在 Java 中是不合法的，而在 Kotlin 中，借助泛型实化功能就可以使用T::class.java这样的语法了。现在我们可以使用如下代码对 getGenericType() 函数进行测试： fun main() { val result1 = getGenericType&lt;String&gt;() val result2 = getGenericType&lt;Int&gt;() println(&quot;result1 is $result1&quot;) println(&quot;result2 is $result2&quot;) } 这里给getGenericType()函数指定了两种不同的泛型，由于 getGenericType() 函数会将指定泛型的具体类型返回，因此这里我们将返回的结果进行打印，如下： 泛型实化的应用 使用 Intent 启动一个 Activity ： val intent = Intent(context, TestActivity::class.java) context.startActivity(intent) TestActivity::class.java这样的语法是很难受的，Kotlin 的泛型实化功能使得我们拥有了更好的选择。新建一个reified.kt文件，然后在里面编写如下代码： inline fun &lt;reified T&gt; startActivity(context: Context) { val intent = Intent(context, T::class.java) context.startActivity(intent) } 这里同时使用inline和reified关键字让泛型T成为了一个被实化的泛型，因此在 Intent 接受的第二个参数里可以直接传入T::class.java。 现在启动 TestActivity，只需要这样写即可： startActivity&lt;TestActivity&gt;(context) Kotlin 将能够识别出指定泛型的实际类型，并启动相应的 Activity。 通常在启用 Activity 的时候可能会使用 Intent 附带一些参数，而经过刚才的封装之后，我们就无法进行传参了。 使用高阶函数可以解决这个问题，在reified.kt文件中添加一个新的startActivity()函数重载，如下所示： inline fun &lt;reified T&gt; startActivity(context: Context, block: Intent.() -&gt; Unit) { val intent = Intent(context, T::class.java) intent.block() context.startActivity(intent) } 这里在startActivity()函数中增加了一个函数类型参数，并且它的函数类型是定义在Intent类当中的。在创建完 Intent 的实例之后，随即调用该函数类型参数，并把 Intent 的实例传入，这样调用 startActivity() 函数的时候就可以在 Lambda 表达式中为 Intent 传递参数了，如下所示： startActivity&lt;TestActivity&gt;(context) { putExtra(&quot;param1&quot;, &quot;data&quot;) putExtra(&quot;param2&quot;, 123) } 泛型的协变 Kotlin 的内置 API 中使用了很多协变和逆变的特性。 一个泛型类或者泛型接口中的方法，它的参数列表是接收数据的地方，因此可以称它为in位置，而它的返回值是输出数据的地方，因此可以称它为out位置。如下图所示： 首先定义如下 3 个类： open class Person(val name: String, val age: Int) class Student(name: String, age: Int) : Person(name, age) class Teacher(name: String, age: Int) : Person(name, age) 这里先定义了一个Person类，类中包含name和age两个字段。然后又定义了Student和Teacher这两个类，让它们成为 Person 类的子类。 Student 是 Person 的子类，但List&lt;Student&gt;不能直接成为List&lt;Person&gt;的子类，否则将可能存在类型转换的安全隐患。 为什么会存在类型转换的安全隐患呢？下面通过一个具体的例子进行说明。自定义一个SimpleData类，代码如下所示： class SimpleData&lt;T&gt; { private var data: T? = null fun set(t: T?) { data = t } fun get(): T? { return data } } SimpleData 是一个泛型类，它的内部封装了一个泛型data字段，调用set()方法可以给 data 字段赋值，调用get()方法可以获取 data 字段的值。 假设：若编程语言允许向某个接收SimpleData&lt;Person&gt;参数的方法传入SimpleData&lt;Student&gt;的实例，那么如下代码就会是合法的： fun main() { val student = Student(&quot;Tom&quot;, 19) val data = SimpleData&lt;Student&gt;() data.set(student) handleSimpleData(data) // 实际上这行代码会报错，这里假设它能编译通过 val studentData = data.get() } fun handleSimpleData(data: SimpleData&lt;Person&gt;) { val teacher = Teacher(&quot;Jack&quot;, 35) data.set(teacher) } 在main()方法中创建一个Student的实例，并将它封装到SimpleData&lt;Student&gt;中，然后将 SimpleData 作为参数传递给handleSimpleData()方法。但是此方法接收一个SimpleData&lt;Person&gt;参数（这里假设可以编译通过），那么在 handleSimpleData() 方法中，我们就可以创建一个Teacher的实例，并用它来替换 SimpleData 参数中的原有数据。这种操作肯定是合法的，因为 Teacher 也是 Person 的子类。 但是问题马上来了，回到main()方法当中，我们调用SimpleData&lt;Student&gt;的get()方法来获取它内部封装的Student数据，可现在 SimpleData 中实际包含的却是一个 Teacher 的实例，那么此时必然会产生类型转换异常。 问题发生的主要原因是我们在handleSimpleData()方法中向 SimpleData 里设置了一个 Teacher 的实例。如果 SimpleData 在泛型T上是只读的话，肯定就没有类型转换的安全隐患了。 下面给出泛型协变的定义：假如定义了一个MyClass&lt;T&gt;的泛型类，其中 A 是 B 的子类型，同时 MyClass&lt;A&gt;又是MyClass&lt;B&gt;的子类型，那么我们就可以称MyClass在T这个泛型上是协变的。 但是如何才能让MyClass&lt;A&gt;成为MyClass&lt;B&gt;的子类型呢？即让MyClass&lt;T&gt;类中的所有方法都不能接收T类型的参数。换句话说，T只能出现在out位置上，而不能出现在in位置上。 修改 SimpleData 类的代码，如下所示： class SimpleData&lt;out T&gt;(val data: T?) { fun get(): T? { return data } } 这里对 SimpleData 类进行了改造，在泛型T的声明前面加上了一个out关键字。这就意味着现在 T 只能出现在 out 位置上，而不能出现在in位置上，同时也意味着SimpleData在泛型 T 上是协变的。 由于泛型 T 不能出现在 in 位置上，因此我们也就不能使用set()方法为 data 参数赋值了，所以这里改成了使用构造函数的方式来赋值。由于这里使用了val关键字，所以构造函数中的泛型 T 仍然是只读的。另外，即使我们使用了var关键字，但只要给它加上private修饰符，保证这个泛型T对于外部而言是不可修改的，那么就都是合法的写法。 经过了这样的修改之后，下面的代码就可以完美编译通过且没有任何安全隐患： fun main() { val student = Student(&quot;Tom&quot;, 19) val data = SimpleData&lt;Student&gt;(student) handleMyData(data) val studentData = data.get() } fun handleMyData(data: SimpleData&lt;Person&gt;) { val personData = data.get() } 由于 SimpleData 类进行了协变声明，那么SimpleData&lt;Student&gt;自然就是SimpleData&lt;Person&gt;的子类了，所以这里可以安全地向handleMyData()方法中传递参数。 然后在handleMyData()方法中去获取 SimpleData 封装的数据，虽然这里泛型声明的是 Person 类型，实际获得的会是一个 Student 的实例，但由于 Person 是 Student 的父类，向上转型是完全安全的。 如果某个方法接收一个List&lt;Person&gt;类型的参数，而传入的却是一个List&lt;Student&gt;的实例， 这在 Java 中是不允许的。而在 Kotlin 中是合法的，因为 Kotlin 已经默认给许多内置的 API 加上了协变声明，其中就包括了各种集合的类与接口。 Kotlin 中的List本身就是只读的，如果你想要给 List 添加数据，需要使用MutableList才行。既然 List 是只读的，也就意味着它天然就是可以协变的，下面来看一下 List 简化版的源码： public interface List&lt;out E&gt; : Collection&lt;E&gt; { override val size: Int override fun isEmpty(): Boolean override fun contains(element: @UnsafeVariance E): Boolean override fun iterator(): Iterator&lt;E&gt; public operator fun get(index: Int): E } List 在泛型E的前面加上了out关键字，说明 List 在泛型 E 上是协变的。 不过这里还有一点需要说明，原则上在声明了协变之后，泛型E就只能出现在out位置上，可是我们会发现，在contains()方法中，泛型 E 仍然出现在了in位置上。 这么写本身是不合法的，因为在in位置上出现了泛型E就意味着会有类型转换的安全隐患。但是 contains()方法的目的非常明确，它只是为了判断当前集合中是否包含参数中传入的这个元素，而并不会修改当前集合中的内容，因此这种操作实质上又是安全的。 为了让编译器能够理解这种操作是安全的，这里在泛型E的前面又加上了一个@UnsafeVariance注解，这样编译器就会允许泛型 E 出现在in位置上了。 泛型的逆变 泛型逆变的定义：假如定义了一个MyClass&lt;T&gt;的泛型类，其中 A 是 B 的子类型，同时MyClass&lt;B&gt;又是MyClass&lt;A&gt;的子类型，那么我们就可以称MyClass在T这个泛型上是逆变的。协变和逆变的区别如下图所示： 原本 A 是 B 的子类型，怎么MyClass&lt;B&gt;能反过来成为MyClass&lt;A&gt;的子类型了呢？ 这里先定义一个Transformer接口，用于执行一些转换操作，代码如下所示： interface Transformer&lt;T&gt; { fun transform(t: T): String } Transformer接口中声明了一个transform()方法，它接收一个T类型的参数，并且返回一个String类型的数据，这意味着参数 T 在经过 transform() 方法的转换之后将会变成一个字符串。至于具体的转换逻辑是什么样的，则由子类去实现。 下面尝试对Transformer接口进行实现，代码如下所示： fun main() { val trans = object : Transformer&lt;Person&gt; { override fun transform(t: Person): String { return &quot;${t.name} ${t.age}&quot; } } handleTransformer(trans) // 这行代码会报错 } fun handleTransformer(trans: Transformer&lt;Student&gt;) { val student = Student(&quot;Tom&quot;, 19) val result = trans.transform(student) } 首先在 main() 方法中编写了一个Transformer&lt;Person&gt;的匿名类实现，并通过transform()方法将传入的 Person 对象转换成了一个“姓名+年龄”拼接的字符串。而handleTransformer()方法接收的是一个Transformer&lt;Student&gt;类型的参数，这里在 handleTransformer() 方法中创建了一个 Student 对象，并调用参数的 transform() 方法将 Student 对象转换成一个字符串。 因为Student是Person的子类，使用Transformer&lt;Person&gt;的匿名类实现将 Student 对象转换成一个字符串也是绝对安全的，并不存在类型转换的安全隐患。但是实际上，在调用 handleTransformer() 方法的时候却会提示语法错误，原因也很简单，Transformer&lt;Person&gt;并不是Transformer&lt;Student&gt;的子类型。 那么这个时候逆变就可以派上用场了，它就是专门用于处理这种情况的。修改Transformer接口中的代码，如下所示： interface Transformer&lt;in T&gt; { fun transform(t: T): String } 这里在泛型T的声明前面加上了一个in关键字。这就意味着现在 T 只能出现在 in 位置上，而不能出现在 out 位置上，同时也意味着Transformer在泛型 T 上是逆变的。 此时Transformer&lt;Person&gt;已经成为了Transformer&lt;Student&gt;的子类型。 为什么逆变的时候泛型T不能出现在out位置上？ 这里假设逆变是允许让泛型T出现在out位置上的，然后看一看可能会产生什么样的安全隐患。修改Transformer中的代码，如下所示： interface Transformer&lt;in T&gt; { fun transform(name: String, age: Int): @UnsafeVariance T } 这里将transform()方法改成了接收name和age这两个参数，并把返回值类型改成了泛型T。由于逆变是不允许泛型 T 出现在out位置上的，为了能让编译器正常编译通过，加上了@UnsafeVariance注解。 那么，这个时候可能会产生什么样的安全隐患呢？观察如下代码： fun main() { val trans = object : Transformer&lt;Person&gt; { override fun transform(name: String, age: Int): Person { return Teacher(name, age) } } handleTransformer(trans) } fun handleTransformer(trans: Transformer&lt;Student&gt;) { val result = trans.transform(&quot;Tom&quot;, 19) } 上述代码就是一个典型的违反逆变规则而造成类型转换异常的例子。 在Transformer&lt;Person&gt;的匿名类实现中，使用transform()方法中传入的 name 和 age 参数构建了一个 Teacher 对象，并把这个对象直接返回。 由于transform()方法的返回值要求是一个Person对象，而Teacher是 Person 的子类，因此这种写法肯定是合法的。 但在handleTransformer()方法当中，我们调用了Transformer&lt;Student&gt;的transform()方法，并传入了 name 和 age 这两个参数，期望得到的是一个Student对象的返回，然而实际上 transform() 方法返回的却是一个Teacher对象，因此这里必然会造成类型转换异常。 Kotlin 在提供协变和逆变功能时，就已经把各种潜在的类型转换安全隐患全部考虑进去了。只要我们严格按照其语法规则，让泛型在协变时只出现在out位置上，逆变时只出现在in位置上，就不会存在类型转换异常的情况。虽然@UnsafeVariance注解可以打破这一语法规则，但同时也会带来额外的风险。 最后介绍一下逆变功能在 Kotlin 内置 API 中的应用，比较典型的例子就是Comparable的使用。Comparable 是一个用于比较两个对象大小的接口，其源码定义如下： interface Comparable&lt;in T&gt; { operator fun compareTo(other: T): Int } 可以看到，Comparable在T这个泛型上就是逆变的，compareTo()方法则用于实现具体的比较逻辑。 那么这里为什么要让 Comparable 接口是逆变的呢？想象以下场景： 如果使用Comparable&lt;Person&gt;实现了让两个 Person 对象比较大小的逻辑，那么用这段逻辑去比较两个 Student 对象的大小也一定是成立的，因此让Comparable&lt;Person&gt;成为Comparable&lt;Student&gt;的子类合情合理，这也是逆变非常典型的应用。 ","link":"https://Petrichoroo.github.io/post/kotlinfan-xing-de-gao-ji-te-xing/"},{"title":"Kotlin：泛型和委托","content":" Kotlin 泛型的基本用法 类委托 委托属性 懒加载技术（by lazy） Kotlin 泛型的基本用法 在一般的编程模式下，我们需要给任何一个变量指定一个具体的类型，而泛型允许我们在不指定具体类型的情况下进行编程，这样编写出来的代码将会拥有更好的扩展性。 泛型主要有两种定义方式：一种是定义泛型类，另一种是定义泛型方法，通常使用的语法结构是&lt;T&gt;。 定义一个泛型类，就可以这么写： class MyClass&lt;T&gt; { fun method(param: T): T { return param } } 此时的MyClass就是一个泛型类，MyClass 中的方法允许使用T类型的参数和返回值。我们在调用 MyClass 类和method()方法的时候，就可以将泛型指定成具体的类型，如下所示： val myClass = MyClass&lt;Int&gt;() val result = myClass.method(123) 而如果我们不想定义一个泛型类，只是想定义一个泛型方法，只需要将定义泛型的语法结构写在方法上面即可，如下所示： class MyClass { fun &lt;T&gt; method(param: T): T { return param } } 此时的调用方式也需要进行相应的调整： val myClass = MyClass() val result = myClass.method&lt;Int&gt;(123) 由于 Kotlin 出色的类型推导机制，这里可以直接省略泛型的指定： val myClass = MyClass() val result = myClass.method(123) Kotlin 允许我们对泛型的类型进行限制，可以通过指定上界的方式来对泛型的类型进行约束，比如这里将method()方法的泛型上界设置为Number类型，如下所示： class MyClass { fun &lt;T : Number&gt; method(param: T): T { return param } } 现在只能将method()方法的泛型指定成数字类型，比如Int、Float、Double等。但是如果指定成字符串类型，就肯定会报错。 另外，在默认情况下，所有的泛型都是可以指定成可空类型的，这是因为在不手动指定上界的时候，泛型的上界默认是Any?。而如果想要让泛型的类型不可为空，只需要将泛型的上界手动指定成Any即可。 类委托 委托是一种设计模式，它的基本理念是：操作对象自己不会去处理某段逻辑，而是会把工作委托给另外一个辅助对象去处理。 Kotlin 中将委托功能分为了两种：类委托和委托属性。 类委托的核心思想在于将一个类的具体实现委托给另一个类去完成。借助于委托模式，我们可以轻松实现一个自己的实现类。比如这里定义一个MySet，并让它实现Set接口，代码如下所示： class MySet&lt;T&gt;(val helperSet: HashSet&lt;T&gt;) : Set&lt;T&gt; { override val size: Int get() = helperSet.size override fun contains(element: T) = helperSet.contains(element) override fun containsAll(elements: Collection&lt;T&gt;) = helperSet.containsAll(elements) override fun isEmpty() = helperSet.isEmpty() override fun iterator() = helperSet.iterator() } 可以看到，MySet的构造函数中接收了一个HashSet参数，这就相当于一个辅助对象。然后在Set接口所有的方法实现中，我们都没有进行自己的实现，而是调用了辅助对象中相应的方法实现，这其实就是一种委托模式。 这种写法的好处是什么呢？既然都是调用辅助对象的方法实现，那还不如直接使用辅助对象。 如果我们只是让大部分的方法实现调用辅助对象中的方法，少部分的方法实现由自己来重写，甚至加入一些自己独有的方法，那么MySet就会成为一个全新的数据结构类，这就是委托模式的意义所在。 但是这种写法也有一定的弊端，如果接口中的待实现方法比较少还好，要是有几十甚至上百个方法的话，每个都去这样调用辅助对象中的相应方法实现是很复杂的，不过在 Kotlin 中可以通过类委托的功能来解决这个问题。 Kotlin 中委托使用的关键字是by，我们只需要在接口声明的后面使用 by 关键字，再接上受委托的辅助对象，就可以免去之前所写的一大堆模板式的代码了，如下所示： class MySet&lt;T&gt;(val helperSet: HashSet&lt;T&gt;) : Set&lt;T&gt; by helperSet { } 另外，如果我们要对某个方法进行重新实现，只需要单独重写那一个方法即可，其他的方法仍然可以享受类委托所带来的便利，如下所示： class MySet&lt;T&gt;(val helperSet: HashSet&lt;T&gt;) : Set&lt;T&gt; by helperSet { fun helloWorld() = println(&quot;Hello World&quot;) override fun isEmpty() = false } 这里新增了一个helloWorld()方法，并且重写了isEmpty()方法，让它永远返回false。这当然是一种错误的做法，这里仅仅是为了演示一下而已。 现在MySet就成为了一个全新的数据结构类，它不仅永远不会为空，而且还能打印 &quot;Hello World&quot;，至于其他Set接口中的功能，则和HashSet保持一致。这就是 Kotlin 的类委托所能实现的功能。 委托属性 类委托的核心思想是将一个类的具体实现委托给另一个类去完成，而委托属性的核心思想是将一个属性（字段）的具体实现委托给另一个类去完成。 委托属性的语法结构，如下所示： class MyClass { var p by Delegate() } 这里使用by关键字连接了左边的p属性和右边的Delegate实例。 这种写法就代表着将p属性的具体实现委托给了Delegate类去完成。当调用 p 属性的时候会自动调用 Delegate 类的getValue()方法，当给 p 属性赋值的时候会自动调用 Delegate 类的setValue()方法。 因此，我们还得对Delegate类进行具体的实现才行，代码如下所示： class Delegate { var propValue: Any? = null operator fun getValue(myClass: MyClass, prop: KProperty&lt;*&gt;): Any? { return propValue } operator fun setValue(myClass: MyClass, prop: KProperty&lt;*&gt;, value: Any?) { propValue = value } } 这是一种标准的代码实现模板，在Delegate 类中我们必须实现getValue()和setValue()这两个方法，并且都要使用operator关键字进行声明。 getValue()方法要接收两个参数： 第一个参数用于声明该Delegate类的委托功能可以在什么类中使用，这里写成MyClass表示仅可在 MyClass 类中使用。 第二个参数KProperty&lt;*&gt;是Kotlin中的一个属性操作类，可用于获取各种属性相关的值，在当前场景下用不着，但是必须在方法参数上进行声明。另外，&lt;*&gt;这种泛型的写法表示你不知道或者不关心泛型的具体类型，只是为了通过语法编译而已。至于返回值可以声明成任何类型，根据具体的实现逻辑即可。 setValue()方法也是相似的，只不过它要接收 3 个参数。前两个参数和getValue()方法是相同的，最后一个参数表示具体要赋值给委托属性的值，这个参数的类型必须和 getValue() 方法返回值的类型保持一致。 整个委托属性的工作流程：当给MyClass的p属性赋值时，就会调用Delegate类的setValue()方法，当获取 MyClass 中 p 属性的值时，就会调用 Delegate 类的getValue()方法。 不过，其实还存在一种情况可以不用在Delegate类中实现setValue()方法，那就是MyClass中的p属性是使用val关键字声明的。因为如果 p 属性是使用 val 关键字声明的，那么就意味着 p 属性是无法在初始化之后被重新赋值的，因此也就没有必要实现 setValue() 方法。 懒加载技术（by lazy） 把想要延迟执行的代码放到by lazy代码块中，这样代码块中的代码在一开始的时候就不会执行，只有当相关变量首次被调用的时候，代码块中的代码才会执行。 实际上，by lazy并不是连在一起的关键字，只有by才是 Kotlin 中的关键字，lazy在这里只是一个高阶函数而已。 在lazy函数中会创建并返回一个Delegate对象，当调用p属性时，其实调用的是 Delegate 对象的getValue()方法，然后 getValue() 方法中又会调用 lazy 函数传入的Lambda表达式，这样表达式中的代码就可以得到执行了，并且调用 p 属性后得到的值就是 Lambda 表达式中最后一行代码的返回值。 ","link":"https://Petrichoroo.github.io/post/kotlinfan-xing-he-wei-tuo/"},{"title":"Kotlin：高阶函数详解","content":" Kotlin 定义高阶函数 内联函数的作用 noinline 与 crossinline Kotlin 定义高阶函数 如果一个函数接收另一个函数作为参数，或者返回值的类型是另一个函数，那么该函数就称为高阶函数。 编程语言中有整型、布尔型等字段类型，而 Kotlin 又增加了一个函数类型的概念。如果我们将这种函数类型添加到一个函数的参数声明或者返回值声明当中，那么这就是一个高阶函数了。 不同于定义一个普通的字段类型，函数类型的语法规则是有点特殊的，基本规则如下： (String, Int) -&gt; Unit 既然是定义一个函数类型，那么最关键的就是要声明该函数接收什么参数，以及它的返回值是什么。 因此，-&gt;左边的部分就是用来声明该函数接收什么参数的，多个参数之间使用逗号隔开，如果不接收任何参数，写一对空括号即可。而-&gt;右边的部分用于声明该函数的返回值是什么类型，如果没有返回值就使用Unit，它大致相当于 Java 中的void。 现在将上述函数类型添加到某个函数的参数声明或者返回值声明上，那么这个函数就是一个高阶函数了，如下所示： fun example(func: (String, Int) -&gt; Unit) { func(&quot;hello&quot;, 123) } 这里的example()函数接收了一个函数类型的参数，因此 example() 函数就是一个高阶函数。而调用一个函数类型的参数，它的语法类似于调用一个普通的函数，只需要在参数名的后面加上一对括号，并在括号中传入必要的参数即可。 高阶函数允许让函数类型的参数来决定函数的执行逻辑。即使是同一个高阶函数，只要传入不同的函数类型参数，那么它的执行逻辑和最终的返回结果就可能是完全不同的。 下面来举一个具体的例子：定义一个叫作num1AndNum2()的高阶函数，并让它接收两个整型和一个函数类型的参数。 我们在num1AndNum2()函数中对传入的两个整型参数进行某种运算，并返回最终的运算结果，但是具体进行什么运算是由传入的函数类型参数决定的。 新建一个HigherOrderFunction.kt文件，然后在这个文件中编写如下代码： fun num1AndNum2(num1: Int, num2: Int, operation: (Int, Int) -&gt; Int): Int { val result = operation(num1, num2) return result } num1AndNum2()函数的前两个参数没有什么需要解释的，第三个参数是一个接收两个整型参数并且返回值也是整型的函数类型参数。在 num1AndNum2() 函数中，我们没有进行任何具体的运算操作，而是将num1和num2参数传给了第三个函数类型参数，并获取它的返回值，最终将得到的返回值返回。 现在高阶函数已经定义好了，那么我们该如何调用它呢？ 由于num1AndNum2()函数接收一个函数类型的参数，因此我们还得先定义与其函数类型相匹配的函数才行。在HigherOrderFunction.kt文件中添加如下代码： fun plus(num1: Int, num2: Int): Int { return num1 + num2 } fun minus(num1: Int, num2: Int): Int { return num1 - num2 } 这里定义了两个函数，并且这两个函数的参数声明和返回值声明都和num1AndNum2()函数中的函数类型参数是完全匹配的。 有了上述函数之后，我们就可以调用num1AndNum2()函数了，在main()函数中编写如下代码： fun main() { val num1 = 100 val num2 = 80 val result1 = num1AndNum2(num1, num2, ::plus) val result2 = num1AndNum2(num1, num2, ::minus) println(&quot;result1 is $result1&quot;) println(&quot;result2 is $result2&quot;) } 注意这里调用num1AndNum2()函数的方式，第三个参数使用了::plus和::minus这种写法。这是一种函数引用方式的写法，表示将plus()和minus()函数作为参数传递给 num1AndNum2() 函数。 而由于num1AndNum2()函数中使用了传入的函数类型参数来决定具体的运算逻辑，因此这里实际上就是分别使用了plus()和minus()函数来对两个数字进行运算。 现在运行一下程序，结果如下图所示： 使用这种函数引用的写法虽然能够正常工作，但是如果每次调用任何高阶函数的时候都还得先定义一个与其函数类型参数相匹配的函数，这种做法是比较复杂的。 因此 Kotlin 还支持其他多种方式来调用高阶函数，比如Lambda表达式、匿名函数、成员引用等。其中，Lambda 表达式是最常见也是最普遍的高阶函数调用方式。 上述代码如果使用Lambda表达式的写法来实现的话，代码如下所示： fun main() { val num1 = 100 val num2 = 80 val result1 = num1AndNum2(num1, num2) { n1, n2 -&gt; n1 + n2 } val result2 = num1AndNum2(num1, num2) { n1, n2 -&gt; n1 - n2 } println(&quot;result1 is $result1&quot;) println(&quot;result2 is $result2&quot;) } Lambda表达式同样可以完整地表达一个函数的参数声明和返回值声明（Lambda 表达式中的最后一行代码会自动作为返回值），但是写法却更加精简。 现在可以将刚才定义的plus()和minus()函数删掉了，重新运行一下代码，会发现结果是一模一样的。 之前使用的apply函数，它可以用于给Lambda表达式提供一个指定的上下文，当需要连续调用同一个对象的多个方法时，apply 函数可以让代码变得更加精简，比如StringBuilder就是一个典型的例子。 接下来我们就使用高阶函数模仿实现一个类似的功能。修改HigherOrderFunction.kt文件，在其中加入如下代码： fun StringBuilder.build(block: StringBuilder.() -&gt; Unit): StringBuilder { block() return this } 这里给StringBuilder类定义了一个build扩展函数，这个扩展函数接收一个函数类型参数，并且返回值类型也是 StringBuilder。 注意，这个函数类型参数的声明方式和我们前面学习的语法有所不同：它在函数类型的前面加上了一个StringBuilder. 的语法结构。其实这才是定义高阶函数完整的语法规则，在函数类型的前面加上ClassName. 就表示这个函数类型是定义在哪个类当中的。 那么这里将函数类型定义到StringBuilder类当中有什么好处呢？好处就是当我们调用build函数时传入的Lambda表达式将会自动拥有 StringBuilder 的上下文，同时这也是apply函数的实现方式。 现在我们就可以使用自己创建的build函数来简化StringBuilder构建字符串的方式了。这里仍然用吃水果这个功能来举例： fun main() { val list = listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;) val result = StringBuilder().build { append(&quot;Start eating fruits.\\n&quot;) for (fruit in list) { append(fruit).append(&quot;\\n&quot;) } append(&quot;Ate all fruits.&quot;) } println(result.toString()) } 可以看到，build函数的用法和apply函数基本上是一模一样的，只不过我们编写的 build 函数目前只能作用在StringBuilder类上面，而 apply 函数是可以作用在所有类上面的。 如果想实现 apply 函数的这个功能，需要借助于 Kotlin 的泛型。 内联函数的作用 高阶函数确实非常神奇，用途也十分广泛，可是它背后的实现原理是怎样的呢？ 这里仍然使用刚才编写的num1AndNum2()函数来举例，代码如下所示： fun num1AndNum2(num1: Int, num2: Int, operation: (Int, Int) -&gt; Int): Int { val result = operation(num1, num2) return result } fun main() { val num1 = 100 val num2 = 80 val result = num1AndNum2(num1, num2) { n1, n2 -&gt; n1 + n2 } } 可以看到，上述代码中调用了num1AndNum2()函数，并通过Lambda表达式指定对传入的两个整型参数进行求和。 但我们知道，Kotlin 的代码最终还是要编译成 Java 字节码的，但 Java 中并没有高阶函数的概念。 那么 Kotlin 究竟是如何让 Java 支持这种高阶函数的语法呢？ Kotlin 的编译器会将这些高阶函数的语法转换成 Java 支持的语法结构，上述的 Kotlin 代码大致会被转换成如下 Java 代码： public static int num1AndNum2(int num1, int num2, Function operation) { int result =(int) operation . invoke (num1, num2); return result; } public static void main() { int num1 = 100; int num2 = 80; int result = num1AndNum2 (num1, num2, new Function() { @Override public Integer invoke(Integer n1, Integer n2) { return n1 + n2; } }); } 这里对这段代码进行了些许调整，并不是严格对应了 Kotlin 转换成的 Java 代码。 可以看到，在这里num1AndNum2()函数的第三个参数变成了一个Function接口，这是一种 Kotlin 内置的接口，里面有一个待实现的invoke()函数。而 num1AndNum2() 函数其实就是调用了 Function 接口的 invoke() 函数，并把num1和num2参数传了进去。 在调用num1AndNum2()函数的时候，之前的 Lambda 表达式在这里变成了Function接口的匿名类实现，然后在invoke()函数中实现了n1 + n2的逻辑，并将结果返回。 这就是 Kotlin 高阶函数背后的实现原理。会发现原来我们一直使用的 Lambda 表达式在底层被转换成了匿名类的实现方式。这就表明，我们每调用一次 Lambda 表达式，都会创建一个新的匿名类实例，当然也会造成额外的内存和性能开销。 为了解决这个问题，Kotlin 提供了内联函数的功能，它可以将使用 Lambda 表达式带来的运行时开销完全消除。 内联函数的用法非常简单，只需要在定义高阶函数时加上inline关键字的声明即可，如下所示： inline fun num1AndNum2(num1: Int, num2: Int, operation: (Int, Int) -&gt; Int): Int { val result = operation(num1, num2) return result } 那么内联函数的工作原理又是什么呢？其实并不复杂，就是 Kotlin 编译器会将内联函数中的代码在编译的时候自动替换到调用它的地方，这样也就不存在运行时的开销。 下面我们通过图例的方式来详细说明内联函数的代码替换过程。 首先，Kotlin 编译器会将 Lambda 表达式中的代码替换到函数类型参数调用的地方，如下图所示： 接下来，再将内联函数中的全部代码替换到函数调用的地方，如下图所示： 最终的代码就被替换成了下图所示的样子： 也正是如此，内联函数才能完全消除 Lambda 表达式所带来的运行时开销。 noinline 与 crossinline 接下来讨论一些更加特殊的情况。比如，一个高阶函数中如果接收了两个或者更多函数类型的参数，这时我们给函数加上了inline关键字，那么 Kotlin 编译器会自动将所有引用的 Lambda 表达式全部进行内联。 但是，如果我们只想内联其中的一个 Lambda 表达式该怎么办呢？这时就可以使用noinline关键字，如下所示： inline fun inlineTest(block1: () -&gt; Unit, noinline block2: () -&gt; Unit) { } 这里在block2参数的前面加上了一个noinline关键字，那么现在就只会对block1参数所引用的 Lambda 表达式进行内联。 为什么 Kotlin 还要提供一个noinline关键字来排除内联功能呢？ 因为内联的函数类型参数在编译的时候会被进行代码替换，因此它没有真正的参数属性。非内联的函数类型参数可以自由地传递给其他任何函数，因为它就是一个真实的参数，而内联的函数类型参数只允许传递给另外一个内联函数，这也是它最大的局限性。 另外，内联函数和非内联函数还有一个重要的区别，那就是内联函数所引用的 Lambda 表达式中是可以使用return关键字来进行函数返回的，而非内联函数只能进行局部返回。 为了说明这个问题，我们来看下面的例子： fun printString(str: String, block: (String) -&gt; Unit) { println(&quot;printString begin&quot;) block(str) println(&quot;printString end&quot;) } fun main() { println(&quot;main start&quot;) val str = &quot;&quot; printString(str) { s -&gt; println(&quot;lambda start&quot;) if (s.isEmpty()) return@printString println(s) println(&quot;lambda end&quot;) } println(&quot;main end&quot;) } 这里定义了一个叫作printString()的高阶函数，用于在 Lambda 表达式中打印传入的字符串参数。但是如果字符串参数为空，那么就不进行打印。注意，Lambda 表达式中是不允许直接使用return关键字的，这里使用了return@printString的写法，表示进行局部返回，并且不再执行 Lambda 表达式的剩余部分代码。 现在我们就刚好传入一个空的字符串参数，运行程序，打印结果如下图所示： 可以看到，除了 Lambda 表达式中return@printString语句之后的代码没有打印，其他的日志是正常打印的，说明 return@printString 确实只能进行局部返回。 但是如果我们将printString()函数声明成一个内联函数，那么情况就不一样了，如下所示： inline fun printString(str: String, block: (String) -&gt; Unit) { println(&quot;printString begin&quot;) block(str) println(&quot;printString end&quot;) } fun main() { println(&quot;main start&quot;) val str = &quot;&quot; printString(str) { s -&gt; println(&quot;lambda start&quot;) if (s.isEmpty()) return println(s) println(&quot;lambda end&quot;) } println(&quot;main end&quot;) } 现在printString()函数变成了内联函数，我们就可以在 Lambda 表达式中使用return关键字了。此时的 return 代表的是返回外层的调用函数，也就是main()函数。 现在重新运行一下程序，打印结果如下图所示： 可以看到，不管是main()函数还是printString()函数，确实都在return关键字之后停止执行了，和我们所预期的结果一致。 将高阶函数声明成内联函数是一种良好的编程习惯，事实上，绝大多数高阶函数是可以直接声明成内联函数的，但是也有少部分例外的情况。观察下面的代码示例： inline fun runRunnable(block: () -&gt; Unit) { val runnable = Runnable { block() } runnable.run() } 这段代码在没有加上inline关键字声明的时候绝对是可以正常工作的，但是在加上 inline 关键字之后就会提示如图所示的错误： 这个错误出现的原因解释起来可能会稍微有点复杂。 首先，在runRunnable()函数中，我们创建了一个Runnable对象，并在 Runnable 的 Lambda 表达式中调用了传入的函数类型参数。而 Lambda 表达式在编译的时候会被转换成匿名类的实现方式，也就是说，上述代码实际上是在匿名类中调用了传入的函数类型参数。 而内联函数所引用的Lambda表达式允许使用return关键字进行函数返回，但是由于我们是在 匿名类中调用的函数类型参数，此时是不可能进行外层调用函数返回的，最多只能对匿名类中的函数调用进行返回，因此这里就提示了上述错误。 也就是说，如果我们在高阶函数中创建了另外的 Lambda 或者匿名类的实现，并且在这些实现中调用函数类型参数，此时再将高阶函数声明成内联函数，就一定会提示错误。 那么是不是在这种情况下就真的无法使用内联函数了呢？也不是，比如借助crossinline关键字就可以很好地解决这个问题： inline fun runRunnable(crossinline block: () -&gt; Unit) { val runnable = Runnable { block() } runnable.run() } 前面已经分析过错误的原因，就是因为内联函数的Lambda表达式中允许使用return关键字，和高阶函数的匿名类实现中不允许使用 return 关键字之间造成了冲突。而crossinline关键字就像一个契约，它用于保证在内联函数的 Lambda 表达式中一定不会使用 return 关键字，这样冲突就不存在了，问题也就巧妙地解决了。 声明crossinline之后，就无法在调用runRunnable函数时的 Lambda 表达式中使return关键字进行函数返回了，但是仍然可以使用return@runRunnable的写法进行局部返回。 总体来说，除了在 return关 键字的使用上有所区别之外，crossinline保留了内联函数的其他所有特性。 ","link":"https://Petrichoroo.github.io/post/kotlingao-jie-han-shu-xiang-jie/"},{"title":"实现强制下线功能（Kotlin)","content":" 强制下线 具体实现 强制下线 具体实现 实现强制下线功能的思路比较简单，只需要在界面上弹出一个对话框，让用户无法进行任何其他操作，必须点击对话框中的“确定”按钮，然后回到登录界面即可。 新建一个BroadcastBestPractice项目，由于强制下线功能需要先关闭所有的Activity，然后回到登录界面，因此先创建一个ActivityCollector类用于管理所有的Activity，代码如下所示： object ActivityCollector { //单例类 全局最多只能拥有一个实例 private val activities = ArrayList&lt;Activity&gt;() fun addActivity(activity: Activity) { activities.add(activity) } fun removeActivity(activity: Activity) { activities.remove(activity) } fun finishAll() { for (activity in activities) { if (!activity.isFinishing) { activity.finish() } } activities.clear() } } 然后创建BaseActivity类作为所有 Activity 的父类，代码如下所示： open class BaseActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) ActivityCollector.addActivity(this) } override fun onDestroy() { super.onDestroy() ActivityCollector.removeActivity(this) } } 然后创建一个LoginActivity来作为登录界面，然后编辑布局文件activity_login.xml，代码如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;60dp&quot; android:layout_marginTop=&quot;180dp&quot;&gt; &lt;TextView android:layout_width=&quot;90dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_vertical&quot; android:text=&quot;Account:&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;EditText android:id=&quot;@+id/accountEdit&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_weight=&quot;1&quot; /&gt; &lt;/LinearLayout&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;60dp&quot;&gt; &lt;TextView android:layout_width=&quot;90dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_vertical&quot; android:text=&quot;Account:&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;EditText android:id=&quot;@+id/passwordEdit&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_weight=&quot;1&quot; android:inputType=&quot;textPassword&quot; /&gt; &lt;/LinearLayout&gt; &lt;Button android:id=&quot;@+id/login&quot; android:layout_width=&quot;200dp&quot; android:layout_height=&quot;60dp&quot; android:layout_gravity=&quot;center_horizontal&quot; android:text=&quot;Login&quot; android:textAllCaps=&quot;false&quot; /&gt; &lt;/LinearLayout&gt; 布局最外层是一个纵向的LinearLayout，里面包含了 3 行直接子元素。 第一行是一个横向的 LinearLayout，用于输入账号信息；第二行也是一个横向的 LinearLayout，用于输入密码信息；第三行是一个登录按钮。 接下来修改LoginActivity中的代码，如下所示： class LoginActivity : BaseActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_login) val button: Button = findViewById(R.id.login) val accountEdit: EditText = findViewById(R.id.accountEdit) val passwordEdit: EditText = findViewById(R.id.passwordEdit) button.setOnClickListener { val account = accountEdit.text.toString() val password = passwordEdit.text.toString() if (account == &quot;admin&quot; &amp;&amp; password == &quot;123456&quot;) { val intent = Intent(this, MainActivity::class.java) startActivity(intent) finish() } else { Toast.makeText(this, &quot;account or password is invalid&quot;, Toast.LENGTH_SHORT).show() } } } } 这里模拟了一个简单的登录功能。首先将LoginActivity的继承结构改成继承自BaseActivity，然后在登录按钮的点击事件里对输入的账号和密码进行判断。 因此，可以将MainActivity理解成是登录成功后进入的程序主界面，这里我们并不需要在主界面提供什么花哨的功能，只需要加入强制下线功能就可以了。修改activity_main.xml中的代码，如下所示： &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:orientation=&quot;vertical&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; &gt; &lt;Button android:id=&quot;@+id/forceOffline&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Send force offline broadcast&quot; android:textAllCaps=&quot;false&quot;/&gt; &lt;/LinearLayout&gt; 这里只有一个按钮用于触发强制下线功能。然后修改MainActivity中的代码，如下所示： class MainActivity : BaseActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val forceOffline: Button = findViewById(R.id.forceOffline) forceOffline.setOnClickListener { val intent = Intent(&quot;com.example.broadcastbestpractice.FORCE_OFFLINE&quot;) sendBroadcast(intent) } } } 这里在按钮的点击事件里发送了一条通知程序强制用户下线的广播，也就是说，强制用户下线的逻辑并不是写在MainActivity里的，而是应该写在接收这条广播的BroadcastReceiver里。 这样强制下线的功能就不会依附于任何界面了，不管是在程序的任何地方，只要发出这样一条广播，就可以完成强制下线的操作。 由于BroadcastReceiver中需要弹出一个对话框来阻塞用户的正常操作，但如果创建的是一个静态注册的 BroadcastReceiver，是没有办法在onReceive()方法里弹出对话框这样的 UI 控件的，而我们显然也不可能在每个 Activity 中都注册一个动态的 BroadcastReceiver。 好的解决办法是在BaseActivity中动态注册一个 BroadcastReceiver 就可以了，因为所有的 Activity 都继承自 BaseActivity。 修改BaseActivity中的代码，如下所示： open class BaseActivity : AppCompatActivity() { lateinit var receiver: ForceOfflineReceiver override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) ActivityCollector.addActivity(this) } /** * 始终需要保证只有处于栈顶的Activity才能接收到这条强制下线广播 * 非栈顶的Activity不应该也没必要接收这条广播 * 所以写在onResume()和onPause()方法里就可以很好地解决这个问题 * 当一个Activity失去栈顶位置时就会自动取消BroadcastReceiver的注册。*/ override fun onResume() { super.onResume() val intentFilter = IntentFilter() intentFilter.addAction(&quot;com.example.broadcastbestpractice.FORCE_OFFLINE&quot;) receiver = ForceOfflineReceiver() registerReceiver(receiver, intentFilter) } override fun onPause() { super.onPause() unregisterReceiver(receiver) } override fun onDestroy() { super.onDestroy() ActivityCollector.removeActivity(this) } inner class ForceOfflineReceiver : BroadcastReceiver() { override fun onReceive(context: Context, intent: Intent) { AlertDialog.Builder(context).apply { setTitle(&quot;Warning&quot;) setMessage(&quot;You are forced to be offline. Please try to login again.&quot;) setCancelable(false) //将对话框设为不可取消 setPositiveButton(&quot;OK&quot;) { _, _ -&gt; ActivityCollector.finishAll() //销毁所有Activity val intent = Intent(context, LoginActivity::class.java) context.startActivity(intent) //重新启动LoginActivity } show() } } } } 这样的话，所有强制下线的逻辑就已经完成了，接下来我们还需要对AndroidManifest.xml文 件进行修改，代码如下所示： &lt;application ... &lt;activity android:name=&quot;.LoginActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.MAIN&quot;/&gt; &lt;category android:name=&quot;android.intent.category.LAUNCHER&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=&quot;.MainActivity&quot;&gt; &lt;/activity&gt; &lt;/application&gt; 就是将主 Activity 设置为LoginActivity，而不再是MainActivity，因为我们肯定不希望用户在没登录的情况下就能直接进入程序主界面。 现在来尝试运行一下程序。首先会进入登录界面，并可以在这里输入账号和密码，如下： 如果输入的账号密码正确，点击登录按钮就会进入程序的主界面，如下： 这时点击一下发送广播的按钮，就会发出一条强制下线的广播，ForceOfflineReceiver收到这条广播后会弹出一个对话框，提示用户已被强制下线，如下： 这时用户将无法再对界面的任何元素进行操作，只能点击“OK”按钮，然后重新回到登录界面，如下： ","link":"https://Petrichoroo.github.io/post/shi-xian-qiang-zhi-xia-xian-gong-neng-kotlin/"},{"title":"Kotlin：扩展函数和运算符重载","content":" Kotlin 扩展函数 运算符重载 Kotlin 扩展函数 扩展函数表示即使在不修改某个类的源码的情况下，仍然可以打开这个类，向该类添加新的函数。 比如一段字符串中可能包含字母、数字和特殊符号等字符，现在我们希望统计字符串中字母的数量，你要怎么实现这个功能呢？ 如果按照一般的编程思维，可能大多数人会很自然地写出如下函数： object StringUtil { fun lettersCount(str: String): Int { var count = 0 for (char in str) { if (char.isLetter()) { count++ } } return count } } 这里先定义了一个StringUtil单例类，然后在这个单例类中定义了一个lettersCount()函数，该函数接收一个字符串参数。 现在，当我们需要统计某个字符串中的字母数量时，只需要编写如下代码即可： val str = &quot;ABC123xyz!@#&quot; val count = StringUtil.lettersCount(str) 这是 Java 编程中最标准的实现思维。但是有了扩展函数之后就不一样了，我们可以使用一种更加面向对象的思维来实现这个功能，比如说将lettersCount()函数添加到String类当中。 定义扩展函数的语法结构如下所示： fun ClassName.methodName(param1: Int, param2: Int): Int { return 0 } 相比于定义一个普通的函数，定义扩展函数只需要在函数名的前面加上一个ClassName.的语法结构，就表示将该函数添加到指定类当中了。 接下来我们就尝试使用扩展函数的方式来优化刚才的统计功能。 由于我们希望向String类中添加一个扩展函数，因此需要先创建一个String.kt文件。 建议向哪个类中添加扩展函数，就定义一个同名的Kotlin文件，这样便于以后查找。 当然，扩展函数也是可以定义在任何一个现有类当中的，并不一定非要创建新文件。不过通常来说，最好将它定义成顶层方法，这样可以让扩展函数拥有全局的访问域。现在在 String.kt 文件中编写如下代码： fun String.lettersCount(): Int { var count = 0 for (char in this) { if (char.isLetter()) { count++ } } return count } 现在我们将lettersCount()方法定义成了String类的扩展函数，那么函数中就自动拥有了 String 实例的上下文。因此 lettersCount() 函数就不再需要接收一个字符串参数了，而是直接遍历this即可，因为现在 this 就代表着字符串本身。 定义好了扩展函数之后，统计某个字符串中的字母数量只需要这样写即可： val count = &quot;ABC123xyz!@#&quot;.lettersCount() 扩展函数在很多情况下可以让 API 变得更加简洁、丰富，更加面向对象。 除了 String 类之外，我们还可以向任何类中添加扩展函数，Kotlin 对此基本没有限制。如果能利用好扩展函数这个功能，将会大幅度地提升代码质量和开发效率。 运算符重载 Kotlin 允许我们将所有的运算符甚至其他的关键字进行重载，从而拓展这些运算符和关键字的用法。比如允许我们让任意两个对象进行相加，或者是进行更多其他的运算操作。 运算符重载使用的是operator关键字，只要在指定函数的前面加上 operator 关键字，就可以实现运算符重载的功能。 但问题在于这个指定函数是什么？这是运算符重载里面比较复杂的一个问题，因为不同的运算符对应的重载函数也是不同的。比如说加号运算符对应的是plus()函数，减号运算符对应的是minus()函数。 这里以加号运算符为例，如果想要实现让两个对象相加的功能，那么它的语法结构如下： class Obj { operator fun plus(obj: Obj): Obj { // 处理相加的逻辑 } } 在上述语法结构中，关键字operator和函数名plus都是固定不变的，而接收的参数和函数返回值可以根据你的逻辑自行设定。 那么上述代码就表示一个 Obj 对象可以与另一个 Obj 对象相加，最终返回一个新的 Obj 对象。对应的调用方式如下： val obj1 = Obj() val obj2 = Obj() val obj3 = obj1 + obj2 这种obj1 + obj2的语法看上去好像很神奇，但其实这就是 Kotlin 给我们提供的一种语法糖，它会在编译的时候被转换成obj1.plus(obj2)的调用方式。 下面开始实现一个更加有意义功能：让两个Money对象相加。 首先定义 Money 类的结构，这里让 Money 的主构造函数接收一个value参数，用于表示钱的金额。创建Money.kt文件，代码如下所示： class Money(val value: Int) { operator fun plus(money: Money): Money { val sum = value + money.value return Money(sum) } } 这里使用了operator关键字来修饰plus()函数，这是必不可少的。在 plus() 函数中，我们将当前 Money 对象的value和参数传入的 Money 对象的 value 相加，然后将得到的和传给一个新的 Money 对象并将该对象返回。 现在我们可以使用如下代码来对刚刚编写的功能进行测试： val money1 = Money(5) val money2 = Money(10) val money3 = money1 + money2 println(money3.value) 上述代码执行结果一定是 15 Money 对象只能允许和另一个 Money 对象相加是不够方便的，因此下面实现 Money 对象直接和数字相加的功能，因为 Kotlin 允许我们对同一个运算符进行多重重载，如下所示： class Money(val value: Int) { operator fun plus(money: Money): Money { val sum = value + money.value return Money(sum) } operator fun plus(newValue: Int): Money { val sum = value + newValue return Money(sum) } } 这里我们又重载了一个plus()函数，不过这次接收的参数是一个整型数字。那么现在，Money对象就拥有了和数字相加的能力，如下： val money1 = Money(5) val money2 = Money(10) val money3 = money1 + money2 val money4 = money3 + 20 println(money4.value) 这里让 money3 对象再加上 20 的金额，最终打印的结果就变成了 35。 当然，我们还可以对这个例子进一步扩展，比如加上汇率转换的功能。让 1 人民币的 Money 对象和 1 美元的 Money 对象相加，然后根据实时汇率进行转换，从而返回一个新的 Money 对象。 实际上 Kotlin 允许我们重载的运算符和关键字多达十几个。下表列出了所有常用的可重载运算符和关键字对应的语法糖表达式，以及它们会被转换成的实际调用函数。如果我们想重载其中某一种运算符或关键字，只要参考刚才加号运算符重载的写法去实现即可。 之前多次使用了一个随机生成字符串长度的函数，代码如下所示： fun getRandomLengthString(str: String): String { val n = (1..20).random() val builder = StringBuilder() repeat(n) { builder.append(str) } return builder.toString() } 这个函数的核心思想就是将传入的字符串重复 n 次，下面实现使用str * n这种写法来表示让 str 字符串重复 n 次。 要让一个字符串可以乘以一个数字，那么肯定要在String类中重载乘号运算符才行，但是 String 类是系统提供的类，我们无法修改这个类的代码。这个时候就可以借助扩展函数功能向 String 类中添加新函数了。 新建String.kt文件，然后加入如下代码： operator fun String.times(n: Int): String { val builder = StringBuilder() repeat(n) { builder.append(this) } return builder.toString() } 首先，operator关键字肯定是必不可少的，然后既然是要重载乘号运算符，参看上表可知，函数名必须是times，最后，由于是定义扩展函数，因此还要在函数名前面加上String.的语法结构。 现在，字符串就拥有了和一个数字相乘的能力，比如执行如下代码： val str = &quot;abc&quot; * 3 println(str) 最后，其实 Kotlin 的String类中已经提供了一个用于将字符串重复 n 遍的repeat()函数，因此times()函数还可以进一步精简成如下形式： operator fun String.times(n: Int) = repeat(n) 现在可以getRandomLengthString()函数中使用上述写法，如下： fun getRandomLengthString(str: String) = str * (1..20).random() ","link":"https://Petrichoroo.github.io/post/kotlinkuo-zhan-han-shu-he-yun-suan-fu-chong-zai/"},{"title":"简易版的新闻应用（Kotlin）","content":" 新闻应用 具体实现 新闻应用 具体实现 Fragment 很多时候是在平板开发当中使用的，因为它可以解决屏幕空间不能充分利用的问题，下面编写一个简单的兼容手机和平板的新闻应用程序。 新建新闻的实体类News，代码如下所示： class News(val title: String, val content: String) { } title字段表示新闻标题，content字段表示新闻内容。 接着新建布局文件news_content_frag.xml，作为新闻内容的布局： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;LinearLayout android:id=&quot;@+id/contentLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot; android:visibility=&quot;invisible&quot;&gt; &lt;TextView android:id=&quot;@+id/newsTitle&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:gravity=&quot;center&quot; android:padding=&quot;10dp&quot; android:textSize=&quot;20sp&quot; /&gt; &lt;View android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;1dp&quot; android:background=&quot;#000&quot; /&gt; &lt;TextView android:id=&quot;@+id/newsContent&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot; android:padding=&quot;15dp&quot; android:textSize=&quot;18sp&quot; /&gt; &lt;/LinearLayout&gt; &lt;View android:layout_width=&quot;1dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_alignParentLeft=&quot;true&quot; android:background=&quot;#000&quot; /&gt; &lt;/RelativeLayout&gt; 头部部分显示新闻标题，正文部分显示新闻内容，中间使用一条水平方向的细线分隔开。除此之外，这里还使用了一条垂直方向的细线，它的作用是在双页模式时将左侧的新闻列表和右侧的新闻内容分隔开。 注意要将新闻内容的布局设置成不可见。因为在双页模式下，如果还没有选中新闻列表中的任何一条新闻，是不应该显示新闻内容布局的。 然后新建一个NewsContentFragment类，继承自 Fragment，代码如下所示： class NewsContentFragment : Fragment() { //延迟初始化 private lateinit var contentLayout: LinearLayout private lateinit var newsTitle: TextView private lateinit var newsContent: TextView override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { val view: View = inflater.inflate(R.layout.news_content_frag, container, false) contentLayout = view.findViewById(R.id.contentLayout) newsTitle = view.findViewById(R.id.newsTitle) newsContent = view.findViewById(R.id.newsContent) return view } fun refresh(title: String, content: String) { contentLayout.visibility = View.VISIBLE //将隐藏的新闻内容布局设置成可见 newsTitle.text = title //刷新新闻的标题 newsContent.text = content //刷新新闻的内容 } } 这样就把新闻内容的 Fragment 和布局都创建好了，但是它们都是在双页模式中使用的，若想在单页模式中使用的话，我们还需要再创建一个 Activity。 新建一个NewsContentActivity，然后修改布局代码，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;fragment android:id=&quot;@+id/newsContentFrag&quot; android:name=&quot;com.example.fragmentbestpractice.NewsContentFragment&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;/LinearLayout&gt; 这里充分发挥了代码的复用性，直接在布局中引入了NewsContentFragment。 这样相当于把news_content_frag布局的内容自动加了进来。然后修改 NewsContentActivity 中的代码，如下所示： class NewsContentActivity : AppCompatActivity() { companion object { fun actionStart(context: Context, title: String, content: String) { val intent = Intent(context, NewsContentActivity::class.java).apply { putExtra(&quot;news_title&quot;, title) putExtra(&quot;news_content&quot;, content) } context.startActivity(intent) } } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_news_content) val title = intent.getStringExtra(&quot;news_title&quot;) //获取传入的新闻标题 val content = intent.getStringExtra(&quot;news_content&quot;) //获取传入的新闻内容 if (title != null &amp;&amp; content != null) { //得到NewsContentFragment的实例 val fragment = supportFragmentManager.findFragmentById(R.id.newsContentFrag) as NewsContentFragment fragment.refresh(title, content) //刷新界面 } } } 接下来还需要再创建一个用于显示新闻列表的布局，新建news_title_frag.xml，代码如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;androidx.recyclerview.widget.RecyclerView android:id=&quot;@+id/newsTitleRecyclerView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;/LinearLayout&gt; 这里只有一个用于显示新闻列表的RecyclerView。既然要用到 RecyclerView，那么就必定少不了子项的布局。新建news_item.xml作为 RecyclerView 子项的布局，代码如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;TextView xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/newsTitle&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:ellipsize=&quot;end&quot; android:maxLines=&quot;1&quot; android:paddingLeft=&quot;10dp&quot; android:paddingTop=&quot;15dp&quot; android:paddingRight=&quot;10dp&quot; android:paddingBottom=&quot;15dp&quot; android:textSize=&quot;18sp&quot;&gt; &lt;/TextView&gt; 子项的布局也非常简单，只有一个 TextView，android:padding表示给控件的周围加上补白，这样不至于让文本内容紧靠在边缘上。android:maxLines设置为 1 表示让这个 TextView只能单行显示。android:ellipsize用于设定当文本内容超出控件宽度时文本的缩略方式，这里指定成end表示在尾部进行缩略。 然后新建NewsTitleFragment作为展示新闻列表的 Fragment，代码如下所示： class NewsTitleFragment : Fragment() { private var isTwoPane = false override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { return inflater.inflate(R.layout.news_title_frag,container,false) } override fun onActivityCreated(savedInstanceState: Bundle?) { super.onActivityCreated(savedInstanceState) isTwoPane = activity?.findViewById&lt;View&gt;(R.id.newsContentLayout) != null } } 通过在 Activity 中能否找到一个 id 为newsContentLayout的 View，来判断当前是双页模式还是单页模式。注意，由于在 Fragment 中调用getActivity()方法有可能返回 null，所以在上述代码中使用了一个?.操作符来保证代码的安全性。 怎样才能实现让 id 为newsContentLayout的 View 只在双页模式中才会出现呢？其实并不复杂，借助限定符即可。首先修改activity_main.xml中的代码，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/newsTitleLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;fragment android:id=&quot;@+id/newsTitleFrag&quot; android:name=&quot;com.example.fragmentbestpractice.NewsTitleFragment&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;/FrameLayout&gt; 上述代码表示在单页模式下只会加载一个新闻标题的 Fragment。 然后新建layout-sw600dp文件夹，在这个文件夹下再新建一个activity_main.xml文件，代码如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;fragment android:id=&quot;@+id/newsTitleFrag&quot; android:name=&quot;com.example.fragmentbestpractice.NewsTitleFragment&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;1&quot; /&gt; &lt;FrameLayout android:id=&quot;@+id/newsContentLayout&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;3&quot;&gt; &lt;fragment android:id=&quot;@+id/newsContentFrag&quot; android:name=&quot;com.example.fragmentbestpractice.NewsContentFragment&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; &lt;/FrameLayout&gt; &lt;/LinearLayout&gt; 在双页模式下，同时引入了两个 Fragment，并将新闻内容的 Fragment 放在了一个 FrameLayout 布局下，而这个布局的 id 正是newsContentLayout。因此，能够找到这个 id 的时候就是双页模式，否则就是单页模式。 接下来在NewsTitleFragment中将新闻列表展示出来。我们在其中新建一个内部类NewsAdapter来作为 RecyclerView 的适配器向其中填充数据，如下所示： class NewsTitleFragment : Fragment() { private var isTwoPane = false inner class NewsAdapter(private val newsList: List&lt;News&gt;) : RecyclerView.Adapter&lt;NewsAdapter.ViewHolder&gt;() { inner class ViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) { val newsTitle: TextView = itemView.findViewById(R.id.newsTitle) } override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): ViewHolder { val view = LayoutInflater.from(parent.context) .inflate(R.layout.news_item, parent, false) val holder = ViewHolder(view) holder.itemView.setOnClickListener { val news = newsList[holder.adapterPosition] if (isTwoPane) { //如果是双页模式 则刷新NewsContentFragment中的内容 val fragment = newsContentFrag as NewsContentFragment fragment.refresh(news.title, news.content) } else { //如果是单页模式 直接启动NewsContentActivity NewsContentActivity.actionStart(parent.context, news.title, news.content) } } return holder } override fun onBindViewHolder(holder: NewsAdapter.ViewHolder, position: Int) { val news = newsList[position] holder.newsTitle.text = news.title } override fun getItemCount(): Int { return newsList.size } } override fun onCreateView( inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle? ): View? { return inflater.inflate(R.layout.news_title_frag, container, false) } override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) val layoutManager = LinearLayoutManager(activity) newsTitleRecyclerView.layoutManager = layoutManager val adapter = NewsAdapter(getNews()) newsTitleRecyclerView.adapter = adapter } /** * onActivityCreated()：确保与Fragment相关联的Activity已经创建完毕时调用 * 但书中的onActivityCreated()方法现已被弃用 * 与Fragment视图有关的代码应在onViewCreated()（在onActivityCreated()之前调用）中执行 * 但是在判断单双页模式即得到isTwoPane变量值时 调用了getActivity()方法 * 而onViewCreated()方法中没有得到与fragment绑定的Activity实例 * 使得isTwoPane值保持初始值不变 在单双页判断时 始终会启动一个新的Activity来展示新闻内容 * 因此这里将相关代码放在onStart()方法中 * */ override fun onStart() { super.onStart() isTwoPane = activity?.findViewById&lt;View&gt;(R.id.newsContentLayout) != null } private fun getNews(): List&lt;News&gt; { val newsList = ArrayList&lt;News&gt;() for (i in 1..50) { val news = News(&quot;This is news title $i&quot;, getRandomLengthString(&quot;This is news content $i&quot;)) newsList.add(news) } return newsList } private fun getRandomLengthString(str: String): String { val n = (1..20).random() val builder = StringBuilder() repeat(n) { builder.append(str) } return builder.toString() } } 这里调用了getNews()来初始化 50 条模拟新闻数据，getRandomLengthString()方法来随机生成新闻内容的长度，以保证每条新闻的内容差距比较大。 首先在手机模拟器上运行，效果如下： 然后点击第一条新闻，效果如下： 然后在平板模拟器上运行，效果如下： 同样点击第一条新闻，效果如下： ","link":"https://Petrichoroo.github.io/post/jian-yi-ban-de-xin-wen-ying-yong-kotlin/"},{"title":"聊天界面实现（Kotlin）","content":" 聊天界面 制作 9-Patch 图片 具体实现 聊天界面 制作 9-Patch 图片 9-Patch是一种被特殊处理过的 png 图片，能够指定哪些区域可以被拉伸、哪些区域不可以。 新建一个布局，背景图片设置成一张气泡样式的图片 message_left.png，修改activity_main.xml中的代码，如下所示： &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;50dp&quot; android:background=&quot;@drawable/message_left&quot;&gt; &lt;/LinearLayout&gt; 由于 message_left 的宽度不足以填满整个屏幕的宽度，整张图片被均匀地拉伸了，效果非常差。这时就可以使用 9-Patch 图片来进行改善。 在 Android Studio 中，我们可以将任何png类型的图片制作成9-Patch图片。 首先对着 message_left.png 图片右击 →Create 9-Patch file，然后保持默认文件名就可以了，其实就相当于创建了一张以 9.png 为后缀的同名图片，点击Save完成保存。 这时 Android Studio 会显示如下的编辑界面： 我们可以在图片的 4 个边框绘制一个个的小黑点，在上边框和左边框绘制的部分表示当图片需要拉伸时就拉伸黑点标记的区域，在下边框和右边框绘制的部分表示内容允许被放置的区域。使用鼠标在图片的边缘拖动就可以进行绘制了，按住Shift键拖动可以进行擦除。绘制完成后效果如下所示： 最后记得要将原来的 message_left.png 图片删除，只保留制作好的message_left.9.png图片即可，因为 Android 项目中不允许同一文件夹下有两张相同名称的图片（即使后缀名不同也不行）。重新运行程序，效果如下所示： 具体实现 既然是要编写一个聊天界面，那肯定要有收到的消息和发出的消息。 上面我们制作的message_left.9.png作为收到消息的背景图，同样地，制作message_right.9.png作为发出消息的背景图，制作过程是完全一样的。 接下来开始编写主界面，修改 activity_main.xml 中的代码，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:background=&quot;#d8e0e8&quot; android:orientation=&quot;vertical&quot; tools:context=&quot;.MainActivity&quot;&gt; &lt;androidx.recyclerview.widget.RecyclerView android:id=&quot;@+id/recyclerView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;0dp&quot; android:layout_weight=&quot;1&quot; /&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;EditText android:id=&quot;@+id/inputText&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:hint=&quot;Type something here&quot; android:maxLines=&quot;2&quot; /&gt; &lt;Button android:id=&quot;@+id/send&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Send&quot; android:textAllCaps=&quot;false&quot; /&gt; &lt;/LinearLayout&gt; &lt;/LinearLayout&gt; 然后定义消息的实体类，新建Msg，代码如下所示： class Msg(val content: String, val type: Int) { companion object { const val TYPE_RECEIVED = 0 const val TYPE_SEND = 1 } } Msg 类中只有两个字段：content表示消息的内容，type表示消息的类型。其中消息类型有两个值可选，分别表示接收消息与发送消息，这里用const关键字将其声明成常量。 注意只有在单例类、companion object 或顶层方法中才可以使用 const 关键字。 接下来开始编写 RecyclerView 的子项布局，新建msg_left_item.xml，代码如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:padding=&quot;10dp&quot;&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;left&quot; android:background=&quot;@drawable/message_left&quot;&gt; &lt;TextView android:id=&quot;@+id/leftMsg&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:layout_margin=&quot;10dp&quot; android:textColor=&quot;#fff&quot; /&gt; &lt;/LinearLayout&gt; &lt;/FrameLayout&gt; 这是接收消息的子项布局。这里我们让收到的消息居左对齐，并使用message_left.9.png作为背景图。 类似地，我们还需要再编写一个发送消息的子项布局，新建msg_right_item.xml，代码如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;FrameLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:padding=&quot;10dp&quot;&gt; &lt;LinearLayout android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;right&quot; android:background=&quot;@drawable/message_right&quot;&gt; &lt;TextView android:id=&quot;@+id/rightMsg&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:layout_margin=&quot;10dp&quot; android:textColor=&quot;#000&quot; /&gt; &lt;/LinearLayout&gt; &lt;/FrameLayout&gt; 这里我们让发出的消息居右对齐，并使用message_right.9.png作为背景图。 接下来需要创建 RecyclerView 的适配器类，新建类MsgAdapter，代码如下所示： class MsgAdapter(private val msgList: List&lt;Msg&gt;) : RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;() { //缓存msg_left_item.xml布局中的控件 inner class LeftViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) { val leftMsg: TextView = itemView.findViewById(R.id.leftMsg) } //缓存msg_right_item.xml布局中的控件 inner class RightViewHolder(itemView: View) : RecyclerView.ViewHolder(itemView) { val rightMsg: TextView = itemView.findViewById(R.id.rightMsg) } //返回当前position对应的消息类型 override fun getItemViewType(position: Int): Int { val msg = msgList[position] return msg.type } //根据不同的viewType来加载不同的布局并创建不同的ViewHolder override fun onCreateViewHolder(parent: ViewGroup, viewType: Int) = if (viewType == Msg.TYPE_RECEIVED) { val view = LayoutInflater.from(parent.context) .inflate(R.layout.msg_left_item, parent, false) LeftViewHolder(view) } else { val view = LayoutInflater.from(parent.context) .inflate(R.layout.msg_right_item, parent, false) RightViewHolder(view) } override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) { val msg = msgList[position] when (holder) { is LeftViewHolder -&gt; holder.leftMsg.text = msg.content //显示到左边的消息布局 is RightViewHolder -&gt; holder.rightMsg.text = msg.content //显示到右边的消息布局 else -&gt; throw IllegalArgumentException() } } override fun getItemCount(): Int { return msgList.size } } 核心就是根据不同的 viewType 创建不同的界面。 最后修改 MainActivity 中的代码，为 RecyclerView 初始化一些数据，并给发送按钮加入事件响应，代码如下所示： class MainActivity : AppCompatActivity() { private val msgList = ArrayList&lt;Msg&gt;() private var adapter: MsgAdapter? = null override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) initMsg() val send: Button = findViewById(R.id.send) val inputText: EditText = findViewById(R.id.inputText) val recyclerView: RecyclerView = findViewById(R.id.recyclerView) val layoutManager = LinearLayoutManager(this) recyclerView.layoutManager = layoutManager adapter = MsgAdapter(msgList) recyclerView.adapter = adapter send.setOnClickListener { val content = inputText.text.toString() if (content.isNotEmpty()) { val msg = Msg(content, Msg.TYPE_SENT) msgList.add(msg) adapter?.notifyItemInserted(msgList.size - 1) // 当有新消息时 刷新RecyclerView中的显示 recyclerView.scrollToPosition(msgList.size - 1) // 显示的数据定位到最后一行 inputText.setText(&quot;&quot;) // 清空输入框中的内容 } } } /** * 初始化几条数据用于在RecyclerView中显示 * */ private fun initMsg() { val msg1 = Msg(&quot;Hello guy.&quot;, Msg.TYPE_RECEIVED) msgList.add(msg1) val msg2 = Msg(&quot;Hello. Who is that?&quot;, Msg.TYPE_SENT) msgList.add(msg2) val msg3 = Msg(&quot;This is Tom. Nice talking to you. &quot;, Msg.TYPE_RECEIVED) msgList.add(msg3) } } 还可以调用适配器的notifyDataSetChanged()方法，它会将 RecyclerView 中所有可见的元素全部刷新，这样不管是新增、删除、还是修改元素，界面上都会显示最新的数据，但缺点是效率会相对差一些。 代码优化可见：Kotlin：延迟初始化和密封类 效果如下： ","link":"https://Petrichoroo.github.io/post/liao-tian-jie-mian-shi-xian-kotlin/"},{"title":"Kotlin：延迟初始化和密封类","content":" Kotlin 对变量延迟初始化 使用密封类优化代码 Kotlin 对变量延迟初始化 如果你的类中存在很多全局变量实例，为了保证它们能够满足 Kotlin 的空指针检查语法标准，你不得不做许多的非空判断保护才行，即使你非常确定它们不会为空。 观察如下代码，会发现这里适配器的写法略微有点特殊： class MainActivity : AppCompatActivity(), View.OnClickListener { private var adapter: MsgAdapter? = null override fun onCreate(savedInstanceState: Bundle?) { ... adapter = MsgAdapter(msgList) ... } override fun onClick(v: View?) { ... adapter?.notifyItemInserted(msgList.size - 1) ... } } 这里将adapter设置为了全局变量，但是它的初始化工作是在onCreate()方法中进行的，因此不得不先将 adapter 赋值为null，同时把它的类型声明成MsgAdapter?。 虽然我们会在 onCreate() 方法中对 adapter 进行初始化，同时确保onClick()必然在 onCreate() 方法之后才会调用，但是我们在 onClick() 方法中调用 adapter 的任何方法时仍然要进行判空处理才行，否则编译肯定无法通过。 而当你的代码中有了越来越多的全局变量实例时，这个问题就会变得越来越明显，到时候你可能必须编写大量额外的判空处理代码，只是为了满足 Kotlin 编译器的要求。 因此，我们可以考虑对全局变量进行延迟初始化。 延迟初始化使用的是lateinit关键字，它可以告诉 Kotlin 编译器，我会在晚些时候对这个变量进行初始化，这样就不用在一开始的时候将它赋值为 null 了。 使用延迟初始化的方式对上述代码进行优化，如下所示： class MainActivity : AppCompatActivity(), View.OnClickListener { private lateinit var adapter: MsgAdapter override fun onCreate(savedInstanceState: Bundle?) { ... adapter = MsgAdapter(msgList) ... } override fun onClick(v: View?) { ... adapter.notifyItemInserted(msgList.size - 1) ... } } 当然，使用lateinit关键字也不是没有任何风险，如果我们在 adapter 变量还没有初始化的情况下就直接使用它，那么程序就一定会崩溃。 所以，当我们对一个全局变量使用了lateinit关键字时，请一定要确保它在被任何地方调用之前已经完成了初始化工作，否则 Kotlin 将无法保证程序的安全性。 我们可以通过代码来判断一个全局变量是否已经完成了初始化，这样在某些时候能够有效地避免重复对某一个变量进行初始化操作，示例代码如下： class MainActivity : AppCompatActivity(), View.OnClickListener { private lateinit var adapter: MsgAdapter override fun onCreate(savedInstanceState: Bundle?) { ... if (!::adapter.isInitialized) { //若已初始化 取反后为false adapter = MsgAdapter(msgList) } ... } } 使用密封类优化代码 新建一个 Kotlin 文件，文件名就叫Result.kt，然后在这个文件中编写如下代码： interface Result class Success(val msg: String) : Result class Failure(val error: Exception) : Result 这里定义了一个Result接口，用于表示某个操作的执行结果，接口中不用编写任何内容。然后定义了两个类去实现 Result 接口。 接下来再定义一个getResultMsg()方法，用于获取最终执行结果的信息，代码如下所示： fun getResultMsg(result: Result) = when (result) { is Success -&gt; result.msg is Failure -&gt; result.error.message else -&gt; throw IllegalArgumentException() } getResultMsg() 方法中接收一个Result参数。我们通过when语句来判断 result 是属于Success还是Failure，再分别返回对应的消息。 但比较让人讨厌的是，接下来我们不得不再编写一个else条件，否则 Kotlin 编译器会认为这里缺少条件分支，代码将无法编译通过。但实际上 Result 的执行结果只可能是 Success 或者 Failure，所以在这里直接抛出了一个异常，只是为了满足 Kotlin 编译器的语法检查而已。 另外，编写 else 条件还有一个潜在的风险。若现在新增了一个Unknown类并实现 Result 接口，用于表示未知的执行结果，但是忘记在 getResultMsg() 方法中添加相应的条件分支，编译器在这种情况下是不会提醒我们的，而是会在运行的时候进入 else 条件里面，从而抛出异常并导致程序崩溃。 不过，Kotlin 的密封类可以很好地解决这个问题。 密封类的关键字是sealed class，下面将 Result 接口改造成密封类的写法： sealed class Result class Success(val msg: String) : Result() class Failure(val error: Exception) : Result() 由于密封类是一个可继承的类，因此在继承它的时候需要在后面加上一对括号。 现在 getResultMsg() 方法中的 else 条件已经不再需要了。 因为当在 when 语句中传入一个密封类变量作为条件时，Kotlin 编译器会自动检查该密封类有哪些子类，并强制要求你将每一个子类所对应的条件全部处理。这样就可以保证，即使没有编写 else 条件，也不可能会出现漏写条件分支的情况。 而如果我们现在新增一个 Unknown 类，并也让它继承自 Result，此时 getResultMsg() 方法就一定会报错，必须增加一个 Unknown 的条件分支才能让代码编译通过。 密封类及其所有子类只能定义在同一个文件的顶层位置，不能嵌套在其他类中，这是被密封类底层的实现机制所限制的。 下面使用密封类结合MsgAdapter中的ViewHolder一起使用，并顺便优化一下 MsgAdapter 中的代码。 class MsgAdapter(val msgList: List&lt;Msg&gt;) : RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt;() { inner class LeftViewHolder(view: View) : RecyclerView.ViewHolder(view) { ... } inner class RightViewHolder(view: View) : RecyclerView.ViewHolder(view) { ... } override fun getItemViewType(position: Int): Int { ... } override fun onCreateViewHolder(parent: ViewGroup, viewType: Int) { ... } override fun onBindViewHolder(holder: RecyclerView.ViewHolder, position: Int) { val msg = msgList[position] when (holder) { is LeftViewHolder -&gt; holder.leftMsg.text = msg.content is RightViewHolder -&gt; holder.rightMsg.text = msg.content else -&gt; throw IllegalArgumentException() } } override fun getItemCount() = msgList.size } onBindViewHolder()方法中就存在一个没有实际作用的 else 条件，只是抛出了一个异常而已。对于这部分代码，我们就可以借助密封类的特性来进行优化。 删除LeftViewHolder和RightViewHolder类，新建一个MsgViewHolder.kt文件，在其中加入如下代码： sealed class MsgViewHolder(view: View) : RecyclerView.ViewHolder(view) class LeftViewHolder(view: View) : MsgViewHolder(view) { val leftMsg: TextView = view.findViewById(R.id.leftMsg) } class RightViewHolder(view: View) : MsgViewHolder(view) { val rightMsg: TextView = view.findViewById(R.id.rightMsg) } 这里定义了一个密封类MsgViewHolder，并让它继承自RecyclerView.ViewHolder，然后让 LeftViewHolder 和 RightViewHolder 继承自 MsgViewHolder。 这样就相当于密封类 MsgViewHolder 只有两个已知子类，因此在 when 语句中只要处理这两种情况的条件分支即可。 现在修改 MsgAdapter 中的代码，如下所示： class MsgAdapter(val msgList: List&lt;Msg&gt;) : RecyclerView.Adapter&lt;MsgViewHolder&gt;() { ... override fun onBindViewHolder(holder: MsgViewHolder, position: Int) { val msg = msgList[position] when (holder) { is LeftViewHolder -&gt; holder.leftMsg.text = msg.content is RightViewHolder -&gt; holder.rightMsg.text = msg.content } } ... } 这里我们将RecyclerView.Adapter的泛型指定成刚刚定义的密封类MsgViewHolder。 这样onBindViewHolder()方法传入的参数就变成了 MsgViewHolder。然后只要在 when 语 句当中处理两种情况即可。 这种 RecyclerView 适配器的写法更加规范也更加推荐。 ","link":"https://Petrichoroo.github.io/post/kotlinyan-chi-chu-shi-hua-he-mi-feng-lei/"},{"title":"Kotlin：标准函数和静态方法","content":" Kotlin 标准函数 with run apply 定义静态方法 Kotlin 标准函数 Kotlin 的标准函数指的是 Standard.kt 文件中定义的函数，任何 Kotlin 代码都可以自由地调用所有的标准函数。 with with函数接收两个参数：第一个参数可以是一个任意类型的对象，第二个参数是一个 Lambda 表达式。with 函数会在 Lambda 表达式中提供第一个参数对象的上下文，并使用 Lambda 表达式中的最后一行代码作为返回值返回。示例代码如下： val result = with(obj) { // 这里是obj的上下文 &quot;value&quot; // with函数的返回值 } 可以在连续调用同一个对象的多个方法时让代码变得更加精简。 比如有一个水果列表，现在我们想吃完所有水果，并将结果打印出来，就可以这样写： val list = listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;) val builder = StringBuilder() builder.append(&quot;Start eating fruits.\\n&quot;) for (fruit in list) { builder.append(fruit).append(&quot;\\n&quot;) } builder.append(&quot;Ate all fruits.&quot;) val result = builder.toString() println(result) 仔细观察上述代码，会发现我们连续调用了很多次 builder 对象的方法。其实这个时候就可以考虑使用with函数来让代码变得更加精简，如下所示： val list = listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;) val result = with(StringBuilder()) { append(&quot;Start eating fruits.\\n&quot;) for (fruit in list) { append(fruit).append(&quot;\\n&quot;) } append(&quot;Ate all fruits.&quot;) toString() } println(result) 这里给 with 函数的第一个参数传入了一个 StringBuilder 对象，那么接下来整个 Lambda 表达式的上下文就会是这个 StringBuilder 对象。 于是我们在 Lambda 表达式中就不用再像刚才那样调用builder.append()和builder.toString()方法了，而是可以直接调用 append() 和 toString() 方法。Lambda 表达式的最后一行代码会作为 with 函数的返回值返回。 run run函数的用法和使用场景其实和 with 函数是非常类似的，只是稍微做了一些语法改动而已。首先 run 函数通常不会直接调用，而是要在某个对象的基础上调用；其次 run 函数只接收一个 Lambda 参数，并且会在 Lambda 表达式中提供调用对象的上下文。同样地，也会使用 Lambda 表达式中的最后一行代码作为返回值返回。示例代码如下： val result = obj.run { // 这里是obj的上下文 &quot;value&quot; // run函数的返回值 } 使用run函数来修改一下吃水果的这段代码，如下所示： val list = listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;) val result = StringBuilder().run { append(&quot;Start eating fruits.\\n&quot;) for (fruit in list) { append(fruit).append(&quot;\\n&quot;) } append(&quot;Ate all fruits.&quot;) toString() } println(result) apply apply函数和 run 函数也是极其类似的，都要在某个对象上调用，并且只接收一个 Lambda 参数，也会在 Lambda 表达式中提供调用对象的上下文，但是 apply 函数无法指定返回值，而是会自动返回调用对象本身。示例代码如下： val result = obj.apply { // 这里是obj的上下文 } // result == obj 使用apply函数来修改一下吃水果的这段代码，如下所示： val list = listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;) val result = StringBuilder().apply { append(&quot;Start eating fruits.\\n&quot;) for (fruit in list) { append(fruit).append(&quot;\\n&quot;) } append(&quot;Ate all fruits.&quot;) //返回的给 result 实际上是一个 StringBuilder 对象 } println(result.toString()) 定义静态方法 静态方法在某些编程语言里面又叫作类方法，指的就是那种不需要创建实例就能调用的方法。因而静态方法非常适合用于编写一些工具类的功能，因为工具类通常没有创建实例的必要，基本是全局通用的。 和绝大多数主流编程语言不同，Kotlin 极度弱化了静态方法这个概念。像工具类这种功能，在 Kotlin 中就非常推荐使用单例类的方式来实现。如下： object Util { fun doAction() { println(&quot;do action&quot;) } } 不过，使用单例类的写法会将整个类中的所有方法全部变成类似于静态方法的调用方式。 若只是希望让类中的某一个方法变成静态方法的调用方式，就需要用到companion object关键字，示例如下： class Util { fun doAction1() { println(&quot;do action1&quot;) } companion object { fun doAction2() { println(&quot;do action2&quot;) } } } 这里首先将 Util 从单例类改成了一个普通类，并使用了companion object关键字。 因此，doAction1() 方法是一定要先创建 Util 类的实例才能调用的，而doAction2()方法可以直接使用Util.doAction2()的方式调用。 不过，doAction2()方法其实也并不是静态方法，companion object这个关键字实际上会在 Util 类的内部创建一个伴生类，而 doAction2() 方法就是定义在这个伴生类里面的实例方法。只是 Kotlin 会保证 Util 类始终只会存在一个伴生类对象，因此调用 Util.doAction2() 方法实际上就是调用了 Util 类中伴生对象的 doAction2() 方法。 可以看出，Kotlin 确实没有直接定义静态方法的关键字，但是提供了一些语法特性来支持类似于静态方法调用的写法。 若要真正地定义一个静态方法， Kotlin 仍然提供了两种实现方式：注解和顶层方法。 如果我们给单例类或 companion object 中的方法加上@JvmStatic注解，那么 Kotlin 编译器就会将这些方法编译成真正的静态方法，如下： class Util { fun doAction1() { println(&quot;do action1&quot;) } companion object { @JvmStatic fun doAction2() { println(&quot;do action2&quot;) } } } 注意，@JvmStatic 注解只能加在单例类或 companion object 中的方法上。 顶层方法指的是那些没有定义在任何类中的方法。Kotlin 编译器会将所有的顶层方法全部编译成静态方法，因此只要定义了一个顶层方法，那么它就一定是静态方法。 想要定义一个顶层方法，首先需要创建一个 Kotlin 文件。 对着任意包名右击 → New → Kotlin File/Class，在弹出的对话框中输入文件名即可。注意创建类型要选择 File。 比如创建一个Helper.kt文件。现在我们在这个文件中定义的任何方法都会是顶层方法，比如这里我就定义一个doSomething()方法吧，如下所示： fun doSomething() { println(&quot;do something&quot;) } 若是在 Kotlin 代码中，所有的顶层方法都可以在任何位置被直接调用，不用管包名路径，也不用创建实例，直接键入 doSomething() 即可。 但若是在 Java 代码中，会发现是找不到 doSomething() 这个方法的，因为 Java 中没有顶层方法这个概念，所有的方法必须定义在类中。 刚才创建的 Kotlin 文件名叫作Helper.kt，于是 Kotlin 编译器会自动创建一个叫作 HelperKt 的 Java 类，doSomething() 方法就是以静态方法的形式定义在 HelperKt 类里面的，因此在 Java 中使用HelperKt.doSomething()的写法来调用即可。 ","link":"https://Petrichoroo.github.io/post/kotlinbiao-zhun-han-shu-he-jing-tai-fang-fa/"},{"title":"Kotlin 基础","content":" Kotlin Kotlin 语言简介 变量和函数 变量 函数 函数的可见性修饰符 Kotlin 函数的语法糖 程序的逻辑控制 if 条件语句 when 条件语句 循环语句 面向对象编程 类与对象 继承与构造函数 接口 数据类与单例类 Lambda 编程 集合的创建与遍历 List Set Map 集合的函数式 API Java 函数式 API 的使用 空指针检查 可空类型系统 判空辅助工具 字符串内嵌表达式 函数的参数默认值 Kotlin Kotlin 语言简介 Google 在 2017 年的 I/O 大会上宣布，Kotlin 正式成为 Android 的一级开发语言，和 Java 平起平坐，Android Studio 也对 Kotlin 进行了全面的支持。 两年之后，Google 又在 2019 年的 I/O 大会上宣布，Kotlin 已经成为 Android 的第一开发语言，虽然 Java 仍然可以继续使用，但 Google 更加推荐开发者使用 Kotlin 来编写 Android 应用程序，并且未来提供的官方 API 也将会优先考虑 Kotlin 版本。 编程语言大致可以分为两类：编译型语言和解释型语言。 编译型语言的特点是编译器会将我们编写的源代码一次性地编译成计算机可识别的二进制文件，然后计算机直接执行，像 C 和 C++ 都属于编译型语言。 解释型语言则完全不一样，它有一个解释器，在程序运行时，解释器会一行行地读取我们编写的源代码，然后实时地将这些源代码解释成计算机可识别的二进制数据后再执行，因此解释型语言通常效率会差一些，像 Python 和 JavaScript 都属于解释型语言。 虽然 Java 代码是要先编译再运行的，但是 Java 代码编译之后生成的并不是计算机可识别的二进制文件，而是一种特殊的class文件，这种 class 文件只有 Java 虚拟机才能识别，而这个虚拟机担当的其实就是解释器的角色，它会在程序运行时将编译后的 class 文件解释成计算机可识别的二进制数据后再执行。因此，准确来讲，Java 属于解释型语言。 Java 虚拟机（Android 中叫 ART，一种移动优化版的虚拟机）不关心 class 文件是从 Java 编译来的，还是从 Kotlin 编译来的，只要是符合规格的 class 文件，它都能识别。因此，JetBrains 才能以一个第三方公司的身份设计出一门用来开发 Android 应用程序的编程语言。 Kotlin 的语法更加简洁，对于同样的功能，使用 Kotlin 开发的代码量，可能会比使用 Java 开发的减少 50% 甚至更多。 Kotlin 的语法更加高级，相比于 Java 比较老旧的语法，Kotlin 增加了很多现代高级语言的语法特性，使得开发效率大大提升。还有，Kotlin 在语言安全性方面下了很多工夫，几乎杜绝了空指针这个全球崩溃率最高的异常。 Kotlin 和 Java 是 100% 兼容的。Kotlin 可以直接调用使用 Java 编写的代码，也可以无缝使用 Java 第三方的开源库。 变量和函数 变量 Kotlin 中定义一个变量，只允许在变量前声明两种关键字：val和var。 val（value 的简写）：用来声明一个不可变的变量，这种变量在初始赋值之后就再也不能重新赋值，对应 Java 中的final变量。 var（variable 的简写）：用来声明一个可变的变量，这种变量在初始赋值之后仍然可以再被重新赋值，对应 Java 中的非 final 变量。 Kotlin 拥有出色的类型推导机制。若你要把一个整数赋值给 a，那么 a 就只能是整型变量，而如果你要把一个字符串赋值给 a 的话，那么 a 就会被自动推导成字符串变量。 fun main() { val a = 10 println(&quot;a = &quot; + a) } 注意，Kotlin 每一行代码的结尾是不用加分号的。 如果我们对一个变量延迟赋值的话，Kotlin 就无法自动推导它的类型了。这时候就需要显式地声明变量类型。 val a: Int = 10 使用 val 关键字声明的变量无法被重新赋值，改用 var 即可。 Kotlin 完全抛弃了 Java 中的基本数据类型，全部使用了对象数据类型。在 Java 中int 是关键字，而在 Kotlin 中 Int 变成了一个类，它拥有自己的方法和继承结构。 永远优先使用 val 来声明一个变量，而当 val 没有办法满足你的需求时再使用 var。这样设计出来的程序会更加健壮，也更加符合高质量的编码规范。 函数 Kotlin 允许我们自由地定义函数，语法规则如下： fun methodName(param1: Int, param2: Int): Int { return 0 } fun（function的简写）是定义函数的关键字，无论你定义什么函数，都一定要使用 fun 来声明。 参数的声明格式是“参数名: 参数类型”。 参数括号后面的那部分是可选的，用于声明该函数会返回什么类型的数据。 函数的可见性修饰符 Kotlin 中有 4 种函数的可见性修饰符，分别是public、private、protected和internal，需要使用哪种修饰符时，直接定义在 fun 关键字的前面即可。 Java 和 Kotlin 函数可见性修饰符对照表： Kotlin 函数的语法糖 编写一个名为 largerNumber() 的函数，其作用是：接收两个整型参数，然后总是返回两个参数中更大的那个数，如下所示： fun largerNumber(num1: Int, num2: Int): Int { return max(num1, num2) } max() 函数是 Kotlin 提供的一个内置函数，它的作用就是返回两个参数中更大的那个数，这里给其做了一层封装而已。 Kotlin 函数的语法糖：当一个函数中只有一行代码时，Kotlin 允许我们不必编写函数体，可以直接将唯一的一行代码写在函数定义的尾部，中间用等号连接即可。因此可以将代码简化成如下形式： fun largerNumber(num1: Int, num2: Int): Int = max(num1, num2) 使用这种语法，由于 Kotlin 出色的类型推导机制，return 关键字也可以省略了，等号足以表达返回值的意思。代码可以进一步简化成如下形式： fun largerNumber(num1: Int, num2: Int) = max(num1, num2) 程序的逻辑控制 Kotlin 中的条件语句主要有两种实现方式：if 和 when。 if 条件语句 使用 if 判断用来实现 largerNumber() 函数，写法如下： fun largerNumber(num1: Int, num2: Int): Int { var value = 0 if (num1 &gt; num2) { value = num1 } else { value = num2 } return value } 这里使用了 var 关键字来声明 value 这个变量，因为其涉及到了重新赋值。 Kotlin 中的 if 语句相比于 Java 有一个额外的功能，它是可以有返回值的，返回值就是 if 语句每一个条件中最后一行代码的返回值。因此，上述代码就可以简化成如下形式： fun largerNumber(num1: Int, num2: Int): Int { val value = if (num1 &gt; num2) { num1 } else { num2 } return value } 你会发现其实 value 变量也是多余的，同时根据之前所学的语法糖，可以将代码进一步简化： fun largerNumber(num1: Int, num2: Int) = if (num1 &gt; num2) num1 else num2 when 条件语句 Kotlin 中的 when 语句有点类似于 Java 中的 switch 语句，但它又远比 switch 语句强大得多。 这里编写一个查询考试成绩的功能，输入一个学生的姓名，返回该学生考试的分数。如果使用 if 语句实现，代码会比较冗余，因此当判断条件非常多的时候，应该考虑使用 when 语句。如下所示： fun getScore(name: String) = when (name) { &quot;Tom&quot; -&gt; 86 &quot;Jim&quot; -&gt; 77 &quot;Jack&quot; -&gt; 95 &quot;Lily&quot; -&gt; 100 else -&gt; 0 } when 语句和 if 语句一样，也是可以有返回值的，因此仍然可以使用单行代码函数的语法糖。 when 语句允许传入一个任意类型的参数，然后可以在 when 的结构体中定义一系列的条件，格式是： 匹配值 -&gt; { 执行逻辑 } 除了精确匹配之外，when 语句还允许进行类型匹配，如下： fun checkNumber(num: Number) { when (num) { is Int -&gt; println(&quot;number is Int&quot;) is Double -&gt; println(&quot;number is Double&quot;) else -&gt; println(&quot;number not support&quot;) } } is关键字就是类型匹配的核心，它相当于 Java 中的 instanceof 关键字。 when 语句还有一种不带参数的用法，虽然这种用法可能不太常用，但有的时候却能发挥很强的扩展性，如下所示： fun getScore(name: String) = when { name == &quot;Tom&quot; -&gt; 86 name == &quot;Jim&quot; -&gt; 77 name == &quot;Jack&quot; -&gt; 95 name == &quot;Lily&quot; -&gt; 100 else -&gt; 0 } Kotlin 中判断字符串或对象是否相等可以直接使用==关键字。 这种用法是将判断的表达式完整地写在 when 的结构体当中。这种无参数的 when 语句写起来比较冗余，但有些场景必须使用这种写法才能实现。 假设所有名字以 Tom 开头的人，他的分数都是 86 分，这种场景如果用带参数的 when 语句来写就无法实现，而使用不带参数的when语句就可以这样写： fun getScore(name: String) = when { name.startsWith(&quot;Tom&quot;) -&gt; 86 ... else -&gt; 0 } 现在不管你传入的名字是 Tom 还是 Tommy，只要是以 Tom 开头的名字，他的分数就是 86 分。 循环语句 Kotlin 提供了 while 循环和 for 循环，其中 while 循环不管是在语法还是使用技巧上都和 Java 中的 while 循环没有任何区别。 Java 中常用的 for-i 循环在 Kotlin 中直接被舍弃了，而 Java 的另一种 for-each 循环则被 Kotlin 进行了大幅度的加强，变成了for-in循环。 首先可以使用如下 Kotlin 代码来表示一个区间： val range = 0..10 两端都是闭区间，即 [0,10]。 其中，..是创建两端闭区间的关键字，在其两边指定区间的左右端点就可以创建一个区间。 有了区间之后，我们就可以通过for-in循环来遍历这个区间： fun main() { for (i in 0..10) { println(i) } } Kotlin 中可以使用until关键字来创建一个左闭右开的区间，如下所示： val range = 0 until 10 左闭右开，即 [0,10)。 默认情况下，for-in 循环每次执行循环时会在区间范围内递增 1，可以使用step关键字跳过其中的一些元素，如下： fun main() { for (i in 0 until 10 step 2) { println(i) } } 若想创建一个降序的区间，可以使用downTo关键字，如下： fun main() { for (i in 10 downTo 1) { println(i) } } [10, 1] 的降序区间 若有一些特殊场景使用for-in循环无法实现，可以改用while循环。 面向对象编程 面向对象的语言是可以创建类的。类就是对事物的一种封装，类中可以拥有自己的字段和函数，字段表示该类所拥有的属性，函数则表示该类可以有哪些行为。 类与对象 Kotlin 中也是使用class关键字来声明一个类的。创建一个 Person 类，并为其加入字段和函数，如下： class Person { var name = &quot;&quot; var age = 0 fun eat() { println(name + &quot; is eating. He is &quot; + age + &quot; years old.&quot;) } } 这里使用var关键字创建两个字段，因为需要在创建对象之后再指定具体的姓名和年龄。 对这个类进行实例化，如下： val p = Person() Kotlin 中实例化一个类的方式和 Java 是基本类似的，只是去掉了 new 关键字而已。 继承与构造函数 Student 类去继承 Person 类，这样 Student 就自动拥有了 Person 中的字段和函数，另外还可以定义自己独有的字段和函数。 创建一个 Student 类，并为其加入字段，如下： class Student { var sno = &quot;&quot; //学号 var grade = 0 //年级 } 现在两个类之间是没有任何继承关系的，想要让 Student 类继承 Person 类，需要做两件事： 使 Person 类可以被继承。在 Kotlin 中任何一个非抽象类默认都是不可以被继承的，相当于 Java 中给类声明了 final 关键字。 抽象类本身是无法创建实例的，一定要由子类去继承它才能创建实例。 可以给类加上open关键字，就是在主动告诉 Kotlin 编译器，这个类是专门为继承而设计的，如下： open class Person { ... } 要让 Student 类继承 Person 类。在 Java 中继承的关键字是extends，而在 Kotlin中变成了一个冒号，写法如下： class Student : Person() { var sno = &quot;&quot; var grade = 0 } Person 类的后面要加上一对括号是因为涉及了主构造函数、次构造函数等方面的知识。 Kotlin 将构造函数分成了两种：主构造函数和次构造函数。 主构造函数将会是你最常用的构造函数，每个类默认都会有一个不带参数的主构造函数，当然也可以显式地给它指明参数。主构造函数的特点是没有函数体，直接定义在类名的后面即可。比如下面这种写法： class Student(val sno: String, val grade: Int) : Person() { } 这里将学号和年级这两个字段都放到了主构造函数当中，这就表明在对 Student 类进行实例化的时候，必须传入构造函数中要求的所有参数。比如： val student = Student(&quot;a123&quot;, 5) 由于构造函数中的参数是在创建实例的时候传入的，不像之前的写法那样还得重新赋值，因此可以将参数全部声明成 val。 主构造函数没有函数体，但可以通过init结构体在主构造函数中编写一些逻辑，如下： class Student(val sno: String, val grade: Int) : Person() { init { println(&quot;sno is &quot; + sno) println(&quot;grade is &quot; + grade) } } 在 Kotlin 中，子类中的构造函数必须调用父类中的构造函数。可是主构造函数并没有函数体，怎样去调用父类的构造函数呢？ Kotlin 采用的设计方式是：子类的主构造函数调用父类中的哪个构造函数，在继承的时候通过括号来指定。因此，对于之前的那段代码，如下： class Student(val sno: String, val grade: Int) : Person() { } 在这里，Person 类后面的一对空括号表示 Student 类的主构造函数在初始化的时候会调用 Person 类的无参数构造函数，即使在无参数的情况下，这对括号也不能省略。 如果将 Person 改造一下，将 name 和 age 字段都放到主构造函数当中，如下所示： open class Person(val name: String, val age: Int) { ... } 此时 Student 类一定会报错，因为 Person 类后面的空括号表示要去调用 Person 类中无参的构造函数，但是 Person 类现在已经没有无参的构造函数了。 为了解决这个问题，可以在 Student 类的主构造函数中加上 name 和 age 这两个参数，再将这两个参数传给 Person 类的构造函数，代码如下所示： class Student(val sno: String, val grade: Int, name: String, age: Int): Person(name, age) { ... } 注意，在 Student 类的主构造函数中增加 name 和 age 这两个字段时，不能再将它们声明成val，因为在主构造函数中声明成 val 或者 var 的参数将自动成为该类的字段，这就会导致和父类中同名的 name 和 age 字段造成冲突。 现在就可以通过如下代码来创建一个 Student 类的实例： val student = Student(&quot;a123&quot;, 5, &quot;Jack&quot;, 19) 下面来说次构造函数，其实我们几乎是用不到次构造函数的，Kotlin 提供了一个给函数设定参数默认值的功能，基本上可以替代次构造函数的作用。 任何一个类只能有一个主构造函数，但是可以有多个次构造函数。次构造函数也可以用于实例化一个类，这一点和主构造函数没有什么不同，只不过它是有函数体的。 Kotlin 规定，当一个类既有主构造函数又有次构造函数时，所有的次构造函数都必须调用主构造函数（包括间接调用），示例代码如下： class Student(val sno: String, val grade: Int, name: String, age: Int) : Person(name, age) { constructor(name: String, age: Int) : this(&quot;&quot;, 0, name, age) { } constructor() : this(&quot;&quot;, 0) { } } 次构造函数是通过constructor关键字来定义的，这里我们定义了两个次构造函数： 第一个次构造函数接收 name 和 age 参数，然后它又通过this关键字调用了主构造函数，并将 sno 和 grade 这两个参数赋值成初始值。 第二个次构造函数不接收任何参数，它通过this关键字调用了我们刚才定义的第一个次构造函数，并将 name 和 age 参数也赋值成初始值，由于第二个次构造函数间接调用了主构造函数，因此这仍然是合法的。 这样就有 3 种方式来对 Student 类进行实体化，分别是： 通过不带参数的构造函数。 通过带两个参数的构造函数。 通过带 4 个参数的构造函数。 对应代码如下所示： val student1 = Student() val student2 = Student(&quot;Jack&quot;, 19) val student3 = Student(&quot;a123&quot;, 5, &quot;Jack&quot;, 19) 有一种非常特殊的情况：类中只有次构造函数，没有主构造函数。 这种情况真的十分少见，但在 Kotlin 中是允许的。当一个类没有显式地定义主构造函数且定义了次构造函数时，它就是没有主构造函数的。示例代码如下： class Student : Person { constructor(name: String, age: Int) : super(name, age) { } } 这里 Student 类的后面没有显式地定义主构造函数且定义了次构造函数，因此它是没有主构造函数的，所以继承 Person 类的时候也就不需要再加上括号了。 由于没有主构造函数，次构造函数只能直接调用父类的构造函数，上述代码也是将 this关键字换成了super关键字。 接口 接口是用于实现多态编程的重要组成部分，可以在接口中定义一系列的抽象行为，然后由具体的类去实现。 创建一个 Study 接口，并在其中添加几个学习相关的函数，注意接口中的函数不要求有函数体，代码如下所示： interface Study { fun readBooks() fun doHomework() } 接下来就可以让 Student 类去实现 Study 接口，代码如下： class Student(name: String, age: Int) : Person(name, age), Study { override fun readBooks() { println(name + &quot; is reading.&quot;) } override fun doHomework() { println(name + &quot; is doing homework.&quot;) } } Kotlin 中使用 override 关键字来重写父类或者实现接口中的函数。 Java 中继承使用的关键字是 extends，实现接口使用的关键字是 implements，而 Kotlin 中统一使用冒号，中间用逗号进行分隔。上述代码就表示 Student 类继承了 Person 类，同时还实现了 Study 接口。 Kotlin 还增加了一个额外的功能：允许对接口中定义的函数进行默认实现，修改 Study 接口中的代码，如下所示： interface Study { fun readBooks() fun doHomework() { println(&quot;do homework default implementation.&quot;) } } 如果接口中的一个函数拥有了函数体，这个函数体中的内容就是它的默认实现。现在当一个类去实现 Study 接口时，只会强制要求实现readBooks()函数，而doHomework()函数则可以自由选择实现或者不实现，不实现时就会自动使用默认的实现逻辑。 数据类与单例类 在一个规范的系统架构中，数据类通常占据着非常重要的角色，它们用于将服务器端或数据库中的数据映射到内存中，为编程逻辑提供数据模型的支持。 数据类通常需要重写equals()、hashCode()、toString()这几个方法。其中： equals()：用于判断两个数据类是否相等。 hashCode()：作为 equals() 的配套方法，也需要一起重写，否则会导致 HashMap、HashSet 等 hash 相关的系统类无法正常工作。 toString()：用于提供更清晰的输入日志，否则一个数据类默认打印出来的就是一行内存地址。 这里新构建一个手机数据类，只有品牌和价格这两个字段，若使用 Java 来实现是比较复杂的，关键是这些代码还是一些没有实际逻辑意义的代码，只是为了让它拥有数据类的功能而已。 而同样的功能使用 Kotlin 来实现就会变得极其简单，新建一个 Cellphone 类，并编写如下代码： data class Cellphone(val brand: String, val price: Double) 神奇的地方就在于data这个关键字，当在一个类前面声明了 data 关键字时，就表明你希望这个类是一个数据类，Kotlin 会根据主构造函数中的参数帮你将 equals()、hashCode()、toString() 等固定且无实际逻辑意义的方法自动生成，从而大大减少了开发的工作量。 单例模式是最常用、最基础的设计模式之一，它可以用于避免创建重复的对象。比如我们希望某个类在全局最多只能拥有一个实例，这时就可以使用单例模式。 在 Kotlin 中创建一个单例类的方式极其简单，在创建类的时候，创建类型选择Object即可，生成的代码如下： object Singleton { } 现在Singleton就已经是一个单例类了，可以直接在这个类中编写需要的函数，示例如下： object Singleton { fun singletonTest() { println(&quot;singletonTest is called.&quot;) } } 而调用单例类中的函数也很简单，如下： Singleton.singletonTest() 这种写法看上去像是静态方法的调用，但其实 Kotlin 在背后自动帮我们创建了一个Singleton类的实例，并且保证全局只会存在一个 Singleton 实例。 Lambda 编程 集合的创建与遍历 传统意义上的集合主要就是 List 和 Set，再广泛一点的话，像 Map 这样的键值对数据结构也可以包含进来。 List 现在创建一个包含许多水果名称的集合。若使用 Java 实现，首先会创建一个 ArrayList 的实例，然后将水果的名称一个个添加到集合中。当然，在 Kotlin 中也可以这么做： val list = ArrayList&lt;String&gt;() list.add(&quot;Apple&quot;) list.add(&quot;Banana&quot;) list.add(&quot;Orange&quot;) list.add(&quot;Pear&quot;) list.add(&quot;Grape&quot;) 但是这种初始化集合的方式比较烦琐，为此 Kotlin 专门提供了一个内置的listOf()函数来简化初始化集合的写法，如下所示： val list = listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;) for-in循环不仅可以用来遍历区间，还可以用来遍历集合，如下： fun main() { val list = listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;) for (fruit in list) { println(fruit) } } 需要注意的是，listOf()函数创建的是一个不可变的 List 集合。 不可变的集合指的就是该集合只能用于读取，无法对集合进行添加、修改或删除操作。 可以使用mutableListOf()函数创建一个可变的 List 集合。 Set Set 集合的用法几乎与 List 一模一样。 创建 Set 集合的方式：setOf()和mutableSetOf()函数。 注意，Set 集合中不可以存放重复元素，若存放了多个相同的元素，只会保留其中一份。 Map Map 是一种键值对形式的数据结构，因此在用法上和 List、Set 集合有较大的不同。传统的 Map 用法是先创建一个 HashMap 的实例，然后将一个个键值对数据添加到 Map 中。比如这里给每种水果设置一个对应的编号，如下： val map = HashMap&lt;String, Int&gt;() map.put(&quot;Apple&quot;, 1) map.put(&quot;Banana&quot;, 2) map.put(&quot;Orange&quot;, 3) map.put(&quot;Pear&quot;, 4) map.put(&quot;Grape&quot;, 5) 这种写法和 Java 比较相似，但在 Kotlin 中并不建议使用put()和get()方法来对 Map 进行添加和读取数据操作，而是更加推荐使用一种类似于数组下标的语法结构，如下： val map = HashMap&lt;String, Int&gt;() map[&quot;Apple&quot;] = 1 map[&quot;Banana&quot;] = 2 map[&quot;Orange&quot;] = 3 map[&quot;Pear&quot;] = 4 map[&quot;Grape&quot;] = 5 Kotlin 毫无疑问地提供了一对mapOf()和mutableMapOf()函数来继续简化 Map 的用法。我们可以直接传入初始化的键值对组合来完成对 Map 集合的创建，如下： val map = mapOf(&quot;Apple&quot; to 1, &quot;Banana&quot; to 2, &quot;Orange&quot; to 3, &quot;Pear&quot; to 4, &quot;Grape&quot; to 5) to并不是关键字，而是一个infix函数。 使用for-in循环遍历 Map 集合中的数据，如下： fun main() { ... for ((fruit, number) in map) { println(&quot;fruit is &quot; + fruit + &quot;, number is &quot; + number) } } 这里将 Map 的键值对变量一起声明到了一对括号里面，这样当进行循环遍历时，每次遍历的结果就会赋值给这两个键值对变量。 集合的函数式 API Lambda 就是一小段可以作为参数传递的代码，但是通常不建议在 Lambda 表达式中编写太长的代码，否则可能会影响代码的可读性。 Lambda 表达式的语法结构： {参数名1: 参数类型, 参数名2: 参数类型 -&gt; 函数体} 最外层是一对大括号，如果有参数传入到 Lambda 表达式中的话，我们还需要声明参数列表，参数列表的结尾使用一个-&gt;符号，表示参数列表的结束以及函数体的开始，函数体中可以编写任意行代码，并且最后一行代码会自动作为 Lambda 表达式的返回值。 在一个水果集合里面找到单词最长的那个水果，如下所示： val list = listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;, &quot;Watermelon&quot;) val lambda = { fruit: String -&gt; fruit.length } val maxLengthFruit = list.maxBy(lambda) maxBy就是一个普通的函数，只不过它接收的是一个 Lambda 类型的参数，并且会在遍历集合时将每次遍历的值作为参数传递给 Lambda 表达式。 maxBy 函数的工作原理是根据传入的条件来遍历集合，从而找到该条件下的最大值。 上面的代码需要简化的地方很多，首先，我们不需要专门定义一个 lambda 变量，而是可以直接将 lambda 表达式传入 maxBy 函数当中，因此第一步简化如下所示： val maxLengthFruit = list.maxBy({ fruit: String -&gt; fruit.length }) 然后 Kotlin 规定，当 Lambda 参数是函数的最后一个参数时，可以将 Lambda 表达式移到函数括号的外面，如下所示： val maxLengthFruit = list.maxBy() { fruit: String -&gt; fruit.length } 接下来，如果 Lambda 参数是函数的唯一一个参数的话，还可以将函数的括号省略： val maxLengthFruit = list.maxBy { fruit: String -&gt; fruit.length } 由于 Kotlin 拥有出色的类型推导机制，Lambda 表达式中的参数列表其实在大多数情况下不必声明参数类型，因此代码可以进一步简化成： val maxLengthFruit = list.maxBy { fruit -&gt; fruit.length } 最后，当 Lambda 表达式的参数列表中只有一个参数时，也不必声明参数名，而是可以使用 it 关键字来代替，那么代码就变成了： val maxLengthFruit = list.maxBy { it.length } 集合中的 map 函数是最常用的一种函数式 API，它用于将集合中的每个元素都映射成一个另外的值，映射的规则在 Lambda 表达式中指定，最终生成一个新的集合。比如，这里希望让所有的水果名都变成大写模式，就可以这样写： fun main() { val list = listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;, &quot;Watermelon&quot;) val newList = list.map { it.toUpperCase() } for (fruit in newList) { println(fruit) } } map 函数的功能非常强大，它可以按照需求对集合中的元素进行任意的映射转换。 filter函数是用来过滤集合中的数据的，它可以单独使用，也可以配合刚才的 map 函数一起使用。比如保留 5 个字母以内的水果，就可以借助 filter 函数来实现，代码如下所示： fun main() { val list = listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;, &quot;Watermelon&quot;) val newList = list.filter { it.length &lt;= 5 }.map { it.toUpperCase() } for (fruit in newList) { println(fruit) } } 先进行过滤操作，再对过滤后的元素进行映射转换，效率会更高。 any函数用于判断集合中是否至少存在一个元素满足指定条件。all函数用于判断集合中是否所有元素都满足指定条件。示例代码如下： fun main() { val list = listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;, &quot;Watermelon&quot;) val anyResult = list.any { it.length &lt;= 5 } val allResult = list.all { it.length &lt;= 5 } println(&quot;anyResult is &quot; + anyResult + &quot;, allResult is &quot; + allResult) } Java 函数式 API 的使用 上面学习的都是 Kotlin 中函数式 API 的用法，但实际上在 Kotlin 中调用 Java 方法时也可以使用函数式 API，只不过这是有一定条件限制的。 具体来讲，如果我们在 Kotlin 代码中调用了一个 Java 方法，并且该方法接收一个 Java 单抽象方法接口参数，就可以使用函数式 API。 Java 单抽象方法接口指的是接口中只有一个待实现方法，如果接口中有多个待实现方法，则无法使用函数式 API。 Java 原生 API 中有一个最为常见的单抽象方法接口——Runnable接口。这个接口中只有一个待实现的run()方法，定义如下： public interface Runnable { void run(); } 对于任何一个 Java 方法，只要它接收Runnable参数，就可以使用函数式 API。不过 Runnable 接口主要还是结合线程来一起使用的，可以使用如下 Java 代码创建并执行一个子线程： new Thread(new Runnable() { @Override public void run() { System.out.println(&quot;Thread is running&quot;); } }).start(); 若直接使用 Kotlin 来实现，写法如下所示： Thread(object : Runnable { override fun run() { println(&quot;Thread is running&quot;) } }).start() 由于 Kotlin 完全舍弃了 new 关键字，因此创建匿名类实例时使用object关键字。注意，目前 Thread 类的构造方法是符合 Java 函数式 API 的使用条件的，因此可以对代码进行精简，如下所示： Thread(Runnable { println(&quot;Thread is running&quot;) }).start() 即使这里没有显式地重写 run() 方法，Kotlin 也能自动明白 Runnable 后面的 Lambda 表达式就是要在 run() 方法中实现的内容。 另外，如果一个 Java 方法的参数列表中有且仅有一个 Java 单抽象方法接口参数，我们还可以将接口名进行省略，如下： Thread({ println(&quot;Thread is running&quot;) }).start() 而且，当 Lambda 表达式是方法的最后一个参数时，可以将 Lambda 表达式移到方法括号的外面。同时，如果 Lambda 表达式还是方法的唯一一个参数，还可以将方法的括号省略，最终简化结果如下： Thread { println(&quot;Thread is running&quot;) }.start() 由于 Android SDK 还是使用 Java 语言编写的，因此当我们在 Kotlin 中调用这些 SDK 接口时，就很可能会用到这种 Java 函数式 API 的写法。 比如 Android 中有一个极为常用的点击事件接口OnClickListener，定义如下： public interface OnClickListener { void onClick(View v); } 这显然是一个单抽象方法接口。这里使用 Kotlin 代码来给按钮注册点击事件，就可以使用函数式 API 的写法来对代码进行简化，如下： button.setOnClickListener { } 空指针检查 空指针是一种不受编程语言检查的运行时异常，只能由程序员主动通过逻辑判断来避免。 可空类型系统 Kotlin 将空指针异常的检查提前到了编译时期，如果我们的程序存在空指针异常的风险，那么在编译的时候会直接报错，修正之后才能成功运行，这样就可以保证程序在运行时期不会出现空指针异常。 Kotlin 默认所有的参数和变量都不可为空。 Kotlin 也提供了另外一套可为空的类型系统，只不过在使用可为空的类型系统时，我们需要在编译时期就将所有潜在的空指针异常都处理掉，否则代码将无法编译通过。 可为空的类型系统就是在类名的后面加上一个问号，比如，Int表示不可为空的整型，而Int?就表示可为空的整型。如果我们希望传入的参数可以为空，那么就应该将参数的类型改为可为空。 判空辅助工具 但是为了在编译时期就处理掉所有的空指针异常，通常需要编写很多额外的检查代码才行。如果每处检查代码都使用 if 判断语句，则会让代码变得比较啰嗦，而且 if 判断语句还处理不了全局变量的判空问题。为此，Kotlin 专门提供了一系列的辅助工具，使开发者能够更轻松地进行判空处理。 首先是最常用的?.操作符。这个操作符的作用就是当对象不为空时正常调用相应的方法，当对象为空时则什么都不做。比如以下的判空处理代码： if (a != null) { a.doSomething() } 使用?.就可以简化成： a?.doSomething() ?:操作符也是比较常用的。这个操作符的左右两边都接收一个表达式，如果左边表达式的结果不为空就返回左边表达式的结果，否则就返回右边表达式的结果。比如以下代码： val c = if (a ! = null) { a } else { b } 使用?:操作符就可以简化成： val c = a ?: b 不过 Kotlin 的空指针检查机制也并非总是那么智能，有的时候我们可能从逻辑上已经将空指针异常处理了，但是 Kotlin 的编译器并不知道，这个时候它还是会编译失败。示例代码如下： var content: String? = &quot;hello&quot; fun main() { if (content != null) { printUpperCase() } fun printUpperCase() { val upperCase = content.toUpperCase() println(upperCase) } } 这里我们定义了一个可为空的全局变量 content，然后在 main() 函数里先进行一次判空操作，当 content 不为空的时候才会调用printUpperCase()函数。 看上去好像逻辑没什么问题，但是这段代码一定是无法运行的。因为printUpperCase()函数并不知道外部已经对 content 变量进行了非空检查，在调用toUpperCase()方法时，还认为这里存在空指针风险，从而无法编译通过。 在这种情况下，如果我们想要强行通过编译，可以使用非空断言工具，写法是在对象的后面加上!!，如下所示： fun printUpperCase() { val upperCase = content!!.toUpperCase() println(upperCase) } 这是一种有风险的写法，意在告诉 Kotlin，我非常确信这里的对象不会为空，所以不用你来帮我做空指针检查。 因此更好的实现方法是使用一个比较与众不同的辅助工具——let。let既不是操作符，也不是什么关键字，而是一个函数。它提供了函数式 API 的编程接口，并将原始调用对象作为参数传递到 Lambda 表达式中。示例代码如下： obj.let { obj2 -&gt; // 编写具体的业务逻辑 } 可以看到，这里调用了 obj 对象的let函数，然后 Lambda 表达式中的代码就会立即执行，并且这个 obj 对象本身还会作为参数传递到 Lambda 表达式中。不过为了防止变量重名，这里将参数名改成 obj2，但实际上它们是同一个对象，这就是 let 函数的作用。 let函数的特性配合?.操作符可以在空指针检查的时候起到很大的作用。 fun doStudy(study: Study?) { study?.let { stu -&gt; stu.readBooks() stu.doHomework() } } let 函数会将 study 对象本身作为参数传递到 Lambda 表达式中，由于使用了?.操作符，此时的 study 对象肯定不为空了，我们就能放心地调用它的任意方法。 最后，当 Lambda 表达式的参数列表中只有一个参数时，可以不用声明参数名，直接使用it关键字来代替即可，那么代码就可以进一步简化成： fun doStudy(study: Study?) { study?.let { it.readBooks() it.doHomework() } } let 函数是可以处理全局变量的判空问题的。 字符串内嵌表达式 Kotlin 从一开始就支持了字符串内嵌表达式的功能，弥补了 Java 在这一点上的遗憾。在 Kotlin 中，我们不需要再像使用 Java 时那样傻傻地拼接字符串了，而是可以直接将表达式写在字符串里面，即使是构建非常复杂的字符串，也会变得轻而易举。 Kotlin 中字符串内嵌表达式的语法规则： &quot;hello, ${obj.name}. nice to meet you!&quot; 可以看到，Kotlin 允许我们在字符串里嵌入${}这种语法结构的表达式，并在运行时使用表达式执行的结果替代这一部分内容。 另外，当表达式中仅有一个变量的时候，还可以将两边的大括号省略，如下所示： &quot;hello, $name. nice to meet you!&quot; 函数的参数默认值 之前已经提到过，Kotlin 提供了给函数设定参数默认值的功能，它在很大程度上能够替代次构造函数的作用。 具体来讲，我们可以在定义函数的时候给任意参数设定一个默认值，这样当调用此函数时就不会强制要求调用方为此参数传值，在没有传值的情况下会自动使用参数的默认值。 给参数设定默认值的方式也很简单，如下所示： fun printParams(num: Int, str: String = &quot;hello&quot;) { println(&quot;num is $num , str is $str&quot;) } Kotlin 提供了一种机制，就是可以通过键值对的方式来传参，从而不必像传统写法那样按照参数定义的顺序来传参。比如调用 printParams() 函数，可以这样写： printParams(str = &quot;world&quot;, num = 123) 此时哪个参数在前哪个参数在后都无所谓，Kotlin 可以准确地将参数匹配上。 回顾一下当初我们学习次构造函数时所编写的代码： class Student(val sno: String, val grade: Int, name: String, age: Int) : Person(name, age) { constructor(name: String, age: Int) : this(&quot;&quot;, 0, name, age) { } constructor() : this(&quot;&quot;, 0) { } } 次构造函数在这里的作用是提供了使用更少参数来对 Student 类进行实例化的方式。 无参的次构造函数会调用两个参数的次构造函数，并将这两个参数赋值成初始值。两个参数的次构造函数会调用 4 个参数的主构造函数，并将缺失的两个参数也赋值成初始值。 这种写法在 Kotlin 中其实是不必要的，因为完全可以通过只编写一个主构造函数，然后给参数设定默认值的方式来实现，代码如下所示： class Student(val sno: String = &quot;&quot;, val grade: Int = 0, name: String = &quot;&quot;, age: Int = 0) : Person(name, age) { } 在给主构造函数的每个参数都设定了默认值之后，我们就可以使用任何传参组合的方式来对 Student 类进行实例化，当然也包含了刚才两种次构造函数的使用场景。 ","link":"https://Petrichoroo.github.io/post/kotlin-xue-xi-bi-ji/"},{"title":"《第一行代码 Android》笔记 — 探究 Service","content":" Service Service 是什么 Android 多线程编程 线程的基本用法 在子线程中更新UI 解析异步消息处理机制 使用AsyncTask Service 的基本用法 定义一个 Service 启动和停止 Service Activity 和 Service 进行通信 Service 的生命周期 Service 的更多技巧 使用前台 Service 使用 IntentService Service Service 是什么 Service 是 Android 中实现程序后台运行的解决方案，它非常适合执行那些不需要和用户交互而且还要求长期运行的任务。Service 的运行不依赖于任何用户界面，即使程序被切换到后台，或者用户打开了另外一个应用程序，Service 仍然能够保持正常运行。 不过需要注意的是，Service 并不是运行在一个独立的进程当中的，而是依赖于创建 Service 时所在的应用程序进程。当某个应用程序进程被杀掉时，所有依赖于该进程的 Service 也会停止运行。 另外，也不要被 Service 的后台概念所迷惑，实际上 Service 并不会自动开启线程，所有的代码都是默认运行在主线程当中的。也就是说，我们需要在 Service 的内部手动创建子线程，并在这里执行具体的任务，否则就有可能出现主线程被阻塞的情况。 Android 多线程编程 线程的基本用法 定义一个线程只需要新建一个类继承自Thread，然后重写父类的run()方法，并在里面编写耗时逻辑即可，如下所示： class MyThread extends Thread { @Override public void run() { //处理具体的逻辑 } } 启动线程： new MyThread().start(); 当然，使用继承的方式耦合性有点高，更多的时候我们都会选择使用实现Runnable接口的方式来定义一个线程，如下所示： class MyThread implements Runnable { @Override public void run() { //处理具体逻辑 } } 启动线程： MyThread myThread = new MyThread(); new Thread(myThread).start(); 当然，如果你不想专门再定义一个类去实现 Runnable 接口，也可以使用匿名类的方式，这种写法更为常见，如下所示： new Thread(new Runnable() { @Override public void run() { //处理具体的逻辑 } }).start(); 在子线程中更新UI 和许多其他的 GUI 库一样，Android 的 UI 也是线程不安全的。也就是说，如果想要更新应用程序里的 UI 元素，则必须在主线程中进行，否则就会出现异常。 Android 提供了一套异步消息处理机制，完美地解决了在子线程中进行 UI 操作的问题。修改 MainActivity 中的代码，如下所示： public class MainActivity extends AppCompatActivity implements View.OnClickListener { private static final int UPDATE_TEXT = 1; //表示更新TextView这个动作 private TextView textView; //Handler用于发送和处理消息 通过sendMessage()方法发出的消息最终传递到handleMessage()中进行处理 private Handler handler = new Handler(Looper.getMainLooper()) { @Override public void handleMessage(@NonNull Message msg) { super.handleMessage(msg); switch (msg.what) { case UPDATE_TEXT: textView.setText(&quot;Nice to meet you&quot;); //更新UI break; default: break; } } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); textView = findViewById(R.id.texts); Button changeText = findViewById(R.id.change_text); changeText.setOnClickListener(this); } @Override public void onClick(View view) { switch (view.getId()) { case R.id.change_text: new Thread(new Runnable() { //开启一个新的子线程处理复杂逻辑有利于提高效率 @Override public void run() { //Android不支持子线程更新UI操作 但是可以通过发送message给Handler进行处理。 Message message = new Message(); message.what = UPDATE_TEXT; //指定动作 handler.sendMessage(message); } }).start(); break; default: break; } } } 布局文件中定义了两个控件：TextView 用于在屏幕的正中央显示内容，Button 用于改变 TextView 中显示的内容。 我们在 Button 的点击事件里开启了一个子线程，并且没有在这里直接进行 UI 操作，而是创建了一个Message对象，并将它的 what 字段的值指定为 updateText，然后调用Handler的sendMessage()方法将这条 Message 发送出去。 Handler 就会收到这条 Message，并在handleMessage()方法中对它进行处理。 注意此时 handleMessage() 方法中的代码就是在主线程当中运行的了，所以我们可以在这里进行 UI 操作。 解析异步消息处理机制 Android 中的异步消息处理主要由 4 部分组成：Message、Handler、MessageQueue和Looper。 Message：在线程之间传递的消息，它可以在内部携带少量的信息，用于在不同线程之间 传递数据。上面中我们使用到了 Message 的what字段，除此之外还可以使用arg1和 arg2字段来携带一些整型数据，使用obj字段携带一个Object对象。 Handler：主要是用于发送和处理消息的。发送消息一般是使用 Handler 的sendMessage()方法、post()方法等，而发出的消息经过一系列地辗转处理后，最终会传递到handleMessage()方法中。 MessageQueue：消息队列。它主要用于存放所有通过 Handler 发送的消息。这部分消息会一直存在于消息队列中，等待被处理。每个线程中只会有一个MessageQueue对象。 Looper：每个线程中的 MessageQueue 的管家，调用Looper的loop()方法后，就会进入一个无限循环当中，然后每当发现 MessageQueue 中存在一条消息时，就会将它取出，并传递到 Handler 的handleMessage()方法中。每个线程中只会有一个 Looper 对象。 异步消息处理的整个流程： 首先需要在主线程中创建一个Handler对象，并重写handleMessage()方法。然后当子线程中需要进行 UI 操作时，就创建一个Message对象，并通过 Handler 将这条消息发送出去。之后这条消息会被添加到MessageQueue的队列中等待被处理，而Looper则会一直尝试从 MessageQueue 中取出待处理消息，最后分发回 Handler 的 handleMessage() 方法中。 由于 Handler 的构造函数中我们传入了Looper.getMainLooper()，所以此时 handleMessage() 方法中的代码也会在主线程中运行，于是我们在这里就可以安心地进行 UI 操作了 整个异步消息处理机制的流程如图： 使用AsyncTask 为了方便在子线程中对 UI 进行操作，Android 还提供了另外一些好用的工具，比如AsyncTask。 AsyncTask 是一个抽象类，所以如果我们想使用它，就必须创建一个子类去继承它。在继承时我们可以为 AsyncTask 类指定 3 个泛型参数，这 3 个参数的用途如下： arams：在执行 AsyncTask 时需要传入的参数，可用于在后台任务中使用。 Progress：在后台任务执行时，如果需要在界面上显示当前的进度，则使用这里指定的泛 型作为进度单位。 Result：当任务执行完毕后，如果需要对结果进行返回，则使用这里指定的泛型作为返回 值类型。 我们还需要去重写 AsyncTask 中的几个方法才能完成对任务的定制。经常需要去重写的方法有以下 4 个： onPreExecute()：在后台任务开始执行之前调用，用于进行一些界面上的初始化操作，比如显示一个进度条对话框等。 doInBackground(Params...)：这个方法中的所有代码都会在子线程中运行，我们应该在这里去处理所有的耗时任务。任务一旦完成就可以通过 return 语句来将任务的执行结果返回，如果 AsyncTask 的第三个泛型参数指定的是 Void，就可以不返回任务执行结果。 注意，在这个方法中是不可以进行 UI 操作的，如果需要更新 UI 元素，比如说反馈当前任务的执行进度，可以调用publishProgress (Progress...)方法来完成。 onProgressUpdate(Progress...)：当在后台任务中调用了publishProgres(Progress...)方法后，onProgressUpdate (Progress...) 方法就会很快被调用，该方法中携带的参数就是在后台任务中传递过来的。这个方法中可以对 UI 进行操作，利用参数中的数值就可以对界面元素进行相应的更新。 onPostExecute(Result)：当后台任务执行完毕并通过 return 语句进行返回时，这个方法就很快会被调用。返回的数据会作为参数传递到此方法中，可以利用返回的数据来进行一些 UI 操作，比如说提醒任务执行的结果，以及关闭掉进度条对话框等。 AsyncTask 由于 context 泄露，回调遗漏，configuration 变化导致崩溃，平台差异性等原因，在API 30（Android 11) 中正式被废弃。 Service 的基本用法 定义一个 Service 在项目中定义一个Service，右击 com.example.包名→New→Service→Service，将类名定义成 MyService，Exported属性表示是否将这个 Service 暴露给外部其他程序访问，Enabled属性表示是否启用这个 Service。 创建完成之后，观察 MyService 中的代码，如下所示： public class MyService extends Service { public MyService() { } @Override public IBinder onBind(Intent intent) { // TODO: Return the communication channel to the service. throw new UnsupportedOperationException(&quot;Not yet implemented&quot;); } } onBind()方法是 Service 中唯一的一个抽象方法，所以必须要在子类里实现。既然是定义一个服务，自然应该在服务中去处理一些事情，重写 Service 中的另外一些方法，如下所示： public class MyService extends Service { public MyService() { } @Override public IBinder onBind(Intent intent) { // TODO: Return the communication channel to the service. throw new UnsupportedOperationException(&quot;Not yet implemented&quot;); } @Override public void onCreate() { super.onCreate(); } @Override public int onStartCommand(Intent intent, int flags, int startId) { return super.onStartCommand(intent, flags, startId); } @Override public void onDestroy() { super.onDestroy(); } } 这里重写了服务中最常用到的 3 个方法： onCreate()：在服务创建的时候调用。 onStartCommand()：在每次服务启动的时候调用。 onDestroy()：在服务销毁的时候调用。 通常情况下，如果希望服务一旦启动就立刻去执行某个动作，就可以将逻辑写在onStartCommand()方法里。而当服务销毁时，又应该在onDestroy()方法中去回收那些不再使用的资源。 另外需要注意，每一个服务都需要在 AndroidManifest.xml 文件中进行注册才能生效，这是Android 四大组件共有的特点。 启动和停止 Service 在布局文件中加入两个按钮，分别是用于启动服务和停止服务的。然后修改 MainActivity 中的代码，如下所示： ... @Override public void onClick(View view) { switch (view.getId()) { case R.id.start_service: Intent startIntent = new Intent(this,MyService.class); startService(startIntent);//启动服务 break; case R.id.stop_service: Intent stopIntent = new Intent(this,MyService.class); stopService(stopIntent); break; default: break; } } startService()和stopService()方法都是定义在 Context 类中的，所以在活动里可以直接调用这两个方法。 注意，这里完全是由活动来决定服务何时停止的，如果没有点击 Stop Service 按钮，服务就会一直处于运行状态。如果想要停止服务，只需要在 MyService 的任何一个位置调用stopSelf()方法即可。 从 Android 8.0 系统开始，应用的后台功能被大幅削减。现在只有当应用保持在前台可见状态的情况下，Service 才能保证稳定运行，一旦应用进入后台之后，Service 随时都有可能被系统回收。 之所以做这样的改动，是为了防止许多恶意的应用程序长期在后台占用手机资源，从而导致手机变得越来越卡。如果需要长期在后台执行一些任务，可以使用前台 Service 或者 WorkManager。 需要注意的是，onCreate()方法是在 Service 第一次创建的时候调用的，而onStartCommand()方法则在每次启动 Service 的时候都会调用。 Activity 和 Service 进行通信 虽然 Service 是在 Activity 里启动的，但是在启动了 Service 之后，Activity 与 Service 基本就没有什么关系了。我们通过onbind()方法来让 Activity 和 Service 的关系更紧密一些。 在 MyService 里提供一个下载功能，然后在 Activity 中可以决定何时开始下载，以及随时查看下载进度。实现此功能的思路是创建一个专门的Binder对象来对下载功能进行管理。修改 MyService 中的代码，如下所示： public class MyService extends Service { private DownloadBinder mBinder = new DownloadBinder(); class DownloadBinder extends Binder { public void startDownload() { Log.d(&quot;MyService&quot;,&quot;startDownload executed&quot;); } public int getProgress() { Log.d(&quot;MyService&quot;,&quot;getProgress executed&quot;); return 0; } } @Override public IBinder onBind(Intent intent) { return mBinder; } ... } 这里新建了一个DownloadBinder类，并让它继承自Binder，然后在它的内部提供了开始下载以及查看下载进度的方法。当然这只是两个模拟方法，并没有实现真正的功能。然后在onBind()方法里返回了 DownloadBinder 的实例。 在布局文件中添加两个按钮，分别用于绑定和取消绑定 Service，当一个 Activity 和 Service 绑定了之后，就可以调用该 Service 里的 Binder 提供的方法了。修改 MainActivity 中的代码，如下所示： public class MainActivity extends AppCompatActivity implements View.OnClickListener { private MyService.DownloadBinder downloadBinder; private ServiceConnection connection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName componentName, IBinder iBinder) { downloadBinder = (MyService.DownloadBinder) iBinder; downloadBinder.startDownload(); downloadBinder.getProgress(); } @Override public void onServiceDisconnected(ComponentName componentName) { } }; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ... Button bindService = findViewById(R.id.bind_service); Button unbindService = findViewById(R.id.unbind_service); bindService.setOnClickListener(this); unbindService.setOnClickListener(this); } @Override public void onClick(View view) { switch (view.getId()) { ... case R.id.bind_service: Intent bindIntent = new Intent(this,MyService.class); bindService(bindIntent,connection,BIND_AUTO_CREATE); //绑定服务 /* 整个调用过程 多次回调 MainActivity.bindService()-&gt;MyService.onCreate()-&gt;MyService.onBind()-&gt; MainActivity.ServiceConnection.onServiceConnection()...-&gt;onDestroy() */ break; case R.id.unbind_service: unbindService(connection); //解绑服务 break; default: break; } } } 这里首先创建了一个ServiceConnection的匿名类，在里面重写了onServiceConnected()方法和onServiceDisconnected()方法，这两个方法分别会在活动与服务成功绑定以及活动与服务的连接断开的时候调用。在 onServiceConnected() 方法中，又通过向下转型得到了DownloadBinder的实例，有了这个实例，活动和服务之间的关系就变得非常紧密。 在 Bind Service 按钮的点击事件里，先构建出了一个 Intent 对象，然后调用bindService()方法将 MainActivity 和 MyService 进行绑定。bindService() 方法接收 3 个参数： 第一个参数是 Intent 对象。 第二个参数是ServiceConnection的实例。 第三个参数则是一个标志位。 这里传入BIND_AUTO_CREATE表示在活动和服务进行绑定后自动创建服务。这会使得MyService 中的onCreate()方法得到执行，但onStartCommand()方法不会执行。 需要注意，任何一个服务在整个应用程序范围内都是通用的，即 MyService 不仅可以和 MainActivity 绑定，还可以和任何一个其他的活动进行绑定，而且在绑定完成后都可以获取到相同的 DownloadBinder 实例。 Service 的生命周期 Service 也有自己的生命周期，前面我们使用到的onCreate()、onStartCommand()、onBind()和onDestroy()等方法都是在 Service 的生命周期内可能回调的方法。 一旦在项目的任何位置调用了 Context 的startService()方法，相应的 Service 就会启动，并回调onStartCommand()方法。 如果这个 Service 之前还没有创建过，onCreate()方法会先于 onStartCommand() 方法执行。Service 启动了之后会一直保持运行状态，直到stopService()或stopSelf()方法被调用，或者被系统回收。 注意，虽然每调用一次 startService() 方法，onStartCommand() 就会执行一次，但实际上每个 Service 只会存在一个实例。所以不管你调用了多少次 startService() 方法，只需调用一次 stopService() 或 stopSelf() 方法，Service 就会停止。 另外，还可以调用 Context 的bindService()来获取一个 Service 的持久连接，这时就会回调 Service 中的onBind()方法。类似地，如果这个 Service 之前还没有创建过，onCreate() 方法会先于 onBind() 方法执行。 之后，调用方可以获取到 onBind() 方法里返回的IBinder对象的实例，这样就能自由地和 Service 进行通信了。只要调用方和 Service 之间的连接没有断开，Service 就会一直保持运行状态，直到被系统回收。 调用了startService()方法后，再去调用stopService()方法。这时 Service 中的onDestroy()方法就会执行，表示 Service 已经销毁了。 类似地，当调用了bindService()方法后，再去调用unbindService()方法，onDestroy()方法也会执行。 需要注意，我们是有可能对一个 Service 既调用了 startService() 方法，又调用了 bindService() 方法的，根据 Android 系统的机制，一个 Service 只要被启动或者被绑定了之后，就会处于运行状态，必须要让以上两种条件同时不满足，Service 才能被销毁。所以，这种情况下要同时调用 stopService() 和 unbindService() 方法，onDestroy() 方法才会执行。 Service 的更多技巧 使用前台 Service 前面说过，只有当应用保持在前台可见状态的情况下，Service 才能保证稳定运行，一旦应用进入后台之后，Service 随时都有可能被系统回收。 而如果你希望 Service 能够一直保持运行状态，就可以考虑使用前台 Service。前台 Service 和普通 Service 最大的区别就在于，它一直会有一个正在运行的图标在系统的状态栏显示，下拉状态栏后可以看到更加详细的信息，非常类似于通知的效果。 有些项目由于特殊的需求会要求必须使用前台服务，比如说天气预报应用，它的服务在后台更新天气数据的同时，还会在系统状态栏一直显示当前的天气信息 修改 MyService 中的代码，如下所示： public class MyService extend Service{ ... @Override public void onCreate(){ super.onCreate(); Intent intent = new Intent(this, MainActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, intent, 0); ... Notification notification = new NotificationCompat.Builder(MainActivity.this,&quot;channelId&quot;) ... .setContentIntent(pendingIntent) .build(); startForeground(1,notification); } } 这次在构建Notification对象后并没有使用NotificationManager将通知显示出来，而是调用了startForeground()方法。这个方法接收两个参数：第一个参数是通知的 id，类似于notify()方法的第一个参数，第二个参数是构建的 Notification 对象。调用 startForeground() 方法后就会让 MyService 变成一个前台 Service，并在系统状态栏显示出来。 另外，从 Android 9.0 系统开始，使用前台 Service 必须在 AndroidManifest.xml 文件中进行权限声明才行，如下所示： &lt;uses-permission android:name=&quot;android.permission.VIBRATE&quot;/&gt; 使用 IntentService 为了可以简单地创建一个异步的、会自动停止的 Service，Android 专门提供了一个IntentService类，新建一个 MyIntentService 类继承自 IntentService，代码如下所示： public class MyIntentService extends IntentService { public MyIntentService() { super(&quot;MyIntentService&quot;); //调用父类的有参构造函数 } @Override protected void onHandleIntent(@Nullable Intent intent) { //打印当前线程的id Log.d(&quot;MyIntentService&quot;,&quot;This id is &quot; + Thread.currentThread().getId()); } @Override public void onDestroy() { super.onDestroy(); Log.d(&quot;MyIntentService&quot;,&quot;onDestroy executed&quot;); } } 这里首先要求必须先调用父类的构造函数，并传入一个字符串，这个字符串可以随意指定，只在调试的时候有用。然后要在子类中实现onHandleIntent()这个抽象方法，这个方法中可以处理一些耗时的逻辑，而不用担心 ANR 的问题，因为这个方法已经是在子线程中运行的了。 为了证实一下，这里在onHandleIntent()方法中打印了当前线程名。另外，根据 IntentService 的特性，这个 Service 在运行结束后应该是会自动停止的，所以我们又重写了onDestroy()方法，在这里也打印了一行日志，以证实 Service 是不是停止了。 最后需要注意的是，Service 都是需要在 AndroidManifest.xml 里注册的，如下所示： &lt;service android:name=&quot;.MyIntentService&quot;/&gt; 当然，也可以使用 Android Studio 提供的快捷方式来创建 IntentService，不过这样会自动生成一些我们用不到的代码。 ","link":"https://Petrichoroo.github.io/post/lesslessdi-yi-xing-dai-ma-androidgreatergreater-bi-ji-tan-jiu-service/"},{"title":"《第一行代码 Android》笔记 — 使用网络技术","content":" Android 中常用的网络技术 WebView 的用法 使用 Http 访问网络 使用 HttpURLConnection 使用 OkHttp 解析 XML 格式数据 Pull 解析方式 SAX 解析方式 解析 JSON 格式数据 使用 JSONObject 使用 GSON 网络请求回调的实现方式 Android 中常用的网络技术 WebView 的用法 Android 提供了一个WebView控件，借助它我们就可以在自己的应用程序里嵌入一个浏览器，从而非常轻松地展示各种各样的网页。 首先需要在布局文件中放置一个 WebView 控件，这个控件就是用来显示网页的，给其设置一个 id，并让它充满整个屏幕，如下所示： &lt;WebView android:id=&quot;@+id/web_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt; 然后修改 MainActivity 中的代码，如下所示： public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); WebView webView = findViewById(R.id.web_view); //getSettings()设置属性 调用setJavaScriptEnabled()方法来让WebView支持Javascript脚本 webView.getSettings().setJavaScriptEnabled(true); //网页跳转时 希望目标仍然在当前WebView中显示 而不是打开浏览器显示 webView.setWebViewClient(new WebViewClient()); webView.loadUrl(&quot;https://www.baidu.com&quot;); } } 另外还需要注意，由于本程序使用到了网络功能，而访问网络是需要声明权限的，因此我们还得修改 AndroidManifest.xml 文件，并加入权限声明，如下所示： &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt; 这里只是简单地使用了 WebView，而 WebView 还有很多更加高级的使用技巧。 使用 Http 访问网络 Http 的工作原理比较简单，就是客户端向服务器发出一条 HTTP 请求，服务器收到请求之后会返回一些数据给客户端，然后客户端再对这些数据进行解析和处理即可。 上面使用到的 WebView 控件，其实就是我们向百度的服务器发起了一条 HTTP 请求，接着服务器分析出我们想要访问的是百度的首页，于是把该网页的 HTML 代码进行返回，然后 WebView 再调用手机浏览器的内核对返回的 HTML 代码进行解析，最终将页面展示出来。 简单来说，WebView 已经在后台帮我们处理好了发送 HTTP 请求、接收服务器响应、解析返回数据，以及最终的页面展示这几步工作。下面我们通过手动发送 HTTP 请求的方式更加深入地理解这个过程。 使用 HttpURLConnection 首先需要获取HttpURLConnection的实例，一般只需创建一个URL对象，并传入目标的网络地址，然后调用一下openConnection()方法即可，如下所示： URL url = new URL(&quot;https://baidu.com&quot;); HttpURLConnection connection = (HttpURLConnection)url.openConnection(); 在得到了HttpURLConnection的实例之后，我们可以设置一下 HTTP 请求所使用的方法。常用的方法主要有两个：GET和POST。GET 表示希望从服务器那里获取数据，而 POST 则表示希望提交数据给服务器。写法如下： connection.setRequestMethod(&quot;GET&quot;); 接下来，就可以进行一些自由的定制了，比如设置连接超时、读取超时的毫秒数等。这部分内容根据自己的实际情况进行编写，示例写法如下： connection.setConnectTimeout(8000); connection.setReadTimeout(8000); 之后再调用getInputStream()方法就可以获取到服务器返回的输入流了，剩下的任务就是对输入流进行读取，如下所示： InputStream in = connection.getInputStream(); 最后，可以调用disconnect()方法将这个 HTTP 连接关闭掉，如下所示： connection.disconnect(); 通过一个具体的例子来体验一下 HttpURLConnection 的用法，首先修改 activity_main.xml 中的代码，如下所示： &lt;Button android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/send_request&quot; android:text=&quot;Send Request&quot;/&gt; &lt;ScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:id=&quot;@+id/response_text&quot;/&gt; &lt;/ScrollView&gt; 由于手机屏幕的空间一般都比较小，有些时候过多的内容一屏是显示不下的，ScrollView 控件可以以滚动的形式查看屏幕外的那部分内容。 Button 用于发送 HTTP 请求，TextView 用于将服务器返回的数据显示出来。修改 MainActivity 中的代码，如下所示： private void sendRequestWithHttpURLConnection() { //开启子线程 new Thread(new Runnable() { @Override public void run() { HttpURLConnection connection = null; BufferedReader reader = null; try { URL url = new URL(&quot;https://www.baidu.com&quot;); connection = (HttpURLConnection) url.openConnection(); connection.setRequestMethod(&quot;GET&quot;); connection.setConnectTimeout(8000); //建立连接所用的时间 适用于网络状况正常的情况下 connection.setReadTimeout(8000); //建立连接后从服务器读取到可用资源所用的时间 InputStream in = connection.getInputStream(); //对获取到的输入流进行读取 reader = new BufferedReader(new InputStreamReader(in)); StringBuilder response = new StringBuilder(); String line; while ((line = reader.readLine()) != null) { response.append(line); } showResponse(response.toString()); //显示服务器返回的数据 } catch (Exception e) { e.printStackTrace(); } finally { if (reader != null) { try { reader.close(); } catch (IOException e) { e.printStackTrace(); } } if (connection != null) { connection.disconnect(); //将HTTP连接关闭掉 } } } }).start(); } //Android不允许在子线程中进行UI操作 需要通过runOnUiThread()方法将线程切换到主线程 private void showResponse(final String response) { runOnUiThread(new Runnable() { @Override public void run() { //在这里进行UI操作 将结果显示到界面上 responseText.setText(response); } }); } 注意声明网络权限。修改 AndroidManifest.xml 中的代码，如下所示： &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; 若是想要提交数据给服务器，只需要将 HTTP 请求的方法改成 POST，并在获取输入流之前把要提交的数据写出即可。注意每条数据都要以键值对的形式存在，数据与数据之间用“&amp;”符号隔开，比如说我们想要向服务器提交用户名和密码，就可以这样写： connection.setRequestMethod(&quot;POST&quot;); DataOutputStream outputStream = new DataOutputStream(connection.getOutputStream()) ; outputStream.writeBytes(&quot;username=admin&amp;&amp;password=123456&quot;); 使用 OkHttp OkHttp 不仅在接口封装上做得简单易用，在底层实现上也是自成一派，现在已经成了广大 Android 开发者首选的网络通信库。 在使用 OkHttp 之前，我们需要先在项目中添加 OkHttp 库的依赖。编辑app/build.gradle文件，在 dependencies 闭包中添加如下内容： dependencies { implementation 'com.squareup.okhttp3:okhttp:4.9.3' ... } 可以通过访问 OkHttp 的项目主页查看当前最新的版本是多少。OkHttp 首先需要创建一个 OkHttpClient 的实例，如下所示： OkHttpClient client = new OkHttpClient(); 接下来，如果想要发起一条 HTTP 请求，就需要创建一个Request对象，并且可以在最终的build()方法之前连缀很多其他方法来丰富这个 Request 对象。比如可以通过url()方法来设置目标的网络地址，如下所示： Request request = new Request.Builder() .url(&quot;https://www.baidu.com&quot;) .build(); 之后，调用 OkHttpClient 的newCall()方法来创建一个Call对象，并调用它的execute()方法来发送请求并获取服务器返回的数据，写法如下： Response response = client.newCall(request).execute(); 其中，Response对象就是服务器返回的数据了，我们可以使用如下写法来得到返回的具体内容： String responseData = response.body().string(); 如果是发起一条POST请求会比 GET 请求稍微复杂一点，我们需要先构建出一个RequestBody对象来存放待提交的参数，如下所示： RequestBody requestBody = new FormBody.Builder() .add(&quot;username&quot;,&quot;admin&quot;) .add(&quot;password&quot;,&quot;123456&quot;) .build(); 然后，在Request.Builder中调用一下post()方法，并将RequestBody对象传入： Request request = new Request.Builder() .url(&quot;https://www.baidu.com&quot;) .post(requestBody) .build(); 接下来的操作就和GET请求一样了，调用execute()方法来发送请求并获取服务器返回的数据即可。 将我们上面使用 HttpURLConnection 请求网络的项目改用 OkHttp 的方式实现： private void sendRequestWithOkHttp() { new Thread(new Runnable() { @Override public void run() { try { OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(&quot;https://www.baidu.com&quot;) .build(); Response response = client.newCall(request).execute(); String responseData = response.body().string(); showResponse(responseData); } catch (Exception e) { e.printStackTrace(); } } }).start(); } 解析 XML 格式数据 一般我们会在网络上传输一些格式化后的数据，这种数据会有一定的结构规则和语义，当另一方收到数据消息之后，就可以按照相同的结构规则进行解析，从而取出想要的那部分内容。 在网络上传输数据时最常用的格式有两种：XML和JSON。 搭建一个最简单的 Web 服务器，在这个服务器上提供一段 XML 文本，然后我们在程序里去访问这个服务器，再对得到的 XML 文本进行解析。服务器类型有很多，这里使用 Apache 服务器。 安装好 Apache 后，在其安装目录下的 htdocs 中新建一个名为 get_data.xml 的文件，然后编辑这个文件，并加入如下 XML 格式的内容： &lt;apps&gt; &lt;app&gt; &lt;id&gt;1&lt;/id&gt; &lt;name&gt;Google Maps&lt;/name&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/app&gt; &lt;app&gt; &lt;id&gt;2&lt;/id&gt; &lt;name&gt;Chrome&lt;/name&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;/app&gt; &lt;app&gt; &lt;id&gt;3&lt;/id&gt; &lt;name&gt;Google Play&lt;/name&gt; &lt;version&gt;2.3&lt;/version&gt; &lt;/app&gt; &lt;/apps&gt; Pull 解析方式 XML 格式的数据已经提供好了，下面从中解析出我们想要得到的那部分内容。修改 MainActivity 中的代码，如下所示： private void sendRequestWithOkHttp() { //开启子线程 new Thread(new Runnable() { @Override public void run() { try { OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() // 10.0.2.2 对于模拟器来说就是电脑本机的IP地址 .url(&quot;http://10.0.2.2/get_data.xml&quot;) //解析XML数据 .build(); Response response = client.newCall(request).execute(); String responseData = response.body().string(); parseXMLWithPull(responseData); //使用 Pull 方法解析服务器返回的数据 } catch (Exception e) { e.printStackTrace(); } } }).start(); } private void parseXMLWithPull(String xmlData) { try { //获取XmlPullParserFactory实例 .newInstance() XmlPullParserFactory factory = XmlPullParserFactory.newInstance(); //借助其得到XmlPullParser对象 .newPullParser() XmlPullParser是一个接口 XmlPullParser xmlPullParser = factory.newPullParser(); //将服务器返回的XML数据设置进去 .setInput(Reader data) xmlPullParser.setInput(new StringReader(xmlData)); //文档刚被初始化 事件为START_DOCUMENT .getEventType()得到当前的解析事件 int eventType = xmlPullParser.getEventType(); String id = &quot;&quot;; String name = &quot;&quot;; String version = &quot;&quot;; //若当前解析事件不等于XmlPullParser.END_DOCUMENT 说明解析工作还没完成 while (eventType != XmlPullParser.END_DOCUMENT) { //得到当前节点的名字 .getName() String nodeName = xmlPullParser.getName(); //第一次进入while循环时为null 第二次即为apps... //过程：null-apps-null-app-null-id-null-name-null-version-app-null-...-apps switch (eventType) { //第一次while循环 eventType为START_DOCUMENT 不匹配任何标签 //开始解析某个节点 通过getName判断读到哪个标签, 然后通过nextText获取文本节点值 case XmlPullParser.START_TAG: { if (&quot;id&quot;.equals(nodeName)) { id = xmlPullParser.nextText(); //获取节点内具体的内容 .nextText() } else if (&quot;name&quot;.equals(nodeName)) { name = xmlPullParser.nextText(); } else if (&quot;version&quot;.equals(nodeName)) { version = xmlPullParser.nextText(); //nodeName = version时 说明一个节点已经读取完毕 产生事件END_TAG } break; } //完成解析某个节点 case XmlPullParser.END_TAG: { //每当解析完一个app节点后就将获取到的内容打印出来 if (&quot;app&quot;.equals(nodeName)) { Log.d(&quot;MainActivity&quot;, &quot;id is &quot; + id); Log.d(&quot;MainActivity&quot;, &quot;name is &quot; + name); Log.d(&quot;MainActivity&quot;, &quot;version is &quot; + version); } break; } default: break; } //调用next()会产生START_TAG 这个事件告诉应用程序一个标签已经开始 eventType = xmlPullParser.next(); //获取下一个解析事件 } } catch (Exception e) { e.printStackTrace(); } } 这里首先改变了 HTTP 请求的地址，10.0.2.2 对于模拟器来说就是计算机本机的 IP 地址。在得到了服务器返回的数据后，我们不再直接将其展示，而是调用了parseXMLWithPull()方法来解析服务器返回的数据。 不过我们还需要再进行一项额外的配置。从 Android9.0 系统开始，应用程序默认只允许使用 HTTPS 类型的网络请求，HTTP 类型的网络请求因为有安全隐患默认不再被支持，而我们搭建的 Apache 服务器现在使用的就是 HTTP。 为了能让程序使用 HTTP，我们还要进行如下配置才可以。右击 res 目录→New→Directory，创建一个xml目录，接着右击 xml 目录→New→File，创建一个network_config.xml文件。然后修改其中的内容，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;network-security-config&gt; &lt;base-config cleartextTrafficPermitted=&quot;true&quot;&gt; &lt;trust-anchors&gt; &lt;certificates src=&quot;system&quot; /&gt; &lt;/trust-anchors&gt; &lt;/base-config&gt; &lt;/network-security-config&gt; 这段配置文件的意思就是允许我们以明文的方式在网络上传输数据，而 HTTP 使用的就是明文传输方式。接下来修改 AndroidManifest.xml 中的代码来启用我们刚才创建的配置文件： &lt;application ... android:networkSecurityConfig=&quot;@xml/network_security_config&quot;&gt; ... &lt;/application&gt; SAX 解析方式 SAX 解析也是一种特别常用的 XML 解析方式，虽然它的用法比 Pull 解析要复杂一些，但在语义方面会更加清楚。 要使用 SAX 解析，通常情况下我们会新建一个类继承自DefaultHandler，并重写父类的 5 个方法，如下所示： public class MyHandler extends DefaultHandler { @Override public void startDocument() throws SAXException { super.startDocument(); } @Override public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException { super.startElement(uri, localName, qName, attributes); } @Override public void characters(char[] ch, int start, int length) throws SAXException { super.characters(ch, start, length); } @Override public void endElement(String uri, String localName, String qName) throws SAXException { super.endElement(uri, localName, qName); } @Override public void endDocument() throws SAXException { super.endDocument(); } } 其中： startDocument()：在开始 XML 解析的时候调用； startElement()：在开始解析某个节点的时候调用； characters()：在获取节点中内容的时候调用； endElement()：在完成解析某个节点的时候调用； endDocument()：在完成整个 XML 解析的时候调用。 其中，startElement()、characters()和endElement()这 3 个方法是有参数的，从 XML 中解析出的数据就会以参数的形式传入到这些方法中。 需要注意的是，在获取节点中的内容时，characters()方法可能会被调用多次，一些换行符也被当作内容解析出来，我们需要针对这种情况在代码中做好控制。 用 SAX 解析的方式实现和上面同样的功能。新建一个ContentHandler类继承自DefaultHandler，并重写父类的 5 个方法，如下所示： public class ContentHandler extends DefaultHandler { private String nodeName; private StringBuilder id; private StringBuilder name; private StringBuilder version; //在开始XML解析的时候调用 @Override public void startDocument() throws SAXException { super.startDocument(); id = new StringBuilder(); name = new StringBuilder(); version = new StringBuilder(); } //在开始解析某个节点的时候调用 @Override public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException { super.startElement(uri, localName, qName, attributes); //localName参数记录着当前节点的名字 nodeName = localName; } //在获取节点中内容的时候调用 @Override public void characters(char[] ch, int start, int length) throws SAXException { super.characters(ch, start, length); //根据当前节点名判断将内容添加到哪一个StringBuilder对象中 if (&quot;id&quot;.equals(nodeName)) { id.append(ch, start, length); } else if (&quot;name&quot;.equals(nodeName)) { name.append(ch, start, length); } else if (&quot;version&quot;.equals(nodeName)) { version.append(ch, start, length); } } //在完成解析某个节点的时候调用 @Override public void endElement(String uri, String localName, String qName) throws SAXException { super.endElement(uri, localName, qName); if (&quot;app&quot;.equals(localName)) { //trim()删除字符串的头尾空白符 包括：空格 制表符 换行符等 Log.d(&quot;ContentHandler&quot;, &quot;id is &quot; + id.toString().trim()); Log.d(&quot;ContentHandler&quot;, &quot;name is &quot; + name.toString().trim()); Log.d(&quot;ContentHandler&quot;, &quot;version is &quot; + version.toString().trim()); //最后要将StringBuilder清空掉(设置的新序列长度) id.setLength(0); name.setLength(0); version.setLength(0); } } //在完成整个XML解析的时候调用 @Override public void endDocument() throws SAXException { super.endDocument(); } } 首先给 id、name 和 version 节点分别定义了一个StringBuilder对象，并在startDocument()方法里对它们进行了初始化。 每当开始解析某个节点的时候，startElement()方法就会得到调用，其中localName参数记录着当前节点的名字，这里把它记录下来。 最后在endElement()方法中进行判断，若app节点已经解析完成，就打印出 id、name 和 version 的内容。需要注意的是，目前 id、name 和 version 中都可能是包括回车或换行符的，因此在打印之前我们还需要调用一下 trim() 方法。 接下来的工作就比较简单了，修改 MainActivity 中的代码，如下所示： private void sendRequestWithOkHttp() { //开启子线程 new Thread(new Runnable() { @Override public void run() { try { ... parseXMLWithSAX(responseData); //使用SAX方法解析服务器返回的数据 } catch (Exception e) { e.printStackTrace(); } } }).start(); } private void parseXMLWithSAX(String xmlData) { try { //获取SAXParserFactory实例 .newInstance() SAXParserFactory factory = SAXParserFactory.newInstance(); //借助其得到xmlReader对象 .newSAXParser().getXMLReader() xmlReader是一个接口 XMLReader xmlReader = factory.newSAXParser().getXMLReader(); //获取ContentHandler实例 将其设置到XMLReader中 ContentHandler handler = new ContentHandler(); xmlReader.setContentHandler(handler); //开始执行解析 parse(InputSource var1) xmlReader.parse(new InputSource(new StringReader(xmlData))); } catch (Exception e) { e.printStackTrace(); } } 在得到了服务器返回的数据后，我们这次去调用parseXMLWithSAX()方法来解析 XML 数据。 除了 Pull 解析和 SAX 解析之外，其实还有一种 DOM 解析方式也比较常用。 解析 JSON 格式数据 比起 XML，JSON 的主要优势在于它的体积更小，在网络上传输的时候可以更省流量。但缺点在于，它的语义性较差，看起来不如 XML 直观。 这次需要在 Apache 安装目录下的 htdocs 中新建一个get_data.json的文件，然后编辑这个文件，并加入如下 JSON 格式的内容： [{&quot;id&quot;:&quot;5&quot;,&quot;version&quot;:&quot;5.5&quot;,&quot;name&quot;:&quot;Clash of Clans&quot;}, {&quot;id&quot;:&quot;6&quot;,&quot;version&quot;:&quot;7.0&quot;,&quot;name&quot;:&quot;Boom Beach&quot;}, {&quot;id&quot;:&quot;7&quot;,&quot;version&quot;:&quot;3.5&quot;,&quot;name&quot;:&quot;Clash Royale&quot;}] 类似地，解析 JSON 数据也有很多种方法，可以使用官方提供的JSONObject，也可以使用谷歌的开源库GSON。另外，一些第三方的开源库如Jackson、FastJSON等也非常不错。 使用 JSONObject 修改 MainActivity 中的代码，如下所示： private void sendRequestWithOkHttp() { //开启子线程 new Thread(new Runnable() { @Override public void run() { try { ... Response response = client.newCall(request).execute(); String responseData = response.body().string(); if( responseData != null ){ parseJSONWithJSONObject(responseData); //使用JSONObject解析服务器返回的数据 } } catch (Exception e) { e.printStackTrace(); } } }).start(); } private void parseJSONWithJSONObject(String jsonData) { try { //在服务器中定义的是个JSON数组 将服务器返回的数据传入到JSONArray对象中 JSONArray jsonArray = new JSONArray(jsonData); for (int i = 0; i &lt; jsonArray.length(); i++) { //JSONArray中取出的每一个元素都是一个JSONObject对象 其中包含着id name version数据 JSONObject jsonObject = jsonArray.getJSONObject(i); String id = jsonObject.getString(&quot;id&quot;); String name = jsonObject.getString(&quot;name&quot;); String version = jsonObject.getString(&quot;version&quot;); Log.d(&quot;MainActivity&quot;, &quot;id is &quot; + id); Log.d(&quot;MainActivity&quot;, &quot;name is &quot; + name); Log.d(&quot;MainActivity&quot;, &quot;version is &quot; + version); } } catch (Exception e) { e.printStackTrace(); } } 这里通过getString()方法获取到数据后，只是简单地将其打印出来。 使用 GSON GSON 并没有被添加到 Android 官方的 API 中，因此如果想要使用这个功能的话，就必须在项目中添加 GSON 库的依赖。编辑app/build.gradle文件，在 dependencies 闭包中添加如下内容： dependencies { implementation 'com.google.code.gson:gson:2.9.0' ... } GSON 库的强大之处就在于可以将一段 JSON 格式的字符串自动映射成一个对象，从而不需要我们再手动编写代码进行解析了。比如说一段 JSON 格式的数据如下所示： {&quot;name&quot;:&quot;Tom&quot;,&quot;age&quot;:20} 那我们就可以定义一个 Person 类，并加入 name 和 age 这两个字段，然后只需简单地调用如下代码就可以将 JSON 数据自动解析成一个 Person 对象了： Gson gson = new Gson(); Person person = gson.fromJson(jsonData,Person.class); 如果需要解析的是一段 JSON 数组会稍微麻烦一点，我们需要借助TypeToken将期望解析成的数据类型传入到fromJson()方法中，如下所示： List&lt;Person&gt; appList = gson.fromJson(gsonData,new TypeToken&lt;List&lt;Person&gt;&gt;(){}.getType()); 下面首先新增一个 App 类，并加入 id、name 和 version 这 3 个字段，如下所示： public class App { private String id; private String name; private String version; public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getVersion() { return version; } public void setVersion(String version) { this.version = version; } } 然后修改 MainActivity 中的代码，如下所示： private void sendRequestWithOkHttp() { //开启子线程 new Thread(new Runnable() { @Override public void run() { try { ... Response response = client.newCall(request).execute(); String responseData = response.body().string(); if( responseData != null ){ parseJSONWithGSON(responseData); //使用GSON解析服务器返回的数据 } } catch (Exception e) { e.printStackTrace(); } } }).start(); } private void parseJSONWithGSON(String jsonData) { Gson gson = new Gson(); //GSON库可以可以将一段JSON格式的字符串自动映射成一个对象 List&lt;App&gt; appList = gson.fromJson(jsonData, new TypeToken&lt;List&lt;App&gt;&gt;() {}.getType()); for (App app : appList) { Log.d(&quot;MainActivity&quot;, &quot;id is &quot; + app.getId()); Log.d(&quot;MainActivity&quot;, &quot;name is &quot; + app.getName()); Log.d(&quot;MainActivity&quot;, &quot;version is &quot; + app.getVersion()); } } 网络请求回调的实现方式 一个应用程序很可能会在许多地方都使用到网络功能，而发送 HTTP 请求的代码基本是相同的，如果我们每次都去编写一遍发送 HTTP 请求的代码，效率是很低的。 通常情况下我们应该将这些通用的网络操作提取到一个公共的类里，并提供一个通用方法，当想要发起网络请求的时候，只需简单地调用一下这个方法即可。 使用HttpURLConnection的写法总体来说还是比较复杂的，这里我们只使用OkHttp来实现，代码如下所示： public class HttpUtil { ... public static void sendOkHttpRequest(String address,okhttp3.Callback callback) { OkHttpClient client = new OkHttpClient(); Request request = new Request.Builder() .url(address) .build(); client.newCall(request).enqueue(callback); } } 可以看到，sendOkHttpRequest()方法中有一个okhttp3.Callback参数，这个是 OkHttp 库中自带的一个回调接口。 网络请求通常都是属于耗时操作，所有的耗时逻辑都是在子线程里进行的，一般的请求方法可能会在服务器还没来得及响应的时候就执行结束了（线程并发），这样也就无法返回响应的数据。因此我们需要利用回调机制将响应数据成功返回给调用方，子线程中是无法通过 return 语句返回数据的。 在client. newCall()调用了一个enqueue()方法，并把 okhttp3.Callback 参数传入。OkHttp 在 enqueue() 方法的内部已经帮我们开好子线程了，然后会在子线程中去执行 HTTP 请求，并将最终的请求结果回调到 okhttp3.Callback 当中。 那么我们在调用 sendOkHttpRequest() 方法的时候就可以这样写： HttpUtil.sendOkHttpRequest(&quot;https://www.baidu.com&quot;,new okhttp3.Callback(){ @Override public void onResponse(Call call,Response response) throws IOException { //得到服务器返回的具体内容 String responseData = response.body().string(); } @Override public void onFailure(Call call,IOException e) { //在这里对异常情况进行处理 } }); 这里可以看出，OkHttp 的接口设计得确实非常人性化，它将一些常用的功能进行了很好的封装，使得我们只需编写少量的代码就能完成较为复杂的网络操作。 另外需要注意的是，不管是使用 HttpURLConnection 还是 OkHttp，最终的回调接口都还是在子线程中运行的，因此我们不可以在这里执行任何的 UI 操作，需要借助runOnUiThread()方法进行线程转换。 ","link":"https://Petrichoroo.github.io/post/lesslessdi-yi-xing-dai-ma-androidgreatergreater-bi-ji-shi-yong-wang-luo-ji-zhu/"},{"title":"《第一行代码 Android》笔记 — 运用手机多媒体","content":" 运用手机多媒体 使用通知 创建通知渠道 通知的基本用法 通知的更多用法 调用摄像头和相册（Kotlin） 调用摄像头拍照 从相册中选择图片 播放多媒体文件（Kotlin） 播放音频 播放视频 运用手机多媒体 之前一直是使用模拟器来运行程序的，下面涉及的一些功能必须要在真正的 Android 手机上运行才看得到效果，我们可以在程序中调用很多手机的多媒体资源，从而编写出更加丰富多彩的应用程序。 使用通知 通知是 Android 系统中比较有特色的一个功能，当某个应用程序希望向用户发出一些提示信息，而该应用程序又不在前台运行时，就可以借助通知来实现。 创建通知渠道 很多应用都会想尽办法地给用户发送通知，以博取更多的展示机会，那么用户手机的状态栏就会被各式各样的通知信息堆满，虽然 Android 系统允许我们将某个应用程序的通知完全屏蔽，以防止它一直给我们发送垃圾信息，但是在这些信息中，也可能会有我们所关心的内容。 于是，Android 8.0 系统引入了通知渠道这个概念，就是每条通知都要属于一个对应的渠道。每个应用程序都可以自由地创建当前应用拥有哪些通知渠道，但是这些通知渠道的控制权是掌握在用户手上的。用户可以自由地选择这些通知渠道的重要程度，是否响铃、是否振动或者是否要关闭这个渠道的通知。 拥有了这些控制权之后，用户就再也不用害怕那些垃圾通知的打扰了，因为用户可以自主地选择关心哪些想知道的信息。对于每个应用来说，通知渠道的划分是非常考究的，因为通知渠道一旦创建之后就不能再修改了。 而我们的应用程序如果想要发出通知，也必须创建自己的通知渠道。下面我们就来学习一下创建通知渠道的详细步骤。 首先需要一个NotificationManager对通知进行管理，通过调用 Context 的getSystemService()方法获取，getSystemService() 方法接收一个字符串参数用于确定获取系统的哪个服务，这里我们传入Context.NOTIFICATION_SERVICE即可，代码如下： NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE); 接下来要使用NotificationChannel类构建一个通知渠道，并调用NotificationManager的createNotificationChannel()方法完成创建。 由于 NotificationChannel 类和 createNotificationChannel() 方法都是 Android 8.0 系统中新增的API，因此我们在使用的时候还需要进行版本判断才可以，写法如下： if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) { String channelId = &quot;channelId&quot;; String channelName = &quot;&quot;; manager.createNotificationChannel(new NotificationChannel (channelId, channelName, NotificationManager.IMPORTANCE_DEFAULT)); } 创建一个通知渠道至少需要渠道 ID、渠道名称以及重要等级这 3 个参数，其中渠道 ID 可以随便定义，只要保证全局唯一性就可以。渠道名称是给用户看的，需要可以清楚地表达这个渠道的用途。 通知的重要等级主要有IMPORTANCE_HIGH、IMPORTANCE_DEFAULT、IMPORTANCE_LOW以及IMPORTANCE_MIN这几种，对应的重要程度依次从高到低。不同的重要等级会决定通知的不同行为。当然这里只是初始状态下的重要等级，用户可以随时手动更改某个通知渠道的重要等级，开发者是无法干预的。 通知的基本用法 首先需要使用一个 Builder 构造器来创建Notification对象，如下所示： NotificationManager manager = (NotificationManager)getSystemService(NOTIFICATION_SERVICE); if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) { String channelId = &quot;channelId&quot;; String channelName = &quot;&quot;; manager.createNotificationChannel(new NotificationChannel (channelId, channelName, NotificationManager.IMPORTANCE_HIGH)); } Notification notification = new NotificationCompat.Builder(MainActivity.this,&quot;channelId&quot;) .setContentTitle(&quot;This is content title&quot;) //指定通知的标题内容 .setContentText(&quot;This is content text&quot;) //指定通知的正文内容 .setSmallIcon(R.drawable.small_icon) //设置通知的小图标 .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.drawable.large_icon)) //设置通知的大图标 .build(); manager.notify(1,notification); NotificationCompat.Builder构造函数中接收两个参数：第一个参数是 Context，第二个参数是渠道 ID。 我们可以在最终的build()方法之前连缀任意多的设置方法来创建一个丰富的Notification对象。需要注意的是，setSmallIcon()方法只能使用纯 alpha 图层的图片进行设置，小图标会显示在系统状态栏上。大图标在下拉系统状态栏时，就可以看到。 最后调用notify()方法就可以让通知显示出来了。notify() 方法接收两个参数：第一个参数是 id，要保证为每个通知指定的 id 都是不同的，第二个参数则是 Notification 对象。 现在当你下拉系统状态栏点击通知时，是没有任何效果的，我们还需要在代码中通过PendingIntent进行相应的设置。 Intent 倾向于立即执行某个动作，而 PendingIntent 倾向于在某个合适的时机执行 某个动作。 PendingIntent 提供了几个静态方法用于获取其实例，可以根据需求来选择是使用getActivity()方法、getBroadcast()方法，还是getService()方法。这些方法所接收的参数都是相同的： 第一个参数是 Context。 第二个参数一般用不到，传入 0 即可。 第三个参数是一个 Intent 对象，我们可以通过这个对象构建出 PendingInten t的“意图”。 第四个参数用于确定 PendingIntent 的行为，有FLAG_ONE_SHOT、FLAG_NO_CREATE、FLAG_CANCEL_CURRENT和FLAG_UPDATE_CURRENT这 4 种值可选，具体含义可以查看文档，通常情况下传入 0 即可。 NotificationCompat.Builder这个构造器还可以连缀一个setContentIntent()方法，接收的参数正是一个 PendingIntent 对象。代码如下所示： ... Intent intent = new Intent(this, NotificationActivity.class); PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, intent, 0); Notification notification = new NotificationCompat.Builder(this,&quot;channelId&quot; ) .setContentIntent(pendingIntent) ... 这里新建一个了 NotificationActivity，当我们点击通知时，界面就会跳转到这个活动中。 不过此时你会发现系统状态上的通知图标还并没有消失，因为我们没有在代码中对该通知进行取消，它就会一直显示在系统的状态栏上。解决的方法有两种： 在 NotificationCompat.Builder 中再连缀一个setAutoCancel()方法，传入 true 即可。 显式地调用 NotificationManager 的cancel()方法将其取消。 需要注意的是，第二种方法manager.cancel(1)中的 1 正是在创建通知的时候给每条通知指定的 id，因此，如果我们想取消哪条通知，在cancel()方法中传入该通知的 id 即可。 通知的更多用法 实际上，NotificationCompat.Builder中提供了非常丰富的API，以便我们创建出更加多样的通知效果。下面是一些比较常用的 API。 setStyle()方法，这个方法允许我们构建出富文本的通知内容。也就是说，通知中不光可以有文字和图标，还可以包含更多的东西。其接收一个NotificationCompat.Style参数，这个参数就是用来构建具体的富文本信息的，如长文字、图片等。 比如在通知当中显示一段长文字，具体写法如下： Notification notification = new NotificationCompat.Builder(this,&quot;channelId&quot; ) .setStyle(NotificationCompat.BigTextStyle().bigText(&quot;长文本...&quot;)) .build() 在setStyle()方法中，我们创建了一个NotificationCompat.BigTextStyle对象，这个对象就是用于封装长文字信息的，只要调用它的bigText()方法并将文字内容传入即可。 除了显示长文字之外，通知里还可以显示一张大图片，具体用法是基本相似的： Notification notification = new NotificationCompat.Builder(this,&quot;channelId&quot; ) .setStyle(NotificationCompat.BigPictureStyle().bigPicture( BitmapFactory.decodeResource(resources, R.drawable.big_image))) .build() 通过BitmapFactory的decodeResource()方法将图片解析成Bitmap对象，再传入bigPicture()方法即可。 通知渠道的重要等级越高，发出的通知就越容易获得用户的注意。比如高重要等级的通知渠道发出的通知可以弹出横幅、发出声音，而低重要等级的通知渠道发出的通知不仅可能会在某些情况下被隐藏，而且可能会被改变显示的顺序，将其排在更重要的通知之后。我们可以在创建渠道的时候通过第三个参数来指定通知渠道的重要等级。 需要注意的是，开发者只能在创建通知渠道的时候为它指定初始的重要等级。 调用摄像头和相册（Kotlin） 调用摄像头拍照 新建一个CameraAlbumTest项目，然后修改activity_main.xml中的代码，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:id=&quot;@+id/takePhotoBtn&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Take Photo&quot; android:textAllCaps=&quot;false&quot; /&gt; &lt;ImageView android:id=&quot;@+id/imageView&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_horizontal&quot; /&gt; &lt;/LinearLayout&gt; Button用于打开摄像头进行拍照的，而ImageView则是用于将拍到的图片显示出来。然后开始编写调用摄像头的具体逻辑，修改 MainActivity 中的代码，如下所示： class MainActivity : AppCompatActivity() { private val takePhoto = 1 lateinit var imageUri: Uri lateinit var outputImage: File override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) takePhotoBtn.setOnClickListener { /** * 创建File对象 用于存储摄像头拍下的照片 图片命名为output_image.jpg * 存放在手机SD卡的应用关联缓存目录下(SD卡中专门用于存放当前应用缓存数据的位置) * 通过调用getExternalCacheDir()方法可以得到这个目录 * 从Android 6.0系统开始 读写SD卡属于危险权限 若存放在SD卡的任何其他目录 都要进行运行时权限处理 */ outputImage = File(externalCacheDir, &quot;output_image.jpg&quot;) if (outputImage.exists()) { outputImage.delete() } outputImage.createNewFile() /** * 系统版本高于Android7.0 调用getUriForFile()方法将File对象转换成封装过的Uri对象 * 因为从Android7.0开始 直接使用本地真实路径的Uri被认为是不安全的 会抛出异常 */ imageUri = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) { //FileProvider是一种特殊的内容提供器 可以选择性的将封装过的Uri共享给外部 提高安全性 FileProvider.getUriForFile( this, &quot;com.example.cameraalbumtest.fileprovider&quot;, outputImage ) } else { //系统版本低于Android7.0 直接调用Uri的fromFile将File对象转换成Uri对象 Uri.fromFile(outputImage) //这个Uri对象标识着图片的本地真实路径 } // 启动相机程序 val intent = Intent(&quot;android.media.action.IMAGE_CAPTURE&quot;) //隐式 intent.putExtra(MediaStore.EXTRA_OUTPUT, imageUri) //指定图片的输出地址 startActivityForResult(intent, takePhoto) //使用的是隐式Intent 系统会找出能够响应这个Intent的活动去启动 这样照相机程序就会被打开 } } //拍照完的结果回调到此方法中 override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { super.onActivityResult(requestCode, resultCode, data) when (requestCode) { takePhoto -&gt; { if (resultCode == Activity.RESULT_OK) { //调用BitmapFactory的decodeStream方法(接收一个InputStream对象) 将照片解析成Bitmap对象 val bitmap = BitmapFactory.decodeStream( contentResolver.openInputStream(imageUri) ) //将Bitmap对象设置到ImageView中显示出来（需要处理照片可能发生旋转的问题） imageView.setImageBitmap(rotateIfRequired(bitmap)) } } } } private fun rotateIfRequired(bitmap: Bitmap): Bitmap { val exif = ExifInterface(outputImage.path) val orientation = exif.getAttributeInt( ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL ) return when (orientation) { ExifInterface.ORIENTATION_ROTATE_90 -&gt; rotateBitmap(bitmap, 90) ExifInterface.ORIENTATION_ROTATE_180 -&gt; rotateBitmap(bitmap, 180) ExifInterface.ORIENTATION_ROTATE_270 -&gt; rotateBitmap(bitmap, 270) else -&gt; bitmap } } private fun rotateBitmap(bitmap: Bitmap, degree: Int): Bitmap { val matrix = Matrix() matrix.postRotate(degree.toFloat()) val rotatedBitmap = Bitmap.createBitmap( bitmap, 0, 0, bitmap.width, bitmap.height, matrix, true ) bitmap.recycle() // 将不再需要的Bitmap对象回收 return rotatedBitmap } } 需要注意的是，调用照相机程序去拍照有可能会在一些手机上发生照片旋转的情况。这是因为这些手机认为打开摄像头进行拍摄时手机就应该是横屏的，因此回到竖屏的情况下就会发生 90 度的旋转。为此，在imageView.setImageBitmap()里又加上了判断图片方向的代码，如果发现图片需要进行旋转，那么就先将图片旋转相应的角度，然后再显示到界面上。 然后要在AndroidManifest.xml中对ContentProvider进行注册才行，代码如下所示： &lt;application ... &lt;provider android:name=&quot;androidx.core.content.FileProvider&quot; android:authorities=&quot;com.example.cameraalbumtest.fileprovider&quot; android:exported=&quot;false&quot; android:grantUriPermissions=&quot;true&quot;&gt; &lt;meta-data android:name=&quot;android.support.FILE_PROVIDER_PATHS&quot; android:resource=&quot;@xml/file_paths&quot; /&gt; &lt;/provider&gt; &lt;/application&gt; android:name的值固定，而android:authorities的值必须和FileProvider.getUriForFile()方法中的第二个参数一致。 另外，这里还在&lt;provider&gt;标签的内部使用&lt;meta-data&gt;指定 Uri 的共享路径，并引用了一个@xml/file_paths资源。当然，这个资源现在还是不存在的，下面我们就来创建它。 右击 res 目录 →New→Directory，创建一个xml目录，接着右击 xml 目录 →New→File，创建一个file_paths.xml文件。然后修改 file_paths.xml 文件中的内容，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;paths xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;external-path name=&quot;my_images&quot; path=&quot;/&quot; /&gt; &lt;/paths&gt; external-path就是用来指定 Uri 共享路径的，name属性的值可以随便填，path属性的值表示共享的具体路径。这里使用一个单斜线表示将整个 SD 卡进行共享。 从相册中选择图片 在 CameraAlbumTest 项目的基础上进行修改，编辑activity_main.xml文件，在布局中添加一个按钮，用于从相册中选择图片，代码如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; ... &lt;Button android:id=&quot;@+id/fromAlbumBtn&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;From Album&quot; android:textAllCaps=&quot;false&quot; /&gt; ... &lt;/LinearLayout&gt; 然后修改 MainActivity 中的代码，加入从相册选择图片的逻辑，代码如下所示： class MainActivity : AppCompatActivity() { ... private val fromAlbum = 2 ... override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) ... //从相册中选择照片 fromAlbumBtn.setOnClickListener { //指定的action表示打开系统的文件选择器 val intent = Intent(Intent.ACTION_OPEN_DOCUMENT) //条件过滤 只允许可打开的图片文件显示出来 intent.addCategory(Intent.CATEGORY_OPENABLE) intent.type = &quot;image/*&quot; startActivityForResult(intent, fromAlbum) } } //拍照完的结果回调到此方法中 override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) { super.onActivityResult(requestCode, resultCode, data) when (requestCode) { ... fromAlbum -&gt; { if (resultCode == Activity.RESULT_OK &amp;&amp; data != null) { data.data?.let { uri -&gt; //调用返回Intent的getData()方法来获取选中图片的Uri // 将选择的图片显示 val bitmap = getBitmapFromUri(uri) //将Uri转换成Bitmap对象 imageView.setImageBitmap(bitmap) } } } } } } 最后需要注意的是，如果某些图片的像素很高，直接加载到内存中就有可能会导致程序崩溃。更好的做法是根据项目的需求先对图片进行适当的压缩，然后再加载到内存中。 播放多媒体文件（Kotlin） 播放音频 在 Android 中播放音频文件一般是使用MediaPlayer类实现的，它对多种格式的音频文件提供了非常全面的控制方法，下表列出了 MediaPlayer 类中一些较为常用的控制方法。 MediaPlayer的工作流程：首先需要创建一个 MediaPlayer 对象，然后调用setDataSource()方法设置音频文件的路径，再调用prepare()方法使 MediaPlayer 进入准备状态，接下来调用start()方法就可以开始播放音频，调用pause()方法就会暂停播放，调用reset()方法就会停止播放。 新建一个 PlayAudioTest 项目，然后修改activity_main.xml中的代码，如下所示： &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;Button android:id=&quot;@+id/play&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Play&quot; android:textAllCaps=&quot;false&quot; /&gt; &lt;Button android:id=&quot;@+id/pause&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Pause&quot; android:textAllCaps=&quot;false&quot; /&gt; &lt;Button android:id=&quot;@+id/stop&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;&quot; android:text=&quot;Stop&quot; /&gt; &lt;/LinearLayout&gt; 布局文件中放置了 3 个按钮，分别用于对音频文件进行播放、暂停和停止操作。 MediaPlayer 可以用于播放网络、本地以及应用程序安装包中的音频。为简单起见，下面实现播放应用程序安装包中的音频。 Android Studio 允许我们在项目工程中创建一个assets目录，并在这个目录下存放任意文件和子目录，这些文件和子目录在项目打包时会一并被打包到安装文件中，然后在程序中就可以借助AssetManager这个类提供的接口对 assets 目录下的文件进行读取。 首先需要创建assets目录，它必须创建在app/src/main这个目录下面，创建完成后，由于我们要播放音频文件，因此需要提前准备好了一份 music.mp3 资源，将它放入 assets 目录中即可。 class MainActivity : AppCompatActivity() { private val mediaPlayer = MediaPlayer() override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val play: Button = findViewById(R.id.play) val pause: Button = findViewById(R.id.pause) val stop: Button = findViewById(R.id.stop) initMediaPlayer() play.setOnClickListener { if (!mediaPlayer.isPlaying) { //判断当前MediaPlayer是否正在播放音频 mediaPlayer.start() // 开始播放 } } pause.setOnClickListener { if (mediaPlayer.isPlaying) { mediaPlayer.pause() // 暂停播放 } } stop.setOnClickListener { //停止播放 if (mediaPlayer.isPlaying) { mediaPlayer.reset() // 将MediaPlayer对象重置到刚刚创建的状态 initMediaPlayer() } } } private fun initMediaPlayer() { val assetManager = assets val fd = assetManager.openFd(&quot;music.mp3&quot;) //设置要播放的音频文件的位置 setDataSource()有多个重载方法 mediaPlayer.setDataSource(fd.fileDescriptor, fd.startOffset, fd.length) mediaPlayer.prepare() } override fun onDestroy() { super.onDestroy() mediaPlayer.stop() mediaPlayer.release() } } 在initMediaPlayer()方法中，首先通过getAssets()方法得到了一个AssetManager的实例，AssetManager 可用于读取assets目录下的任何资源。接着我们调用了openFd()方法将音频文件句柄打开，后面又依次调用了setDataSource()方法和prepare()方法，为MediaPlayer做好了播放前的准备。 最后在onDestroy()方法中，需要分别调用stop()方法和release()方法，将与MediaPlayer相关的资源释放掉。 播放视频 播放视频文件主要是使用VideoView类来实现的。这个类将视频的显示和控制集于一身，它的常用方法如下表所示： 新建 PlayVideoTest 项目，然后修改 activity_main.xml 中的代码，如下所示： &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:orientation=&quot;vertical&quot;&gt; &lt;LinearLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;Button android:id=&quot;@+id/play&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:text=&quot;Play&quot; /&gt; &lt;Button android:id=&quot;@+id/pause&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:text=&quot;Pause&quot; /&gt; &lt;Button android:id=&quot;@+id/replay&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:text=&quot;Replay&quot; /&gt; &lt;/LinearLayout&gt; &lt;VideoView android:id=&quot;@+id/videoView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; /&gt; &lt;/LinearLayout&gt; 这个布局文件中同样放置了 3个 按钮，分别用于控制视频的播放、暂停和重新播放。另外在按钮的下面又放置了一个VideoView，稍后的视频就将在这里显示。 VideoView不支持直接播放assets目录下的视频资源，我们可以在res目录下再创建一个raw目录，像诸如音频、视频之类的资源文件也可以放在这里，并且 VideoView 可以直接播放这个目录下的视频资源。 右击 app/src/main/res→New→Directory，在这里完成raw目录的创建，并把要播放的视频资源 video.mp4 放在里面。 然后修改 MainActivity 中的代码，如下所示： class MainActivity : AppCompatActivity() { override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) val uri = Uri.parse(&quot;android.resource://$packageName/${R.raw.video}&quot;) videoView.setVideoURI(uri) play.setOnClickListener { if (!videoView.isPlaying) { videoView.start() // 开始播放 } } pause.setOnClickListener { if (videoView.isPlaying) { videoView.pause() // 暂停播放 } } replay.setOnClickListener { if (videoView.isPlaying) { videoView.resume() // 重新播放 } } } override fun onDestroy() { super.onDestroy() videoView.suspend() } } 首先在onCreate()方法中调用了Uri.parse()方法，将 raw 目录下的 video.mp4 文件解析成了一个 Uri 对象，这里使用的写法是 Android 要求的固定写法。 然后调用VideoView的setVideoURI()方法将刚才解析出来的 Uri 对象传入，这样就完成了 VideoView 的初始化，接下来就是控制视频播放的逻辑处理。 最后在onDestroy()方法中，需要调用一下suspend()方法，将VideoView所占用的资源释放掉。 VideoView 用法和 MediaPlayer 是比较相似的，其实只是 VideoView 帮我们做了一个很好的封装而已，它的背后仍然是使用 MediaPlayer 对视频文件进行控制的。 另外需要注意，VideoView 并不是一个万能的视频播放工具类，它在视频格式的支持以及播放效率方面都存在着较大的不足。 ","link":"https://Petrichoroo.github.io/post/lesslessdi-yi-xing-dai-ma-androidgreatergreater-bi-ji-yun-yong-shou-ji-duo-mei-ti/"},{"title":"《第一行代码 Android》笔记 — 内容提供器","content":" Content Provider 内容提供器简介 运行时权限 Android 权限机制详解 在程序运行时申请权限 访问其他程序中的数据 ContentResolver 的基本用法 读取系统联系人 创建自己的 Content Provider 创建 ContentProvider 的步骤 实现跨程序数据共享 Content Provider 内容提供器简介 ContentProvider主要用于在不同的应用程序之间实现数据共享的功能，它提供了一套完整的机制，允许一个程序访问另一个程序中的数据，同时还能保证被访问数据的安全性。 目前，使用ContentProvider 是 Android 实现跨程序共享数据的标准方式。 不同于文件存储和 SharedPreferences 存储中的两种全局可读写操作模式（Android 4.2版本中都已被废弃），ContentProvider 可以选择只对哪一部分数据进行共享，从而保证我们程序中的隐私数据不会有泄漏的风险。 运行时权限 Android 权限机制详解 Android 6.0 系统中加入了运行时权限功能。也就是说，用户不需要在安装软件的时候一次性授权所有申请的权限，而是可以在软件的用过程中再对某一项权限申请进行授权。 当然，并不是所有权限都需要在运行时申请，Android 现在将常用的权限大致归成了两类，一类是普通权限，一类是危险权限。准确地讲，其实还有一些特殊权限，不过这些权限使用得相对较少。 普通权限指的是那些不会直接威胁到用户的安全和隐私的权限，对于这部分权限申请，系统会自动帮我们进行授权，不需要用户手动操作。 危险权限则表示那些可能会触及用户隐私或者对设备安全性造成影响的权限，如获取设备联系人信息、定位设备的地理位置等，对于这部分权限申请，必须由用户手动授权才可以，否则程序就无法使用相应的功能。 至 Android 10 系统为止，所有的危险权限，一共是 11 组 30 个权限。每个危险权限都属于一个权限组，我们在进行运行时权限处理时使用的是权限名。原则上，用户一旦同意了某个权限申请之后，同组的其他权限也会被系统自动授权。但是请谨记，不要基于此规则来实现任何功能逻辑，因为 Android 系统随时有可能调整权限的分组。 在程序运行时申请权限 CALL_PHONE这个权限是编写拨打电话功能的时候需要声明的，因为拨打电话会涉及用户手机的资费问题，因而被列为了危险权限。 在 Android 6.0 系统及以上实现拨打电话功能需要进行运行时权限处理，修改 MainActivity 中的代码，如下所示： Button makeCall = findViewById(R.id.make_call); //在程序运行过程中由用户授权我们去执行某些危险操作 makeCall.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { //先判断用户是不是已经给过我们授权 if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED) { //没有授权 调用相关方法来向用户申请授权 ActivityCompat.requestPermissions(MainActivity.this, new String[]{Manifest.permission.CALL_PHONE}, 1); } else { //已经授权 直接执行拨打电话的逻辑操作 call(); } } }); 首先判断用户是不是已经给过我们授权了，借助的是checkSelfPermission()方法，其接收两个参数：第一个参数是 Context，第二个参数是具体的权限名。 然后我们使用方法的返回值和PackageManager.PERMISSION_GRANTED做比较，相等就说明用户已经授权，不等就表示用户没有授权。 如果没有授权的话，则需要调用ActivityCompat.requestPermissions()方法向用户申请授权。其接收 3 个参数：第一个参数要求是 Activity 的实例；第二个参数是一个 String 数组，我们把要申请的权限名放在数组中即可；第三个参数是请求码，只要是唯一值即可。 调用完requestPermissions()方法之后，系统会弹出一个权限申请的对话框，用户可以选择同意或拒绝我们的权限申请。不论是哪种结果，最终都会回调到onRequestPermissionsResult()方法中，而授权的结果则会封装在grantResults参数当中。这里我们只需要判断一下最后的授权结果：如果用户同意的话，就调用call()方法拨打电话；如果用户拒绝的话，我们只能放弃操作，并且弹出一条失败提示。代码如下所示： @Override public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); switch (requestCode) { case 1: //判断一下最后的授权结果 if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) { call(); } else { Toast.makeText(this, &quot;You denied the permission&quot;, Toast.LENGTH_SHORT).show(); } break; default: } } private void call() { try { Intent intent = new Intent(Intent.ACTION_CALL); intent.setData(Uri.parse(&quot;tel:10086&quot;)); startActivity(intent); } catch (SecurityException e) { e.printStackTrace(); } } 最后需要注意的是，无论是普通权限、还是运行时权限，都需要在 AndroidManifest 中进行声明。比如拨打电话需要加入以下权限： &lt;uses-permission android:name=&quot;android.permission.CALL_PHONE&quot;/&gt; 访问其他程序中的数据 ContentProvider的用法一般有两种：一种是使用现有的 ContentProvider 读取和操作相应程序中的数据。另一种是创建自己的 ContentProvider，给程序的数据提供外部访问接口。 ContentResolver 的基本用法 对于每一个应用程序来说，如果想要访问 ContentProvider 中共享的数据，就一定要借助ContentResolver类，可以通过 Context 中的getContentResolver()方法获取该类实例。 ContentResolver 中提供了一系列的方法用于对数据进行增删改查操作，其中insert()方法用于添加数据，update()方法用于更新数据，delete()方法用于删除数据，query()方法用于查询数据，不过这些方法都是不接收表名参数的，而是使用一个Uri参数代替，这个参数被称为内容 URI。 内容 URI 给 ContentProvider 中的数据建立了唯一标识符，它主要由两部分组成： authority：用于对不同的应用程序做区分，一般为了避免冲突，会采用应用包名的方式来进行命名。比如某个应用的包名是 com.example.app，那么该应用对应的 authority 就是com.example.app.provider。 path：用于对同一应用程序中不同的表做区分的，通常会添加到authority的后面。 还需要在字符串的头部加上协议声明，因此内容 URI 最标准的格式如下： content:// com.example.app.provider/table1 content:// com.example.app.provider/table2 内容 URI 可以非常清楚地表达我们想要访问哪个程序中哪张表里的数据。 在得到了内容 URI 字符串之后，我们还需要将它解析成 Uri 对象才可以作为参数传入。代码如下所示： Uri uri = Uri.parse(&quot;content://com.example.app.provider/table1&quot;) 使用这个 Uri 对象来查询 table1 表中的数据了，代码如下所示： Cursor cursor = getContentResolver().query( uri, projection, selection, selectionArgs, sortOrder); 参数说明如下所示： 通过移动游标的位置遍历 Cursor 的所有行，然后取出每一行中相应列的数据，代码如下所示： if (cursor != null) { while (cursor.moveToNext()) { String column1 = cursor.getString(cursor.getColumnIndex(&quot;column1&quot;)); int column2 = cursor.getInt(cursor.getColumnIndex(&quot;column2&quot;)); } cursor.close(); } 向 table1 表中添加一条数据，代码如下所示： ContentValues values = new ContentValues(); values.put(&quot;column1&quot;,&quot;text&quot;); values.put(&quot;column2&quot;,1); getContentResolver().insert(uri,values); 更新这条新添加的数据，把 column1 的值清空，可以借助 ContentResolver 的update()方法实现，代码如下所示： ContentValues values = new ContentValues(); values.put(&quot;column1&quot;,&quot;&quot;); getContentResolver().update(uri,values,&quot;column1 = ? and column2 = ? &quot;,new String[] {&quot;text&quot;,&quot;1&quot;}); 这里使用了selection和selectionArgs参数来对想要更新的数据进行约束，以防止所有的行都会受影响。最后，可以调用 ContentResolver 的delete()方法将这条数据删除掉，代码如下所示： getContentResolver().delete(uri,&quot;column2 = ? &quot;,new String[] {&quot;1&quot;}); 读取系统联系人 模拟器电话簿里是没有任何联系人的，需要自己手动添加几个，以便稍后进行读取。 首先在 AndroidManifest 中添加权限，如下所示： &lt;uses-permission android:name=&quot;android.permission.READ_CONTACTS&quot;/&gt; 这是一个危险权限，需要程序运行时申请。修改 MainActivity 中的代码，如下所示： public class MainActivity extends AppCompatActivity { ArrayAdapter&lt;String&gt; adapter; List&lt;String&gt; contactsList = new ArrayList&lt;&gt;(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ListView contactsView = findViewById(R.id.contacts_view); adapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1, contactsList); contactsView.setAdapter(adapter); //READ_CONTACTS权限属于危险权限 if (ContextCompat.checkSelfPermission(this, Manifest.permission.READ_CONTACTS) != PackageManager.PERMISSION_GRANTED) { ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.READ_CONTACTS}, 1); } else { readContacts(); } } private void readContacts() { Cursor cursor = null; try { //查询联系人数据 cursor = getContentResolver().query(ContactsContract.CommonDataKinds.Phone.CONTENT_URI, null, null, null, null); if (cursor != null) { while (cursor.moveToNext()) { //获取联系人姓名 @SuppressLint(&quot;Range&quot;) String displayName = cursor.getString(cursor.getColumnIndex (ContactsContract.CommonDataKinds.Phone.DISPLAY_NAME)); //获取联系人手机号 @SuppressLint(&quot;Range&quot;) String number = cursor.getString(cursor.getColumnIndex (ContactsContract.CommonDataKinds.Phone.NUMBER)); //将数据添加到 ListView 的数据源里 contactsList.add(displayName + &quot;\\n&quot; + number); } adapter.notifyDataSetChanged(); //通知刷新ListView } } catch (Exception e) { e.printStackTrace(); } finally { if (cursor != null) { cursor.close(); } } } @Override public void onRequestPermissionsResult(...) { ... //与之前所写差别不大 } } 这里使用了 ListView 来展示读取出来的联系人信息，READ_CONTACTS权限属于危险权限，需要程序运行时申请，其步骤和之前所写差不多。在用户授权之后，调用readContacts()方法读取系统联系人信息。 ContactsContract.CommonDataKinds.Phone类已经帮我们做好了封装，不需要我们自己去解析一个内容 URI 字符串，它提供了一个CONTENT_URI常量，而这个常量就是使用Uri.parse()方法解析出来的结果。 同样地，在getColumnIndex()方法中，传入的联系人姓名和联系人手机号所对应的常量也是封装好了的，将两个数据取出后进行拼接，然后将数据添加到 ListView 的数据源里，并通知刷新一下 ListView，最后记得将 Cursor 对象关闭。 创建自己的 Content Provider 上面我们是在自己的程序中访问其他应用程序的数据，那么那些提供外部访问接口的应用程序都是如何实现这种功能的呢？它们又是怎样保证数据的安全性，使得隐私数据不会泄漏出去？ 创建 ContentProvider 的步骤 通过新建一个类去继承ContentProvider的方式来创建一个自己的内容提供器。ContentProvider类中有 6 个抽象方法，我们在使用子类继承它的时候，需要将其全部重写，如下所示： public class MyProvider extends ContentProvider { @Override public boolean onCreate() { return false; } @Nullable @Override public Cursor query(@NonNull Uri uri, @Nullable String[] strings, @Nullable String s, @Nullable String[] strings1, @Nullable String s1) { return null; } @Nullable @Override public String getType(@NonNull Uri uri) { return null; } @Nullable @Override public Uri insert(@NonNull Uri uri, @Nullable ContentValues contentValues) { return null; } @Override public int delete(@NonNull Uri uri, @Nullable String s, @Nullable String[] strings) { return 0; } @Override public int update(@NonNull Uri uri, @Nullable ContentValues contentValues, @Nullable String s, @Nullable String[] strings) { return 0; } } onCreate()：初始化内容提供器的时候调用。通常会在这里完成对数据库的创建和升级等操作。 query()：从内容提供器中查询数据。使用 uri 参数来确定查询哪张表，查询的结果存放在 Cursor 对象中返回。 insert()：向内容提供器中添加一条数据。使用 uri 参数来确定要添加到的表，待添加的数据保存在 values 参数中。添加完成后，返回一个用于表示这条新记录的 URI。 update()：更新内容提供器中已有的数据。使用 uri 参数来确定更新哪一张表中的数据，受影响的行数将作为返回值返回。 delete()：从内容提供器中删除数据。使用 uri 参数来确定删除哪一张表中的数据，被删除的行数将作为返回值返回。 getType()：根据传入的内容 URI 来返回相应的MIME类型。 可以看到，几乎每一个方法都会带有 Uri 这个参数，这个参数也正是调用 ContentResolver 的增删改查方法时传递过来的。 现在，我们需要对传入的 Uri 参数进行解析，从中分析出调用方期望访问的表和数据。之前一个标准的内容 URI 写法是这样的： content://com.example.app.provider/table1 除此之外，我们还可以在这个内容 URI 的后面加上一个id，如下所示： content://com.example.app.provider/table1/1 内容 URI 的格式主要就只有以上两种，以路径结尾就表示期望访问该表中所有的数据，以 id 结尾就表示期望访问该表中拥有相应 id 的数据。我们可以使用通配符的方式来分别匹配这两种格式的内容 URI，规则如下： 星号（*）：表示匹配任意长度的任意字符。 井号（#） ：表示匹配任意长度的数字。 因此，一个能够匹配任意表的内容 URI 格式就可以写成： content://com.example.app.provider/* 而一个能够匹配 table1 表中任意一行数据的内容 URI 格式就可以写成： content://com.example.app.provider/table1/# 接着，再借助UriMatcher这个类就可以轻松地实现匹配内容 URI 的功能。 UriMatcher 提供了一个addURI()方法，这个方法接收 3 个参数，可以分别把authority、path和一个自定义代码传进去。这样，当调用 UriMatcher 的match()方法时，就可以将一个 Uri 对象传入，返回值是某个能够匹配这个 Uri 对象所对应的自定义代码，利用这个代码，我们就可以判断出调用方期望访问的是哪张表中的数据了。修改 MyProvider 中的代码，如下所示： public class MyProvider extends ContentProvider { public static final int TABLE1_DIR = 0; public static final int TABLE1_ITEM = 1; public static final int TABLE2_DIR = 2; public static final int TABLE2_ITEM = 3; private static UriMatcher uriMatcher; static { uriMatcher = new UriMatcher(UriMatcher.NO_MATCH); uriMatcher.addURI(&quot;com.example.app.provider&quot;,&quot;table1&quot;,TABLE1_DIR); uriMatcher.addURI(&quot;com.example.app.provider&quot;,&quot;table1/#&quot;,TABLE1_ITEM); uriMatcher.addURI(&quot;com.example.app.provider&quot;,&quot;table2&quot;,TABLE2_DIR); uriMatcher.addURI(&quot;com.example.app.provider&quot;,&quot;table2/#&quot;,TABLE2_ITEM); } ... @Nullable @Override public Cursor query(@NonNull Uri uri, @Nullable String[] strings, @Nullable String s, @Nullable String[] strings1, @Nullable String s1) { switch (uriMatcher.match(uri)) { case TABLE1_DIR: //查询table1表中的所有数据 break; case TABLE1_ITEM: //查询table1表中的单条数据 break; case TABLE2_DIR: //查询table2表中的所有数据 break; case TABLE2_ITEM: //查询table2表中的单条数据 break; default: break; } ... } ... } MyProvider 中新增了 4 个整型常量，其中： TABLE1_DIR表示访问 table1 表中的所有数据。 TABLE1_ITEM表示访问 table1 表中的单条数据。 TABLE2_DIR表示访问 table2 表中的所有数据。 TABLE2_ITEM表示访问 table2 表中的单条数据。 然后在静态代码块里创建了UriMatcher的实例，并调用addURI()方法，将期望匹配的内容 URI 格式传递进去，注意这里传入的路径参数是可以使用通配符的。当query()方法被调用的时候，就会通过 UriMatcher 的match()方法对传入的 Uri 对象进行匹配，如果发现 UriMatcher 中某个内容 URI 格式成功匹配了该 Uri 对象，则会返回相应的自定义代码，然后我们就可以判断出调用方期望访问的到底是什么数据了。 上述代码只是以 query() 方法为例做了个示范，其实 insert()、update()、delete() 这几个方法的实现也是差不多的，它们都会携带 Uri 这个参数，然后同样利用 UriMatcher 的 match() 方法判断出调用方期望访问的是哪张表，再对该表中的数据进行相应的操作就可以了。 还有一个getType()方法。它是所有的内容提供器都必须提供的一个方法，用于获取 Uri 对象所对应的MIME类型。一个内容 URI 所对应的 MIME 字符串主要由 3 部分组成，Android 对这 3 个部分做了如下格式规定： 必须以 vnd 开头。 如果内容 URI 以路径结尾，则后接android.cursor.dir/，如果内容 URI 以 id 结尾，则后接android.cursor.item/。 最后接上vnd.&lt;authority&gt;.&lt;path&gt;。 所以，对于content://com.example.app.provider/table1这个内容URI，它所对应的 MIME 类型就可以写成： vnd.android.cursor.dir/vnd.com.example.app.provider.table1 对于content://com.example.app.provider/table1/1这个内容 URI，它所对应的 MIME 类型就可以写成： vnd.android.cursor.item/vnd.com.example.app.provider.table1 可以继续完善 MyProvider 中的内容了，这次来实现getType()方法中的逻辑，代码如下所示： ... public class MyProvider extends ContentProvider { ... @Nullable @Override public String getType(@NonNull Uri uri) { switch (uriMatcher.match(uri)) { case TABLE1_DIR: return &quot;vnd.android.cursor.dir/vnd.com.example.app.provider.table1&quot;; case TABLE1_ITEM: return &quot;vnd.android.cursor.item/vnd.com.example.app.provider.table1&quot;; case TABLE2_DIR: return &quot;vnd.android.cursor.dir/vnd.com.example.app.provider.table2&quot;; case TABLE2_ITEM: return &quot;vnd.android.cursor.item/vnd.com.example.app.provider.table2&quot;; default: break; } return null; } } ... 到这里，一个完整的内容提供器就创建完成了，现在任何一个应用程序都可以使用 ContentResolver 来访问我们程序中的数据。 那么,如何才能保证隐私数据不会泄漏出去呢？所有的 CRUD 操作都一定要匹配到相应的内容 URI 格式才能进行的，而我们不可能向 UriMatcher 中添加隐私数据的 URI，所以这部分数据根本无法被外部程序访问到，安全问题也就不存在了。 实现跨程序数据共享 在之前数据库（SQLite）的项目 DatabaseTest 的基础上继续开发，通过内容提供器来给它加入外部访问接口。首先将 MyDatabaseHelper 中使用 Toast 弹出创建数据库成功的提示去除掉，因为跨程序访问时我们不能直接使用 Toast。 创建一个内容提供器，右击包名→New→Other→Content Provider，命名为DatabaseProvider。authority指定为com.example. databasetest.provider。下面两个属性都选中，Exported表示是否允许外部程序访问我们的内容提供器，Enabled表示是否启用内容提供器。修改 DatabaseProvider 中的代码，如下所示： public class DatabaseProvider extends ContentProvider { public static final int BOOK_DIR = 0; //访问Book表中的所有数据 public static final int BOOK_ITEM = 1; //访问Book表中的单条数据 public static final int CATEGORY_DIR = 2; //访问Category表中的所有数据 public static final int CATEGORY_ITEM = 3; //访问Category表中的单条数据 public static final String AUTHORITY = &quot;com.example.databasetest.provider&quot;; private static UriMatcher uriMatcher; private MyDatabaseHelper dbHelper; //初始化UriMatcher 添加期望匹配的几种URI格式 static { uriMatcher = new UriMatcher(UriMatcher.NO_MATCH); //addURI(authority,path,自定义代码) uriMatcher.addURI(AUTHORITY, &quot;book&quot;, BOOK_DIR); uriMatcher.addURI(AUTHORITY, &quot;book/#&quot;, BOOK_ITEM); uriMatcher.addURI(AUTHORITY, &quot;category&quot;, CATEGORY_DIR); uriMatcher.addURI(AUTHORITY, &quot;category/#&quot;, CATEGORY_ITEM); } @Override public boolean onCreate() { dbHelper = new MyDatabaseHelper(getContext(), &quot;BookStore.db&quot;, null, 2); return true; } //查询数据 @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { SQLiteDatabase db = dbHelper.getReadableDatabase(); Cursor cursor = null; /** 根据传入的Uri参数判断出用户想要访问哪张表 match()返回值是某个能够匹配这个Uri对象的自定义代码 根据自定义代码判断出调用方期望访问的数据 */ switch (uriMatcher.match(uri)) { case BOOK_DIR: //访问全部数据 下同 cursor = db.query(&quot;Book&quot;, projection, selection, selectionArgs, null, null, sortOrder); break; case BOOK_ITEM: //访问单条数据（需要得到相关 id）下同 /** getPathSegments() 方法将内容 URI 权限之后的部分以&quot;/&quot;符号进行分割 把分割后的结果放到一个字符串列表中 第0个位置存放的是 path 第一个位置是 id */ String bookId = uri.getPathSegments().get(1); cursor = db.query(&quot;Book&quot;, projection, &quot;id=?&quot;, new String[]{bookId}, null, null, sortOrder); break; case CATEGORY_DIR: cursor = db.query(&quot;Category&quot;, projection, selection, selectionArgs, null, null, sortOrder); break; case CATEGORY_ITEM: String categoryId = uri.getPathSegments().get(1); cursor = db.query(&quot;Category&quot;, projection, &quot;id=?&quot;, new String[]{categoryId}, null, null, sortOrder); break; default: break; } return cursor; } //添加数据 返回值是一个能够表示这条新增数据的 URI @Override public Uri insert(Uri uri, ContentValues values) { SQLiteDatabase db = dbHelper.getWritableDatabase(); Uri uriReturn = null; //根据传入的 Uri 参数判断出用户想往哪张表里添加数据 switch (uriMatcher.match(uri)) { case BOOK_DIR: case BOOK_ITEM: long newBookId = db.insert(&quot;Book&quot;, null, values); //内容URI以新增数据的id结尾 uriReturn = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/book/&quot; + newBookId); break; case CATEGORY_DIR: case CATEGORY_ITEM: long newCategoryId = db.insert(&quot;Category&quot;, null, values); uriReturn = Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/category/&quot; + newCategoryId); break; default: break; } return uriReturn; } //更新数据 返回值是受影响的行数 @Override public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) { SQLiteDatabase db = dbHelper.getWritableDatabase(); int updatedRows = 0; //根据传入的Uri参数判断出用户想要更新哪张表里的数据 switch (uriMatcher.match(uri)) { case BOOK_DIR: updatedRows = db.update(&quot;Book&quot;, values, selection, selectionArgs); break; case BOOK_ITEM: String bookId = uri.getPathSegments().get(1); updatedRows = db.update(&quot;Book&quot;, values, &quot;id=?&quot;, new String[]{bookId}); break; case CATEGORY_DIR: updatedRows = db.update(&quot;Category&quot;, values, selection, selectionArgs); break; case CATEGORY_ITEM: String categoryId = uri.getPathSegments().get(1); updatedRows = db.update(&quot;Category&quot;, values, &quot;id=?&quot;, new String[]{categoryId}); break; default: break; } return updatedRows; } //删除数据 返回值是被删除的行数 @Override public int delete(Uri uri, String selection, String[] selectionArgs) { SQLiteDatabase db = dbHelper.getWritableDatabase(); int deletedRows = 0; switch (uriMatcher.match(uri)) { case BOOK_DIR: deletedRows = db.delete(&quot;Book&quot;, selection, selectionArgs); break; case BOOK_ITEM: String bookId = uri.getPathSegments().get(1); deletedRows = db.delete(&quot;Book&quot;, &quot;id=?&quot;, new String[]{bookId}); break; case CATEGORY_DIR: deletedRows = db.delete(&quot;Category&quot;, selection, selectionArgs); break; case CATEGORY_ITEM: String categoryId = uri.getPathSegments().get(1); deletedRows = db.delete(&quot;Category&quot;, &quot;id=?&quot;, new String[]{categoryId}); break; default: break; } return deletedRows; } //按照之前介绍的格式规则编写 @Override public String getType(Uri uri) { switch (uriMatcher.match(uri)) { case BOOK_DIR: return &quot;vnd.android.cursor.dir/vnd.com.example.dataebasetest.provider.book&quot;; case BOOK_ITEM: return &quot;vnd.android.cursor.item/vnd.com.example.dataebasetest.provider.book&quot;; case CATEGORY_DIR: return &quot;vnd.android.cursor.dir/vnd.com.example.dataebasetest.provider.category&quot;; case CATEGORY_ITEM: return &quot;vnd.android.cursor.item/vnd.com.example.dataebasetest.provider.category&quot;; } return null; } } 内容提供器一定要在 AndroidManifest.xml 文件中注册才可以使用，由于是使用快捷方式创建的内容提供器，因此注册这一步已经被自动完成了。打开文件，代码如下所示： &lt;provider android:name=&quot;.DatabaseProvider&quot; android:authorities=&quot;com.example.databasetest.provider&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt;&lt;/provider&gt; 创建一个新项目ProviderTest，我们将通过这个程序去访问 DatabaseTest 中的数据。在布局文件中放置 4 个按钮，分别用于添加、查询、修改和删除数据，然后修改 MainActivity 中的代码，如下所示： public class MainActivity extends AppCompatActivity { private String newId; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //添加数据 Button addData = findViewById(R.id.add_data); addData.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Uri uri = Uri.parse(&quot;content://com.example.datebasetest.provider/book&quot;); ContentValues values = new ContentValues(); values.put(&quot;name&quot;, &quot;A Clash of Kings&quot;); values.put(&quot;author&quot;, &quot;George Martin&quot;); values.put(&quot;pages&quot;, 1040); values.put(&quot;price&quot;, 12.1); //insert() 方法会返回一个 Uri 对象 包含了新增数据的 id Uri newUri = getContentResolver().insert(uri, values); newId = newUri.getPathSegments().get(1); } }); //查询数据 Button queryData = findViewById(R.id.query_data); queryData.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Uri uri = Uri.parse(&quot;content://com.example.datebasetest.provider/book&quot;); Cursor cursor = getContentResolver().query(uri, null, null, null, null); if (cursor != null) { while (cursor.moveToNext()) { @SuppressLint(&quot;Range&quot;) String name = cursor.getString (cursor.getColumnIndex(&quot;name&quot;)); @SuppressLint(&quot;Range&quot;) String author = cursor.getString (cursor.getColumnIndex(&quot;author&quot;)); @SuppressLint(&quot;Range&quot;) int pages = cursor.getInt (cursor.getColumnIndex(&quot;pages&quot;)); @SuppressLint(&quot;Range&quot;) double price = cursor.getDouble (cursor.getColumnIndex(&quot;price&quot;)); Log.d(&quot;MainActivity&quot;, &quot;book name is &quot; + name); Log.d(&quot;MainActivity&quot;, &quot;book author is &quot; + author); Log.d(&quot;MainActivity&quot;, &quot;book pages is &quot; + pages); Log.d(&quot;MainActivity&quot;, &quot;book price is &quot; + price); } cursor.close(); } } }); //更新数据 Button updateData = findViewById(R.id.update_data); updateData.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { /** 避免 Book 表中的其他行受到影响 在内容 URI 尾部增加了一个 id 这个 id 正是添加数据时所返回的 表示我们只希望更新刚刚添加的那条数据 */ Uri uri = Uri.parse(&quot;content://com.example.datebasetest.provider/book/&quot; + newId); ContentValues values = new ContentValues(); values.put(&quot;name&quot;,&quot;A Storm of Swords&quot;); values.put(&quot;pages&quot;,1216); values.put(&quot;price&quot;,24.05); getContentResolver().update(uri,values,null,null); } }); //删除数据 Button deleteData = findViewById(R.id.delete_data); deleteData.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Uri uri = Uri.parse(&quot;content://com.example.datebasetest.provider/book/&quot;+newId); getContentResolver().delete(uri,null,null); } }); } } 之前所使用的模拟器的 SDK 是 API 30，启动 ProviderTest 项目会报错，因为该版本（Android 11）的更新中，改变了当前应用于本机其他应用进行交互的方式。参考博客 尝试在定义 Provider 的应用 Manifest 中声明可访问权限，然后在需要访问 Provider 的应用的 Manifest 中获取权限。 在定义 Provider 的项目 DatabaseTest 中声明可访问权限： ... &lt;permission android:name=&quot;DatabaseProvider._READ_PERMISSION&quot; android:protectionLevel=&quot;normal&quot; /&gt; &lt;permission android:name=&quot;DatabaseProvider._WRITE_PERMISSION&quot; android:protectionLevel=&quot;normal&quot; /&gt; ... 在访问 Provider 的项目 ProviderTest 中声明访问权限： ... &lt;uses-permission android:name=&quot;DatabaseProvider._READ_PERMISSION&quot; /&gt; &lt;uses-permission android:name=&quot;DatabaseProvider._WRITE_PERMISSION&quot; /&gt; &lt;queries&gt; &lt;package android:name=&quot;com.example.crossdatasharing&quot; /&gt; &lt;/queries&gt; ... 更改完 AndroidManifest.xml 文件后，重新安装两个应用即可。 现在不仅是 ProviderTest 程序，任何一个程序都可以轻松访问 DatabaseTest 中的数据，而且还丝毫不用担心隐私数据泄漏的问题。 ","link":"https://Petrichoroo.github.io/post/lesslessdi-yi-xing-dai-ma-androidgreatergreater-bi-ji-nei-rong-ti-gong-qi/"},{"title":"《第一行代码 Android》笔记 — 持久化技术","content":" 持久化技术 持久化技术简介 文件存储 将数据存储到文件中 从文件中读取数据 SharedPreferences 存储 将数据存储到 SharedPreferences 中 从 SharedPreferences 中读取数据 SQLite 数据库存储 创建数据库 升级数据库 普通写法 最佳写法 添加数据 更新数据 删除数据 查询数据 使用 SQL 语句操作数据库 使用 LitePal 操作数据库 创建和升级数据库 添加数据 更新数据 删除数据 查询数据 持久化技术 持久化技术简介 数据持久化就是指将那些内存中的瞬时数据保存到存储设备中，保证即使在手机或电脑关机的情况下，这些数据仍然不会丢失。保存在内存中的数据是处于瞬时状态的，而保存在存储设备中的数据是处于持久状态的，持久化技术则提供了一种机制可以让数据在瞬时状态和持久状态之间进行转换。 Android 系统中主要提供了 3 种方式用于简单地实现数据持久化功能，即文件存储、SharedPreferences 存储以及数据库存储。 文件存储 文件存储是 Android 中最基本的一种数据存储方式，它不对存储的内容进行任何的格式化处理，所有数据都是原封不动地保存到文件当中的，因而它比较适合用于存储一些简单的文本数据或二进制数据。 将数据存储到文件中 Context类中提供了一个openFileOutput()方法，可以用于将数据存储到指定的文件中。 第一个参数是文件名，在文件创建的时候使用的就是这个名称，注意这里指定的文件名不可以包含路径。 第二个参数是文件的操作模式，主要有两种模式可选，MODE_PRIVATE和MODE_APPEND。 MODE_PRIVATE 是默认的操作模式，表示当指定同样文件名的时候，所写入的内容将会覆盖原文件中的内容。 MODE_APPEND 则表示如果该文件已存在，就往文件里面追加内容，不存在就创建新文件。 openFileOutput()方法返回的是一个FileOutputStream对象，得到这个对象之后就可以使用 Java 流的方式将数据写入文件中了。 我们在 MainActivity 中编写一个save()方法，其作用是把输入的内容存储到文件中，文件命名为 data。然后重写了onDestroy()方法，这样就可以保证在活动销毁之前一定会调用这个方法。代码如下所示： /** 将数据写到文件中（输出流） openFileOutput() 返回 FileOutputStream 对象 借助其构建 OutputStreamWriter 对象 最后借助OutputStreamWriter构建出一个BufferedWriter对象 将文本写入字符输出流 输出到文件中 */ public void save(String inputText) { //输入输出流声明在外面 FileOutputStream out = null; //字节输出流 BufferedWriter writer = null; //字符输出流 try { out = openFileOutput(&quot;data&quot;, Context.MODE_PRIVATE); //OutputStreamWriter 字节字符转换流 //把对象包装在对应的BufferedWriter中 获得最高效率 并且也避免了频繁的调用转换器 writer = new BufferedWriter(new OutputStreamWriter(out)); writer.write(inputText); } catch (IOException e) { e.printStackTrace(); } finally { if (writer != null) { try { writer.close(); } catch (IOException e) { e.printStackTrace(); } } } } //保证在活动销毁之前一定会调用这个方法 @Override protected void onDestroy() { super.onDestroy(); String inputText = edit.getText().toString(); //获取用户输入的文本信息 save(inputText); } 这样我们就把用户输入的内容保存到文件中了。可以借助 Device File Explorer 工具查看一下。这个工具一般在 Android Studio 的右侧边栏当中，在 /data/data/ 包名 /files/ 目录下可以看到已经生成了一个 data 文件。 从文件中读取数据 类似于将数据存储到文件中，Context 类中还提供了一个openFileInput()方法，用于从文件中读取数据。这个方法要比openFileOutput()简单一些，它只接收一个参数，即要读取的文件名。 同样地，我们在 MainActivity 中编写一个load()方法来读取文件中存储的文本内容。代码如下所示： /** 从文件中读取数据（输入流） openFileInput() 返回 FileInputStream 对象 借助其构建 InputStreamReader 对象 最后借助 InputStreamReader 构建出一个 BufferReader 对象 从字符输入流中读取文本 */ public String load() { FileInputStream in = null; //文件输入流 从文件系统的某个文件中获取输入字节 BufferedReader reader = null; //字符缓冲流 StringBuilder content = new StringBuilder(); try { in = openFileInput(&quot;data&quot;); reader = new BufferedReader(new InputStreamReader(in)); String line = &quot;&quot;; //读一行文字并返回该行字符 若读到文件末尾 则返回null while ((line = reader.readLine()) != null) { content.append(line); } } catch (IOException e) { e.printStackTrace(); } finally { if (reader != null) { try { reader.close(); } catch (IOException e) { e.printStackTrace(); } } return content.toString(); } } 若读取过程中没有产生异常，调用方就成功接收到了load()方法返回的字符串，即所读取文件中存储的文本内容。 SharedPreferences 存储 不同于文件的存储方式，SharedPreferences是使用键值对的方式来存储数据的。也就是说，当保存一条数据的时候，需要给这条数据提供一个对应的键，这样在读取数据的时候就可以通过这个键把相应的值取出来。 而且 SharedPreferences 还支持多种不同的数据类型存储。 Android 中主要提供了以下两种方法用于得到SharedPreferences对象。 Context 类中的getSharedPreferences()方法。 此方法接收两个参数：第一个参数用于指定SharedPreferences文件的名称，如果指定的文件不存在则会创建一个。第二个参数用于指定操作模式，目前只有默认的MODE_PRIVATE这一种模式可选，它和直接传入 0 的效果是相同的，表示只有当前的应用程序才可以对这个 SharedPreferences 文件进行读写。其他几种操作模式均已被废弃。 Activity 类中的getPreferences()方法 这个方法和 Context 中的getSharedPreferences()方法很相似，不过它只接收一个操作模式参数，因为使用这个方法时会自动将当前 Activity 的类名作为 SharedPreferences 的文件名。 原来还有一种方式：PreferenceManager 类中的getDefaultSharedPreferences()方法。它接收一个 Context 参数，并自动使用当前应用程序的包名作为前缀来命名 SharedPreferences 文件。只不过在在 API 29 中已经被弃用。 将数据存储到 SharedPreferences 中 得到了 SharedPreferences 对象之后，就可以开始向 SharedPreferences 文件中存储数据了，主要可以分为 3 步实现。 调用 SharedPreferences 对象的edit()方法获取一个SharedPreferences.Editor对象。 向 SharedPreferences.Editor 对象中添加数据，添加一个布尔型数据就使用putBoolean()方法，添加一个字符串则使用putString()方法，以此类推。 调用apply()方法将添加的数据提交，从而完成数据存储操作。 接下来我们给按钮注册一个点击事件，用于将一些数据存储到 SharedPreferences 文件当中。修改 MainActivity 中的代码，如下所示： Button saveData = findViewById(R.id.save_data); saveData.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { SharedPreferences.Editor editor = getSharedPreferences(&quot;data&quot;, MODE_PRIVATE).edit(); editor.putString(&quot;name&quot;, &quot;Tom&quot;); editor.putInt(&quot;age&quot;, 28); editor.putBoolean(&quot;married&quot;, false); editor.apply(); } }); 这里我们向对象中添加了 3 条不同类型的数据，最后调用apply()方法进行提交，从而完成了数据存储的操作。 同样地，我们可以借助 Device File Explorer 来进行查看，进入到 /data/data/ 包名 /shared_prefs/目录下，可以看到生成了一个data.xml文件。 从 SharedPreferences 中读取数据 SharedPreferences 对象中提供了一系列的 get 方法，用于读取存储的数据，每种 get 方法都对应了 SharedPreferences.Editor 中的一种 put 方法。 这些 get 方法都接收两个参数：第一个参数是键，传入存储数据时所使用的键就可以得到相应的值；第二个参数是默认值，表示当传入的键找不到对应的值时就会以默认值进行返回。 同样地，我们增加一个还原数据的按钮，为其注册一个点击事件，希望通过点击这个按钮来从 SharedPreferences 文件中读取数据。修改 MainActivity 中的代码，如下所示： Button restoreData = findViewById(R.id.restore_data); restoreData.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { SharedPreferences pref = getSharedPreferences(&quot;data&quot;, MODE_PRIVATE); String name = pref.getString(&quot;name&quot;, &quot;&quot;); int age = pref.getInt(&quot;age&quot;, 0); boolean married = pref.getBoolean(&quot;married&quot;, false); Log.d(&quot;MainActivity&quot;, &quot;name is &quot; + name); Log.d(&quot;MainActivity&quot;, &quot;age is&quot; + age); Log.d(&quot;MainActivity&quot;, &quot;married is&quot; + married); } }); 这里我们先得到了SharedPreferences对象，然后分别调用它的getString()、getInt()和getBoolean()方法，去获取前面所存储的姓名、年龄和是否已婚，最后通过 Log 打印出来。 SQLite 数据库存储 SQLite 是一款轻量级的关系型数据库，它的运算速度非常快，占用资源很少，因而特别适合在移动设备上使用。SQLite 不仅支持标准的 SQL 语法，还遵循了数据库的 ACID 事务。 前面我们所使用的文件存储和 SharedPreferences 存储毕竟只适用于保存一些简单的数据和键值对，当需要存储大量复杂的关系型数据的时候，就会发现以上两种存储方式很难应付得了。但是使用数据库就可以做得到。 Android 为了让我们能够更加方便地管理数据库，专门提供了一个SQLiteOpenHelper帮助类，借助这个类可以非常简单地对数据库进行创建和升级。 SQLiteOpenHelper是一个抽象类，这意味着如果我们想要使用它，就需要创建一个自己的帮助类去继承它。SQLiteOpenHelper 中有两个抽象方法：onCreate()和onUpgrade()。我们必须在自己的帮助类里重写这两个方法，然后分别在这两个方法中实现创建和升级数据库的逻辑。 SQLiteOpenHelper中还有两个非常重要的实例方法，它们都可以创建或打开一个现有的数据库（如果数据库已存在则直接打开，否则要创建一个新的数据库），并返回一个可对数据库进行读写操作的对象。这两个方法不同的是，当数据库不可写入的时候（如磁盘空间已满）： getReadableDatabase()：此方法返回的对象将以只读的方式打开数据库 getWritableDatabase()：将出现异常。 SQLiteOpenHelper中有两个构造方法可供重写，一般使用参数少一点的那个构造方法即可。这个构造方法中接收 4 个参数： 第一个参数是Context，必须有它才能对数据库进行操作。 第二个参数是数据库名，创建数据库时使用的就是这里指定的名称。 第三个参数允许我们在查询数据的时候返回一个自定义的Cursor，一般传入 null 即可。 第四个参数表示当前数据库的版本号，可用于对数据库进行升级操作。 构建出SQLiteOpenHelper的实例之后，再调用上面的两个方法方法就能够创建数据库了，数据库文件会存放在/data/data/包名/databases/目录下。此时，重写的onCreate()方法也会得到执行，所以通常会在这里处理一些创建表的逻辑。 创建数据库 这里我们希望创建一个名为 BookStore.db 的数据库，然后在这个数据库中新建一张 Book 表，表中有 id（主键）、作者、价格、页数和书名等列。 新建MyDatabaseHelper类继承自SQLiteOpenHelper，代码如下所示： public class MyDatabaseHelper extends SQLiteOpenHelper { public static final String CREATE_BOOK = &quot;create table Book (&quot; + &quot;id integer primary key autoincrement, &quot; + &quot;author text, &quot; + &quot;price real, &quot; + &quot;pages integer, &quot; + &quot;name text)&quot;; private Context mContext; public MyDatabaseHelper(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) { super(context, name, factory, version); mContext = context; } @Override public void onCreate(SQLiteDatabase sqLiteDatabase) { sqLiteDatabase.execSQL(CREATE_BOOK); } @Override public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) { } } 这里把建表语句定义成了一个字符串变量，然后在onCreate()方法中又调用了 SQLiteDatabase 的execSQL()方法去执行这条建表语句，这样就可以保证在数据库创建完成的同时还能成功创建 Book 表。 SQLite 不像其他的数据库拥有众多繁杂的数据类型，它的数据类型很简单：integer 表示整型，real 表示浮点型，blob 表示二进制类型等。在上述建表语句中，我们还使用了primary key将 id 列设为主键，并用autoincrement关键字表示 id 列是自增长的。 然后我们在布局文件中加入一个按钮，为其注册点击事件，用于创建数据库。修改 MainActivity 中的代码，如下所示： public class MainActivity extends AppCompatActivity { private MyDatabaseHelper dbHelper; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); dbHelper = new MyDatabaseHelper(this, &quot;BookStore.db&quot;, null, 1); Button createDatabase = findViewById(R.id.create_database); createDatabase.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { dbHelper.getWritableDatabase(); } }); } } 这里构建了一个MyDatabaseHelper对象，并通过构造函数的参数将数据库名指定为 BookStore.db，版本号指定为 1，然后在按钮的点击事件里里调用了getWritableDatabase()方法，由于当前程序中并没有 BookStore.db 这个数据库，于是会创建该数据库并调用 MyDatabaseHelper 中的onCreate()方法，这样 Book 表也就得到了创建。 如何才能看到我们所创建的数据库呢？这里我们仍然还是可以使用 Device File Explorer，但是这个工具最多只能看到 databases 目录下出现了一个 BookStore.db 文件，是无法查看 Book 表的。 此书第二版介绍的方法是通过使用 adb shell 来对数据库和表的创建情况进行检查，网上有很多相关教程。第三版介绍的方法是使用 Database Navigator 插件，可通过 File-&gt;Settings-&gt;Plugins 路径进入官方的插件市场进行下载，使用方法比较简单，网上也有很多教程。 升级数据库 普通写法 目前项目中已经有一张 Book 表用于存放书的各种详细数据，下面我们想再添加一张Category表用于记录图书的分类。修改 MyDatabaseHelper 中的代码，如下所示： public class MyDatabaseHelper extends SQLiteOpenHelper { ... public static final String CREATE_CATEGORY = &quot;create table Category(&quot; + &quot;id integer primary key autoincrement,&quot; + &quot;category_name text,&quot; + &quot;category_code integer)&quot;; private Context mContext; public MyDatabaseHelper(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) { super(context, name, factory, version); mContext = context; } @Override public void onCreate(SQLiteDatabase sqLiteDatabase) { ... sqLiteDatabase.execSQL(CREATE_CATEGORY); } @Override public void onUpgrade(SQLiteDatabase sqLiteDatabase, int i, int i1) { sqLiteDatabase.execSQL(&quot;drop table if exists Book &quot;); //表存在则删除 sqLiteDatabase.execSQL(&quot;drop table if exists Category&quot;); onCreate(sqLiteDatabase); } } 首先我们添加了一条新的建表语句，并在 onCreate() 方法中执行，然后在onUpgrade()方法中执行了两条 DROP 语句，如果发现数据库中已经存在 Book 表或 Category 表，就将这两张表删除，然后调用 onCreate() 方法重新创建。 假若在这里我们不去使用 onUpgrade() 方法来更新数据库，而是仅在 onCreate() 方法中执行sqLiteDatabase.execSQL(CREATE_CATEGORY)，是无法成功创建 Category 表的。因为我们之前已经创建好了 BookStore.db 数据库，之后不管我们怎样点击创建按钮，onCreate()方法都不会再次执行，因此新添加的表也就无法得到创建了。除非你卸载程序。然后重新安装运行。 最后我们需要去修改 SQLiteOpenHelper 的构造方法里接收的第四个参数，它表示当前数据库的版本号，由于之前传入的是 1，这里传入一个比 1 大的数即可，然后onUpgrade()方法就可以得到执行了，如下所示： dbHelper = new MyDatabaseHelper(this, &quot;BookStore.db&quot;, null, 2); 最佳写法 上面升级数据库的方式其实是非常粗暴的，为了保证数据库中的表是最新的，我们只是简单地在onUpgrade()方法中删除掉了当前所有的表，然后强制重新执行了一遍onCreate()方法。 想象以下场景，比如你编写的某个应用已经成功上线了，并且还拥有了不错的下载量。现在由于添加了新功能，数据库需要一起升级，结果用户更新了这个版本之后却发现以前程序中存储的本地数据全部丢失了，这是很糟糕的情况。 所以我们需要进行一些合理的控制来保证在升级数据库的时候，数据不会丢失。我们已经知道，每一个数据库版本都会对应一个版本号，当指定的数据库版本号大于当前数据库版本号的时候，就会进入onUpgrade()方法中执行更新操作。 这里需要为每一个版本号赋予其所对应的数据库变动，然后在 onUpgrade() 方法中对当前数据库的版本号进行判断，再执行相应的改变。 可以看到，onUpgrade()方法中，后面两个参数是我们之前没有用到的，它们分别代表着数据库的旧版本号以及新版本号。 下面我们来模拟一个数据库升级的案例，还是由 MyDatabaseHelper 类对数据库进行管理。第1版的程序要求非常简单，只需要创建一张Book表。代码如下所示： public class MyDatabaseHelper extends SQLiteOpenHelper { public static final String CREATE_BOOK = &quot;create table Book (&quot; + &quot;id integer primary key autoincrement, &quot; + &quot;author text, &quot; + &quot;price real, &quot; + &quot;pages integer, &quot; + &quot;name text)&quot;; private Context mContext; public MyDatabaseHelper(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) { super(context, name, factory, version); mContext = context; } @Override public void onCreate(SQLiteDatabase sqLiteDatabase) { sqLiteDatabase.execSQL(CREATE_BOOK); } @Override public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) { } } 不过，几星期之后又有了新需求，这次需要向数据库中再添加一张Category表。于是，修改 MyDatabaseHelper 中的代码，如下所示： public class MyDatabaseHelper extends SQLiteOpenHelper { ... public static final String CREATE_CATEGORY = &quot;create table Category(&quot; + &quot;id integer primary key autoincrement,&quot; + &quot;category_name text,&quot; + &quot;category_code integer)&quot;; private Context mContext; public MyDatabaseHelper(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) { super(context, name, factory, version); mContext = context; } @Override public void onCreate(SQLiteDatabase sqLiteDatabase) { sqLiteDatabase.execSQL(CREATE_BOOK); sqLiteDatabase.execSQL(CREATE_CATEGORY); } @Override public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) { if(oldVersion &lt;= 1){ sqLiteDatabase.execSQL(CREATE_CATEGORY); } } } 可以看到，在onCreate()方法里我们新增了一条建表语句，然后又在onUpgrade()方法中添加了一个 if 判断，如果用户数据库的旧版本号小于等于 1，就只会创建一张 Category 表。 这样若用户直接安装第 2 版的程序，就会进入onCreate()方法，将两张表一起创建。而当用户使用第 2 版的程序覆盖安装第 1 版的程序时，就会进入升级数据库的操作中，此时由于 Book 表已经存在了，因此只需要创建一张 Category 表即可。 但是没过多久，新的需求又来了，这次要给 Book 表和 Category 表之间建立关联，需要在 Book 表中添加一个category_id字段。再次修改 MyDatabaseHelper 中的代码，如下所示： public class MyDatabaseHelper extends SQLiteOpenHelper { public static final String CREATE_BOOK = &quot;create table Book(&quot; + &quot;id integer primary key autoincrement,&quot; + &quot;author text,&quot; + &quot;price real,&quot; + &quot;pages integer,&quot; + &quot;name text,&quot; + &quot;category_id integer)&quot;; //添加新字段 ... private Context mContext; public MyDatabaseHelper(@Nullable Context context, @Nullable String name, @Nullable SQLiteDatabase.CursorFactory factory, int version) { super(context, name, factory, version); mContext = context; } @Override public void onCreate(SQLiteDatabase sqLiteDatabase) { sqLiteDatabase.execSQL(CREATE_BOOK); sqLiteDatabase.execSQL(CREATE_CATEGORY); } @Override public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) { if(oldVersion &lt;= 1){ sqLiteDatabase.execSQL(CREATE_CATEGORY); } if(oldVersion &lt;= 2){ sqLiteDatabase.execSQL(&quot;alter table Book add column category_id integer&quot;); } } } 首先我们在 Book 表的建表语句中添加了一个category_id列，这样当用户直接安装第 3 版的程序时（不会进入到 onUpdate() 方法中），这个新增的列就已经自动添加成功了。然而，如果用户之前已经安装了某一版本的程序，现在需要覆盖安装，就会进入升级数据库的操作中。在 onUpgrade() 方法里，我们添加了一个新的条件，若当前数据库的版本号是 2，就会执行alter命令，为 Book 表新增一个 category_id 列。 每当升级一个数据库版本的时候，onUpgrade()方法里都会写一个相应的 if 判断语句。这是为了保证 App 在跨版本升级的时候，每一次的数据库修改都能被全部执行。比如用户当前是从第 2 版升级到第 3 版，那么只有第二条判断语句会执行，而如果用户是直接从第 1 版升级到第 3 版，那么两条判断语句都会执行。使用这种方式来维护数据库的升级，不管版本怎样更新，都可以保证数据库的表结构是最新的，而且表中的数据完全不会丢失。 添加数据 SQLiteDatabase中提供了一个insert()方法，用于添加数据，它接收 3 个参数： 第一个参数是表名。 第二个参数用于在未指定添加数据的情况下给某些可为空的列自动赋值 NULL ，一般我们用不到这个功能，直接传入 null 即可。 第三个参数是一个ContentValues对象，它提供了一系列的put()方法重载，用于向 ContentValues 中添加数据，只需要将表中的每个列名以及相应的待添加数据传入即可。 添加一个按钮，用于向数据库里添加数据，并为其注册点击事件，修改 MainActivity 中的代码，如下所示： Button addData = findViewById(R.id.add_data); addData.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { SQLiteDatabase db = dbHelper.getWritableDatabase(); ContentValues values = new ContentValues(); //开始组装第一条数据 values.put(&quot;name&quot;, &quot;The Da Vinci Code&quot;); values.put(&quot;author&quot;, &quot;Dan Brown&quot;); values.put(&quot;pages&quot;, 454); values.put(&quot;price&quot;, 16.96); db.insert(&quot;Book&quot;, null, values); //插入第一条数据 values.clear(); //开始组装第二条数据 values.put(&quot;name&quot;, &quot;The Lost Symbol&quot;); values.put(&quot;author&quot;, &quot;Dan Brown&quot;); values.put(&quot;pages&quot;, 510); values.put(&quot;price&quot;, 19.95); db.insert(&quot;Book&quot;, null, values); } }); 这里我们先获取了SQLiteDatabase对象，然后使用ContentValues对要添加的数据进行组装，最后使用insert()方法将数据添加到表当中。注意，在前面创建表的时候，我们将id列设置为自增长了，它的值会在入库的时候自动生成。 更新数据 SQLiteDatabase中提供了一个update()方法，用于对数据进行更新，这个方法接收 4 个参数： 第一个参数是表名。 第二个参数是ContentValues对象，要把更新数据在这里组装进去。 第三、第四个参数用于约束更新某一行或某几行中的数据，不指定的话默认会更新所有行。 添加一个用于更新数据的按钮，并为其注册点击事件，修改 MainActivity 中的代码，如下所示： Button updateData = findViewById(R.id.update_data); updateData.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { SQLiteDatabase db = dbHelper.getWritableDatabase(); ContentValues values = new ContentValues(); values.put(&quot;price&quot;, 10.99); db.update(&quot;Book&quot;, values, &quot;name = ?&quot;, new String[]{&quot;The Da Vinci Code&quot;}); } }); 这里使用了第三、第四个参数来指定具体更新哪几行。第三个参数对应的是 SQL 语句的where部分，表示更新所有name等于 ？的行，而 ？是一个占位符，可以通过第四个参数提供的一个字符串数组为第三个参数中的每个占位符指定相应的内容。 删除数据 SQLiteDatabase中提供了一个delete()方法，用于删除数据，这个方法接收 3 个参数： 第一个参数是表名。 第二、第三个参数用于约束删除某一行或某几行的数据，不指定的话默认就是删除所有行。 添加一个按钮，用于删除数据，并为其注册点击事件，修改 MainActivity 中的代码，如下所示： Button deleteData = findViewById(R.id.delete_data); deleteData.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { SQLiteDatabase db = dbHelper.getWritableDatabase(); db.delete(&quot;Book&quot;, &quot;pages &gt; ?&quot;, new String[]{&quot;500&quot;}); } }); 这里我们通过第二、第三个参数来指定仅删除那些页数超过 500 页的书。 查询数据 SQLiteDatabase中提供了一个query()方法用于对数据进行查询。这个方法的参数非常复杂，最短的一个方法重载也需要传入 7 个参数。 第一个参数是表名，表示我们希望从哪张表中查询数据。 第二个参数用于指定去查询哪几列，如果不指定则默认查询所有列。 第三、第四个参数用于约束查询某一行或某几行的数据，不指定则默认查询所有行的数据。 第五个参数用于指定需要去group by的列，不指定则表示不对查询结果进行group by操作。 第六个参数用于对group by之后的数据进行进一步的过滤，不指定则表示不进行过滤。 第七个参数用于指定查询结果的排序方式，不指定则表示使用默认的排序方式。 我们不必为每条查询语句都指定所有的参数，多数情况下只需要传入少数几个参数就可以完成查询操作了。调用query()方法后会返回一个Cursor对象，查询到的所有数据都将从这个对象中取出。 添加一个按钮用于查询数据，并为其注册点击事件，修改 MainActivity 中的代码， 如下所示： Button queryData = findViewById(R.id.query_data); queryData.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { SQLiteDatabase db = dbHelper.getWritableDatabase(); Cursor cursor = db.query(&quot;Book&quot;, null, null, null, null, null, null); if (cursor.moveToFirst()) { //将数据的指针移动到第一行的位置 //遍历 Cursor 对象 do { @SuppressLint(&quot;Range&quot;) String name = cursor.getString(cursor.getColumnIndex(&quot;name&quot;)); @SuppressLint(&quot;Range&quot;) String author = cursor.getString(cursor.getColumnIndex(&quot;author&quot;)); @SuppressLint(&quot;Range&quot;) int pages = cursor.getInt(cursor.getColumnIndex(&quot;pages&quot;)); @SuppressLint(&quot;Range&quot;) double price = cursor.getDouble(cursor.getColumnIndex(&quot;price&quot;)); Log.d(&quot;MainActivity&quot;, &quot;Book's name is &quot; + name); Log.d(&quot;MainActivity&quot;, &quot;Book's author is &quot; + author); Log.d(&quot;MainActivity&quot;, &quot;Book's pages is &quot; + pages); Log.d(&quot;MainActivity&quot;, &quot;Book's price is &quot; + price); } while (cursor.moveToNext()); } cursor.close(); } }); 这里的query()方法只使用了第一个参数指明查询 Book 表，后面的参数全部为 null，这就表示希望查询这张表中的所有数据。查询完成后会得到一个Cursor对象，接着我们调用它的moveToFirst()方法，将数据的指针移动到第一行的位置。接着便是如何读取数据，getColumnIndex()方法可以获取到某一列在表中对应的位置索引，然后将这个索引传入相应的取值方法中，就可以得到从数据库中读取到的数据了。最后别忘了调用close()方法来关闭 Cursor。 使用 SQL 语句操作数据库 Android 不仅提供了很多方便的 API 用于操作数据库，还同样提供了一系列的方法，使得可以直接通过 SQL 语句来操作数据库。 添加数据： db.execSQL(&quot;insert into Book (name,author,pages,price) values(?,?,?,?)&quot;, new String[] {&quot;The Da Vinci Code&quot;,&quot;Dan Brown&quot;,&quot;454&quot;,&quot;16.96&quot;}); db.execSQL(&quot;insert ioto Book (name,author,pages,price) values(?,?,?,?)&quot;, new String[] {&quot;The Lost Symbol&quot;,&quot;Dan Brown&quot;,&quot;510&quot;,&quot;19.95&quot;}); 更新数据： db.execSQL(&quot;update Book set price = ? where name = ? &quot;, new String[]{&quot;10.99&quot;,&quot;The Da Vinci Code&quot; }); 删除数据： db.execSQL(&quot;delete from Book where pages &gt; ? &quot;,new String[] { &quot;500&quot; }); 查询数据： db.rawQuery(&quot;select * from Book&quot;,null); 除了查询数据调用的是SQLiteDatabase的rawQuery()方法，其他的操作都是调用的execSQL()方法。 使用 LitePal 操作数据库 LitePal 是一款开源的 Android 数据库框架，它采用了对象关系映射（ORM）的模式，并将我们平时开发最常用到的一些数据库功能进行了封装。使得不用编写 SQL 语句就可以完成各种建表和増删改查的操作。(这个开源库是此书作者开发维护的) 使用 LitePal 的第一步，就是编辑 app/build.gradle 文件，在 dependencies 闭包中添加如下内容： dependencies { implementation 'org.litepal.guolindev:core:3.2.3' } 记得sync，接下来需要配置litepal.xml文件。右击 app/src/main 目录→New→Directory，创建一个assets目录，然后在 assets 目录右击 →New→File 再新建一个 litepal.xml 文件（.xml后缀要保留），接着编辑 litepal.xml 文件中的内容，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; &lt;litepal&gt; &lt;dbname value=&quot;BookStore&quot;&gt;&lt;/dbname&gt; &lt;version value=&quot;1&quot;&gt;&lt;/version&gt; &lt;list&gt; &lt;/list&gt; &lt;/litepal&gt; 其中，&lt;dbname&gt;标签用于指定数据库名，&lt;version&gt;标签用于指定数据库版本号，&lt;list&gt;标签用于指定所有的映射模型。 最后，还需要再配置一下LitePalApplication，修改 AndroidManifest.xml 中的代码，如下所示： &lt;application android:name=&quot;org.litepal.LitePalApplication&quot; ... &lt;/application&gt; 将项目的 application 配置为org.litepal.LitePalApplication，这样才能让 LitePal 的所有功能都可以正常工作。 创建和升级数据库 之前创建数据库是通过自定义一个类继承自SQLiteOpenHelper，然后在onCreate()方法中编写建表语句来实现的，而使用 LitePal 就不用再这么麻烦了。 LitePal 采取的是对象关系映射（ORM）的模式，对象关系映射，简单点说，我们使用的编程语言是面向对象语言，而使用的数据库则是关系型数据库，那么将面向对象的语言和面向关系的数据库之间建立一种映射关系，这就是对象关系映射了。 对象关系映射模式，它赋予了我们一个强大的功能，就是可以用面向对象的思维来操作数据库，而不用再和 SQL 语句打交道了。 定义一个 Book 类，代码如下所示： public class Book extends { private int id; private String author; //作者 private double price; //价格 private int pages; //书页 private String name; //书名 public int getId() { return id; } public void setId(int id) { this.id = id; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public double getPrice() { return price; } public void setPrice(double price) { this.price = price; } public int getPages() { return pages; } public void setPages(int pages) { this.pages = pages; } public String getName() { return name; } public void setName(String name) { this.name = name; } } 这是一个典型的 Java bean，在 Book 类中定义了id、author、price、pages、name这几个字段，并生成了相应的getter和setter方法。Book 类就会对应数据库中的 Book 表，而类中的每一个字段分别对应了表中的每一个列，这就是对象关系映射最直观的体验。 接下来我们还需要将 Book 类添加到映射模型列表当中，修改litepal.xml中的代码，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; &lt;litepal&gt; &lt;dbname value=&quot;BookStore&quot;&gt;&lt;/dbname&gt; &lt;version value=&quot;1&quot;&gt;&lt;/version&gt; &lt;list&gt; &lt;mapping class=&quot;com.example.litepaltest.Book&quot;&gt;&lt;/mapping&gt; &lt;/list&gt; &lt;/litepal&gt; 这里使用&lt;mapping&gt;标签来声明要配置的映射模型类，注意一定要使用完整的类名。不管有多少模型类需要映射，都使用同样的方式配置在&lt;list&gt;标签下即可。 现在只要进行任意一次数据库的操作，BookStore.db 数据库应该就会自动创建出来。那么我们修改 MainActivity 中的代码，如下所示： Button createDatabase = findViewById(R.id.create_database); createDatabase.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Connector.getDatabase(); } }); 调用Connector.getDatabase()方法就是一次最简单的数据库操作，只要点击一下按钮，数据库就会自动创建完成了。 使用 LitePal 来升级数据库也很简单，不用思考任何的复杂逻辑，只需要改你想改的任何内容，然后将版本号加 1 就行了。比如我们想要向 Book 表中添加一个 press（出版社）列，直接修改 Book 类中的代码，添加一个 press 字段即可，如下所示： public class Book { ... private String press; public String getPress() { return press; } public void setPress(String press) { this.press = press; } 与此同时，我们还想再添加一张 Category 表，那么只需要新建一个 Category 类就可以了，代码如下所示： public class Category { private int id; private String categoryName; private String categoryCode; public void setId(int id) { this.id = id; } public void setCategoryName(String categoryName) { this.categoryName = categoryName; } public void setCategoryCode(String categoryCode) { this.categoryCode = categoryCode; } } 修改完成后只需要记得将版本号加 1 就行了。当然由于这里还添加了一个新的模型类，因此也需要将它添加到映射模型列表中。修改 litepal.xml 中的代码，如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; &lt;litepal&gt; &lt;dbname value=&quot;BookStore&quot;&gt;&lt;/dbname&gt; &lt;version value=&quot;2&quot;&gt;&lt;/version&gt; &lt;list&gt; &lt;mapping class=&quot;com.example.litepaltest.Book&quot;&gt;&lt;/mapping&gt; &lt;mapping class=&quot;com.example.litepaltest.Category&quot;&gt;&lt;/mapping&gt; &lt;/list&gt; &lt;/litepal&gt; 然后重新运行一下程序，点击 Create database 按钮，你会发现 book 表中新增了一个 press 列，category 表也创建成功了，当然 LitePal 还自动帮我们做了一项非常重要的工作，就是保留之前表中的所有数据，这样就不用担心数据丢失的问题了。 添加数据 使用 LitePal 添加数据，只需要创建出模型类的实例，再将所有要存储的数据设置好，最后调用一下save()方法即可。 观察现有的模型类，你会发现它们都是没有继承结构的。因为 LitePal 进行表管理操作时不需要模型类有任何的继承结构，但是进行 CRUD 操作时就不行了，必须要继承自 LitePalSupport 类，因此这里我们需要先把继承结构加上。修改Book类中的代码，如下所示： public class Book extends LitePalSupport { ... } 然后向 Book 表中添加数据，修改 MainActivity 中的代码，如下所示： Button addData = findViewById(R.id.add_data); addData.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Book book = new Book(); book.setName(&quot;The Da Vinci Code&quot;); book.setAuthor(&quot;Dan Brown&quot;); book.setPages(454); book.setPrice(16.86); book.setPress(&quot;Unknow&quot;); book.save(); } }); 调用 Book 类中的各种set方法对数据进行设置，最后再调用book.save()方法就能完成数据添加操作，这个save()方法是从LitePalSupport类中继承而来的。 更新数据 最简单的一种更新方式就是对已存储的对象重新设值，然后重新调用save()方法即可。对于 LitePal 来说，对象是否已存储就是根据调用.isSaved()方法的结果来判断的，返回true就表示已存储，返回false就表示未存储。 只有在两种情况下model.isSaved()方法才会返回 true。 已经调用过model.save()方法去添加数据了，此时 model 会被认为是已存储的对象。 model 对象是通过 LitePal 提供的查询 API 查出来的，由于是从数据库中查到的对象，因此也会被认为是已存储的对象。 添加一个按钮，用于更新数据，并为其注册点击事件，代码如下所示： Button updateData = findViewById(R.id.update_data); updateData.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Book book = new Book(); book.setName(&quot;The Lost Symbol&quot;); book.setAuthor(&quot;Dan Brown&quot;); book.setPages(510); book.setPrice(19.95); book.setPress(&quot;UnKnow&quot;); book.save(); book.setPrice(24.2); //修改价格 book.save(); } }); 这里调用setPrice()方法修改了这本书的价格，之后再次调用了save()方法。此时 LitePal 会发现当前的 Book 对象是已存储的，因此不会再向数据库中去添加一条新数据，而是会直接更新当前的数据。 但是这种更新方式只能对已存储的对象进行操作，限制性比较大，下面我们使用另外一种更加灵巧的更新方式。修改 MainActivity 中的代码，如下所示： Button updateData = findViewById(R.id.update_data); updateData.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { Book book = new Book(); book.setPrice(14.95); book.setPress(&quot;Anchor&quot;); book.updateAll(&quot;name = ? and author = ?&quot;, &quot;The Lost Symbol&quot;, &quot;Dan Brown&quot;); } }); 这里调用setPrice()和setPress()方法来设置要更新的数据，最后再调用updateAll()方法去执行更新操作。注意 updateAll() 方法中可以指定一个条件约束，如果不指定条件语句的话，就表示更新所有数据。 需要注意的是，对于所有想要把数据更新成默认值的操作，LitePal 统一提供了一个setToDefault()方法，然后传入相应的列名就可以实现了，如下所示： Book book = new Book(); book.setToDefault(&quot;pages&quot;); book.updateAll(); 这里将所有书的页数都更新为 0，因为updateAll()方法中没有指定约束条件，因此更新操作对所有数据都生效了。 删除数据 添加一个按钮，用于删除数据，并为其注册点击事件，代码如下所示： Button deleteData = findViewById(R.id.delete_data); deleteData.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { LitePal.deleteAll(Book.class, &quot;price &lt; ?&quot;, &quot;15&quot;); } }); 这里调用了LitePal.deleteAll()方法来删除数据，其中 deleteAll() 方法的第一个参数用于指定删除哪张表中的数据，后面的参数用于指定约束条件。 查询数据 LitePal 在查询 API 方面做了非常多的优化，基本上可以满足绝大多数场景的查询需求，并且代码十分整洁。比如我要去查询 Book 表中的数据，代码如下所示： List&lt;Book&gt; books = LitePal.findAll(Book.class); findAll()方法的返回值是一个 Book 类型的List集合，也就是说，我们不用像之前那样再通过 Cursor 对象一行行去取值了，LitePal 已经自动帮我们完成了赋值操作。然后我们就可以通过调用 Book 类中的一系列 getter 方法来得到相关数据。 除了 findAll() 方法之外，LitePal 还提供了很多其他非常有用的查询 API，如： 查询 Book 表中的第一条数据： Book firstBook = LitePal.findFirst(Book.class); 查询 Book 表中的最后一条数据： Book lastBook = LitePal.findLast(Book.class); 还可以通过连缀查询来定制更多的查询功能，如 select()方法用于指定查询哪几列的数据，比如只查 name 和 author这两列的数据： List&lt;Book&gt; books = LitePal.select(&quot;name&quot;,&quot;author&quot;).find(Book.class); where()方法用于指定查询的约束条件，比如只查页数大于 400 的数据： List&lt;Book&gt; books = LitePal.where(&quot;pages &gt; ?&quot;,&quot;400&quot;).find(Book.class); order()方法用于指定结果的排序方式，比如将查询结果按照书价从高到低排序： List&lt;Book&gt; books = LitePal.order(&quot;price desc&quot;).find(Book.class); 其中desc表示降序排列，asc或者不写表示升序排列。 limit()方法用于指定查询结果的数量，比如只查表中的前 3 条数据： List&lt;Book&gt; books = LitePal.limit(3).find(Book.class); offset()方法用于指定查询结果的偏移量，比如查询表中的第 2 条、第 3 条、第 4 条数据： List&lt;Book&gt; books = LitePal.limit(3).offset(1).find(Book.class); &amp;msp;当然，你还可以对这 5 个方法进行任意的连缀组合，来完成一个比较复杂的查询操作，比如： List&lt;Book&gt; books = LitePal.select(&quot;name&quot;,&quot;author&quot;,&quot;pages&quot;) .where(&quot;pages &gt; ?&quot;.&quot;400&quot;) .order(&quot;pages&quot;) .limit(10) .offset(10) .find(Book.class); 这段代码就表示，查询 Book 表中第 11～20 条满足页数大于 400 这个条件的 name、author 和 pages 这 3 列数据，并将查询结果按照页数升序排列。 LitePal 仍然支持使用原生的 SQL 来进行查询，比如： Cursor c = LitePal.findBySQL(&quot;select * from Book where pages &gt; ? and price &lt; ? &quot;,&quot;400&quot;,&quot;20&quot;); 调用LitePal.findBySQL()方法来进行原生查询，其中第一个参数用于指定 SQL 语句，后面的参数用于指定占位符的值。 ","link":"https://Petrichoroo.github.io/post/lesslessdi-yi-xing-dai-ma-androidgreatergreater-bi-ji-chi-jiu-hua-ji-zhu/"},{"title":"《第一行代码 Android》笔记 — Broadcast","content":" Broadcast 广播机制简介 接收系统广播 动态注册监听网络变化 静态注册实现开机启动 发送自定义广播 发送标准广播 发送有序广播 使用本地广播 Broadcast 广播机制简介 Android 中的每个应用程序都可以对自己感兴趣的广播进行注册，这样该程序就只会收到自己所关心的广播内容，这些广播可能是来自于系统的，也可能是来自于其他应用程序的。Android 提供了一套完整的 API，允许应用程序自由地发送和接收广播。 Android中 的广播主要可以分为两种类型：标准广播和有序广播。 标准广播是一种完全异步执行的广播，在广播发出之后，所有的 BroadcastReceiver 几乎会在同一时刻收到这条广播消息，因此它们之间没有任何先后顺序可言。这种广播的效率会比较高，但同时也意味着它是无法被截断的。 有序广播则是一种同步执行的广播，在广播发出之后，同一时刻只会有一个 BroadcastReceiver 能够收到这条广播消息，当这个BroadcastReceiver中的逻辑执行完毕后，广播才会继续传递。所以此时的 BroadcastReceiver 是有先后顺序的，优先级高的 BroadcastReceiver 就可以先收到广播消息，并且前面的 BroadcastReceiver 还可以截断正在传递的广播，这样后面的 BroadcastReceiver 就无法收到广播消息了。 接收系统广播 Android 内置了很多系统级别的广播，我们可以在应用程序中通过监听这些广播来得到系统的状态信息。广播接收器可以自由地对自己感兴趣的广播进行注册，这样当有相应的广播发出时，广播接收器就能够收到该广播，并在内部处理相应的逻辑。 注册广播的方式一般有两种，在代码中注册和在 AndroidManifest.xml 中注册，其中前者也被称为动态注册，后者也被称为静态注册。 动态注册监听网络变化 新建一个类，让它继承自BroadcastReceiver，并重写父类的onReceive()方法。这样当有广播到来时，onReceive() 方法就会得到执行，具体的逻辑就可以在这个方法中处理。代码如下： public class MainActivity extends AppCompatActivity { private IntentFilter intentFilter; private NetWorkChangeReceiver netWorkChangeReceiver; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); intentFilter = new IntentFilter(); intentFilter.addAction(&quot;android.net.conn.CONNECTIVITY_CHANGE&quot;); netWorkChangeReceiver = new NetWorkChangeReceiver(); registerReceiver(netWorkChangeReceiver,intentFilter); } @Override protected void onDestroy() { super.onDestroy(); unregisterReceiver(netWorkChangeReceiver); } class NetWorkChangeReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { Toast.makeText(context,&quot;network changes&quot;,Toast.LENGTH_SHORT).show(); } } } 这里定义了一个内部类NetworkChangeReceiver，继承自BroadcastReceiver，并重写了父类的onReceive()方法。这样每当网络状态发生变化时，onReceive() 方法就会得到执行，这里只是简单地使用 Toast 提示了一段文本信息。 这里先创建了一个IntentFilter的实例，添加了值为android.net.conn.CONNECTIVITY_CHANGE的 action。当网络状态发生变化时，系统发出的正是这条广播，也就是说我们的广播接收器想要监听什么广播，就在这里添加相应的 action。 然后创建了NetworkChangeReceiver的实例，再调用registerReceiver()方法进行注册。 这样 NetworkChangeReceiver 就会收到所有值为android.net.conn.CONNECTIVITY_CHANGE的广播，也就实现了监听网络变化的功能。 最后需要注意的是，动态注册的广播接收器一定都要取消注册才行。这里我们是在onDestroy()方法中通过调用unregisterReceiver()方法来实现的。 不过，只是提醒网络发生了变化还不够人性化，最好是能准确地告诉用户当前是有网络还是没有网络，因此我们还需要对上面的代码进行进一步的优化。修改 NetWorkChangeReceiver 中的代码，如下所示： @Override public void onReceive(Context context, Intent intent) { //得到系统服务类的实例 专门用于管理网络连接 ConnectivityManager connectionManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo networkInfo = connectionManager.getActiveNetworkInfo(); //判断当前是否有网络 if (networkInfo != null &amp;&amp; networkInfo.isAvailable()) { Toast.makeText(context, &quot;network is available&quot;, Toast.LENGTH_SHORT).show(); } else { Toast.makeText(context, &quot;network is unavailable&quot;, Toast.LENGTH_SHORT).show(); } } 这里通过getSystemService()方法得到ConnectivityManager的实例，这是一个系统服务类，专门用于管理网络连接的。然后调用它的getActiveNetworkInfo()方法可以得到NetworkInfo的实例，最后通过判断出当前是否有网络来对用户进行提示。 最后需要注意的是，访问系统的网络状态就是需要声明权限的。修改AndroidManifest.xml，如下所示： &lt;uses-permission android:name=&quot;android.permission.ACCESS_NETWORK_STATE&quot; /&gt; 静态注册实现开机启动 在Android 8.0系统之后，所有隐式广播都不允许使用静态注册的方式来接收了。隐式广播指的是那些没有具体指定发送给哪个应用程序的广播，大多数系统广播属于隐式广播，但是少数特殊的系统广播目前仍然允许使用静态注册的方式来接收。 这里我们准备让程序接收一条开机广播，在开机的时候，我们的应用程序肯定是没有启动的，因此这个功能不能使用动态注册的方式来实现，而应该使用静态注册的方式来接收开机广播，然后在onReceive()方法里执行相应的逻辑。 首先在我们的com.example.broadcasttest包下右击新建一个BroadcastReceiver，将其命名为BootCompleteReceiver，并勾选下面的两个属性，Exported表示是否允许这个BroadcastReceiver 接收本程序以外的广播，Enabled表示是否启用这个BroadcastReceiver。 然后修改 BootCompleteReceiver 中的代码，如下所示： public class BootCompleteReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { Toast.makeText(context,&quot;Boot Complete&quot;,Toast.LENGTH_SHORT).show(); } } 这里我们只是在onReceive()方法中使用 Toast 弹出一段提示信息。 另外，静态的 BroadcastReceiver 一定要在AndroidManifest.xml文件中注册才可以使用。不过目前的BootCompleteReceiver是无法收到开机广播的，我们还需要对 AndroidManifest.xml 文件进行修改，如下所示： &lt;receiver android:name=&quot;.BootCompleteReceiver&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.BOOT_COMPLETED&quot; /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 由于 Android 系统启动完成后会发出一条值为android.intent.action.BOOT_COMPLETED的广播，因此我们在&lt;receiver&gt;标签中又添加了一个&lt;intent-filter&gt;标签，并在里面声明了相应的 action。 另外接收系统的开机广播就是需要进行权限声明的，所以修改AndroidManifest.xml文件，如下所示： &lt;uses-permission android:name=&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot; /&gt; 注意不要在onReceive()方法中添加过多的逻辑或者进行任何的耗时操作，因为 BroadcastReceiver 中是不允许开启线程的，当 onReceive() 方法运行了较长时间而没有结束时，程序就会出现错误。 因此广播接收器更多的是扮演一种打开程序其他组件的角色，比如创建一条状态栏通知，或者启动一个服务等。 发送自定义广播 发送标准广播 新建一个MyBroadcastReceiver，代码如下所示： public class MyBroadcastReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { Toast.makeText(context,&quot;received in MyBroadcastReceiver&quot;,Toast.LENGTH_SHORT).show(); } } 然后在AndroidManifest.xml中对这个广播接收器进行修改： &lt;receiver android:name=&quot;.MyBroadcastReceiver&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.example.broadcasttest.MY_BROADCAST&quot;/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 这里让 MyBroadcastReceiver 接收一条值为com.example.broadcasttest. MY_BROADCAST的广播，因此待会儿在发送广播的时候，我们就需要发出这样的一条广播。 我们在布局文件中定义了一个 Button，用于作为发送广播的触发点。并为其设置点击事件，如下所示： Button myButton = findViewById(R.id.my_button); myButton.setOnClickListener(new View.OnClickListener() { //所有监听Intent中这条广播的广播接收器就会收到消息 @Override public void onClick(View view) { Intent intent = new Intent(&quot;com.example.broadcasttest.MY_BROADCAST&quot;); //属性分别是广播接收器的包名和对应的 Receiver 的路径 intent.setComponent(new ComponentName(&quot;com.example.broadcasttest&quot;, &quot;com.example.broadcasttest.MY_BROADCAST&quot;)); sendBroadcast(intent,); } }); 首先构建出了一个 Intent 对象，并把要发送的广播的值传入，注意在 Android8.0 系统之后，静态注册的 BroadcastReceiver 是无法接收隐式广播的，而默认情况下我们发出的自定义广播恰恰都是隐式广播。因此这里调用setComponent()方法指定广播是发送给哪个应用程序的，从而让它变成一条显式广播。再调用sendBroadcast()方法发送广播，这样所有监听com.example.broadcasttest.MY_BROADCAST这条广播的广播接收器就会收到消息。 发送有序广播 和标准广播不同，有序广播是一种同步执行的广播，并且是可以被截断的 修改 Button 的点击事件，如下所示： ... sendOrderedBroadcast(intent, null); //发送有序广播 sendOrderedBroadcast()方法接收两个参数，第一个参数仍然是 Intent，第二个参数是一个与权限相关的字符串，这里传入 null 就行了。 然后需要去设定广播接收器的先后顺序，修改AndroidManifest.xml中的代码，如下所示： &lt;receiver android:name=&quot;.MyBroadcastReceiver&quot; android:enabled=&quot;true&quot; android:exported=&quot;true&quot;&gt; &lt;intent-filter android:priority=&quot;100&quot;&gt; &lt;action android:name=&quot;com.example.broadcasttest.MY_BROADCAST&quot;/&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 这里通过android:priority属性给 BroadcastReceiver 设置了优先级，优先级 比较高的 BroadcastReceiver 就可以先收到广播。 既然已经获得了接收广播的优先权，那么MyBroadcastReceiver就可以选择是否允许广播继续 传递了。修改 MyBroadcastReceiver 中的代码，如下所示： @Override public void onReceive(Context context, Intent intent) { Toast.makeText(context,&quot;received in MyBroadcastReceiver&quot;,Toast.LENGTH_SHORT).show(); abortBroadcast(); //将这条广播截断 后面的广播接收器将无法再接收到这条广播 } 使用本地广播 前面我们发送和接收的广播全部属于系统全局广播，即发出的广播可以被其他任何应用程序接收到，并且我们也可以接收来自于其他任何应用程序的广播。这样就很容易引起安全性的问题，比如说我们发送的一些携带关键性数据的广播有可能被其他的应用程序截获，或者其他的程序不停地向我们的广播接收器里发送各种垃圾广播。 为了解决广播的安全性问题，Android 引入了本地广播机制，使用该机制发出的广播只能在应用程序的内部进行传递，并且广播接收器也只能接收来自本应用程序发出的广播。 需要知道的是，本地广播是无法通过静态注册的方式来接收的。我们知道静态注册主要是为了在程序未启动的情况下能接收广播，而当我们发送本地广播的时候，程序肯定是已经启动的了，所以我们需要动态注册方式创建接收器。 这里我们创建一个继承于BroadcastReceiver的LocalReceiver类，代码如下： public class LocalReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { Toast.makeText(context,&quot;Received in LocalReceiver&quot;,Toast.LENGTH_SHORT).show(); } } 接着修改 MainActivity 中的代码，如下所示： public class MainActivity extends AppCompatActivity { private IntentFilter intentFilter; private LocalReceiver localReceiver; private LocalBroadcastManager localBroadcastManager; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //获取实例 Button button = findViewById(R.id.send_button); localBroadcastManager = LocalBroadcastManager.getInstance(this); intentFilter = new IntentFilter(); intentFilter.addAction(&quot;com.example.broadcasttest.LOCAL_BROADCAST&quot;); localReceiver = new LocalReceiver(); //注册本地广播接收器 localBroadcastManager.registerReceiver(localReceiver,intentFilter); //发送广播的点击事件 button.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { Intent intent = new Intent(&quot;com.example.broadcasttest.LOCAL_BROADCAST&quot;); localBroadcastManager.sendBroadcast(intent); //发送本地广播 } }); } @Override protected void onDestroy(){ super.onDestroy(); unregisterReceiver(localReceiver); } } 首先通过LocalBroadcastManager的getInstance()方法得到了它的一个实例，然后在注册广播接收器的时候调用的是 LocalBroadcastManager 的registerReceiver()方法，在发送广播的时候调用的是 LocalBroadcastManager 的sendBroadcast()方法，仅此而已。 使用本地广播的几点优势： 可以明确地知道正在发送的广播不会离开我们的程序，因此不必担心机密数据泄漏。 其他的程序无法将广播发送到我们程序的内部，因此不需要担心会有安全漏洞的隐患。 发送本地广播比发送系统全局广播将会更加高效。 ","link":"https://Petrichoroo.github.io/post/lesslessdi-yi-xing-dai-ma-androidgreatergreater-bi-ji-broadcast/"},{"title":"《第一行代码 Android》笔记 — Fragment","content":" Fragment 基本概念 使用方式 Fragment 的简单用法 动态添加 Fragment 实现返回栈 Fragment 和 Activity 之间的交互 Fragment 的生命周期 碎片的状态和回调 fragment 生命周期示意图 动态加载布局的技巧 使用限定符 使用最小宽度限定符 Fragment 基本概念 Fragment是一种可以嵌入在 Activity 中的可重用的，模块化的 UI 片段，它能让程序更加合理和充分地利用大屏幕的空间。 使用方式 Fragment并不能单独使用，需要嵌套在 Activity 中使用。尽管它拥有自己的生命周期，但是还是会受到宿主 Activity 的生命周期的影响。 Fragment 的简单用法 自定义一个布局my_fragment.xml，用于显示相关内容。 新建一个 myFragment类，继承 Fragment 或者它的子类，重写onCreateView()方法，代码如下： @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View view = inflater.inflate(R.layout.my_fragment, container, false); return view; } 在onCreateView()方法中通过 LayoutInflater 的inflate()方法将刚才定义的my_fragment布局动态加载进来。 3. 修改activity_main.xml中的代码，添加 Fragment，如下所示： &lt;fragment android:id=&quot;@+id/my_frag&quot; android:name=&quot;com.example.fragmenttest.myFragment&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_parent&quot; /&gt; 这里使用了&lt;fragment&gt;标签在布局中添加 Fragment，需要通过android:name属性来显式声明要添加的 Fragment 类名，注意一定要将类的包名也加上。 动态添加 Fragment Fragment 真正的强大之处在于，它可以在程序运行时动态地添加到 Activity 当中。根据具体情况来动态地添加 Fragment，你就可以将程序界面定制得更加多样化。 自定义一个another_fragment.xml的布局，用于显示相关内容。 新建AnotherFragment，继承 Fragment 或者它的子类，重写onCreateView()方法，代码如下： public class AnotherFragment extends Fragment { @Nullable @Override public View onCreateView(@NonNull LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) { View view = inflater.inflate(R.layout.another_fragment,container, false); return view; } } 这里同样是通过inflate()方法将刚才定义的another_fragment布局动态加载进来。 这样我们就准备好了另一个 Fragment，接下来将它将它动态地添加到 Activity 当 中。先修改 activity_main.xml，代码如下所示： &lt;FrameLayout android:id=&quot;@+id/another_layout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_parent&quot; /&gt; 这里将另一个碎片放在一个FrameLayout中，这种布局的特点是所有的控件默认都会摆放在布局的左上角。由于这里仅需要在布局里放入一个碎片，不需要任何定位，因此非常适合使用 FrameLayout。 最后在代码中向FrameLayout里添加内容，从而实现动态添加碎片的功能。修改 MainActivity 中的代码，如下所示： //获取FragmentManager FragmentManager fragmentManager = getSupportFragmentManager(); //开启一个事务 FragmentTransaction transaction = fragmentManager.beginTransaction(); //向容器内添加或替换碎片 transaction.replace(R.id.another_layout,AnotherFragment); transaction.commit(); 可知动态添加 Fragment 主要分为 5 步： (1). 创建待添加 Fragment 的实例 (2). 获取FragmentManager，在 Activity 中可以直接调用getSupportFragmentManager()方法获取。 (3). 开启一个事务，通过调用beginTransaction()方法开启。 (4). 向容器内添加或替换 Fragment，一般使用replace()方法实现，需要传入容器的id和待添 加的 Fragment 实例。 (5). 提交事务，调用commit()方法来完成。 实现返回栈 我们成功实现了向 Activity 中动态添加 Fragment 的功能。不过我们尝试一下就会发现，通过点击按钮添加了一个 Fragment 之后，这时按下 Back 键程序就会直接退出。如果我们想实现类似于返回栈的效果，按下 Back 键可以回到上一个 Fragment，该如何实现呢？ FragmentTransaction中提供了一个addToBackStack()方法，可以用于将一 个事务添加到返回栈中。修改 MainActivity 中的代码，如下所示： ... transaction.addToBackStack(null); transaction.commit(); 我们在事务提交之前调用了addToBackStack()方法，它可以接收一个名字用于描述返回栈的状态，一般传入 null 即可。然后重新运行程序，点击按钮将 AnothertFragment 添加到Activity 中，再按下 Back 键，你会发现程序并没有退出，而回到了上一个 Fragment 界面。 Fragment 和 Activity 之间的交互 虽然 Fragment 是嵌入在 Activity 中显示的，但它们的关系并没有那么亲密。实际上Fragment和 Activity 是各自存在于一个独立的类当中的，它们之间并没有明显的方式来直接进行交互。如果想要实现它们之间的交互，应该如何做呢？ 为了方便碎片和活动之间进行通信，FragmentManager提供了一个类似于findViewById()的方法，专门用于从布局文件中获取 Fragment 的实例，代码如下所示： myFragment fragment = (myFragment) getSupportFragmentManager().findFragmentById(R.id.my_frag); 调用FragmentManager的findFragmentById()方法，可以在活动中得到相应碎片的实例，然后就能轻松地调用碎片里的方法了。 知道了如何在活动中调用碎片里的方法，那在碎片中又该怎样调用活动里的方法呢？ 其实在每个碎片中都可以通过调用getActivity()方法来得到和当前碎片相关联的活动实例，代码如下所示： MainActivity activity = (MainActivity) getActivity(); 有了活动实例之后，在碎片中调用活动里的方法就变得轻而易举了。另外当碎片中需要使用 Context 对象时，也可以使用getActivity()方法，因为获取到的活动本身就是一个 Context 对象。 既然 Fragment 和 Activity 之间的交互问题已经解决了，那么不同的 Fragment 之间可不可以进行交互呢？ 其实基本思路非常简单：首先在一个 Fragment 中可以得到与它相关联的 Activity，然后再通过这个 Activity 去获取另外一个 Fragment 的实例，这样就实现了不同 Fragment 之间的交互。 Fragment 的生命周期 碎片的状态和回调 运行状态 当一个 Fragment 所关联的 Activity 正处于运行状态时，该 Fragment 也处于运行状态。 暂停状态 当一个 Activity 进入暂停状态时（由于另一个未占满屏幕的 Activity 被添加到了栈顶），与它相关联的 Fragment 就会进入暂停状态。 停止状态 当一个 Activity 进入停止状态时，与它相关联的 Fragment 就会进入停止状态。 或通过调用FragmentTransaction的remove()、replace()方法将 Fragment 从 Activity 中移除，但在事务提交之前调用了addToBackStack()方法，这时的 Fragment 也会进入停止状态。 总的来说，进入停止状态的 Fragment 对用户来说是完全不可见的，有可能会被系统回收。 销毁状态 Fragment 总是依附于 Activity 而存在，因此当 Activity 被销毁时，与它相关联的 Fragment 就会进入销毁状态。 或通过调用FragmentTransaction的remove()或replace()方法将 Fragment 从 Activity 中移除，但在事务提交之前并没有调用addToBackStack()方法，这时的 Fragment 也会进入销毁状态。 Fragment 类中也提供了一系列的回调方法，以覆盖碎片生命周期的每个环节。其中活动有的回调方法，碎片中几乎都有，不过碎片还提供了一些附加的回调方法，那我们就重点看一下这几个回调： onAttach：当碎片和活动建立关联的时候调用。 onCreateView：为碎片创建视图（加载布局）时调用。 onViewCreated：在onCreateView方法之后调用，此时表明 fragment 视图层级结构已创建完毕。 onActivityCreated：确保与碎片相关联的活动一定已经创建完毕的时候调用。 onViewStateRestored：当所有保存的状态都已恢复到视图层次结构时调用。 onSaveInstanceState：只有当 Activity 在异常状态下被结束时，系统才会调用此方法，用于保存当前 Activity 的状态，以便后续在重建被异常结束的 Activity 时调用onRestoreInstatnceState方法来恢复现场。 onDestroyView：当与碎片关联的视图被移除的时候调用。 onDetach：当碎片和活动解除关联的时候调用。 onActivityCreated方法现已弃用。与 Fragment 视图有关的代码应在 onViewCreated中执行，而其他初始化代码应在onCreate中执行。如需专门在 Activity 的onCreate完成时接收回调，应在onAttach中的 Activity 的Lifecycle上注册 LifeCycleObserver`，并在收到 onCreate 回调后将其移除。 fragment 生命周期示意图 动态加载布局的技巧 虽然动态添加 Fragment 的功能很强大，可以解决很多实际开发中的问题，但是它毕竟只是在一个布局文件中进行一些添加和替换操作。如果程序能够根据设备的分辨率或屏幕大小，在运行时决定加载哪个布局，那我们可发挥的空间就更多了。 使用限定符 很多平板应用采用的是双页模式（程序会在左侧的面板上显示一个包含子项的列表，在右侧的面板上显示内容），而手机的屏幕就只能显示一页的内容。那么怎样才能在运行时判断程序应该是使用双页模式还是单页模式呢？ 修改layout文件夹中activity_main.xml的代码： &lt;fragment android:id=&quot;@+id/leftFrag&quot; android:name=&quot;com.example.fragmenttest.LeftFragment&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; 这里只有一个 Fragment，并让它充满整个父布局 接着在 res 目录下新建layout-large文件夹，并在这个文件夹下新建一个布局，也叫作activity_main.xml，添加如下代码 &lt;fragment android:id=&quot;@+id/leftFrag&quot; android:name=&quot;com.example.fragmenttest.LeftFragment&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;1&quot; /&gt; &lt;fragment android:id=&quot;@+id/rightFrag&quot; android:name=&quot;com.example.fragmenttest.RightFragment&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;match_parent&quot; android:layout_weight=&quot;3&quot; /&gt; 可以看到，layout/activity_main布局只包含了一个 Fragment，即单页模式，而layout-large/ activity_main布局包含了两个 Fragment，即双页模式。其中，large就是一个限定符，那些屏幕被认为是 large 的设备就会自动加载 layout-large 文件夹下的布局，小屏幕的设备则还是会加载 layout 文件夹下的布局。 使用最小宽度限定符 上面我们使用 large 限定符成功解决了单页双页的判断问题，不过 large 到底是指多大呢？有时候我们希望可以更加灵活地为不同设备加载布局，不管它们是不是被系统认定为 large，这时就可以使用最小宽度限定符。 最小宽度限定符允许我们对屏幕的宽度指定一个最小值（以 dp 为单位），然后以这个最小值为临界点，屏幕宽度大于这个值的设备就加载一个布局，屏幕宽度小于这个值的设备就加载另一个布局。 在res目录下新建layout-sw600dp文件夹，然后在这个文件夹下新建activity_main.xml布局。 可知当程序运行在屏幕宽度大于等于600 dp的设备上时，会加载layout-sw600dp/activity_main布局，否则仍然加载默认的layout/activity_main布局 ","link":"https://Petrichoroo.github.io/post/lesslessdi-yi-xing-dai-ma-androidgreatergreater-bi-ji-fragment/"},{"title":"《第一行代码 Android》笔记 — UI","content":" UI 一、常见控件 TextView 部分XML属性 Button 常见XML 属性 Shape 属性 EditText 常见 XML 属性 ImageView src 属性和 background 属性的区别 动态更改图片 设置图片的缩放类型 绘制圆形的 ImageView ProgressBar 常见 XML 属性 Android 控件的可见属性 设置水平进度条 常见方法 AlertDialog 创建步骤 常用方法 普通对话框 二、常见布局及其属性 LinearLayout 常用属性 RelativeLayout 子控件相对于父布局属性 子控件相对于其它位置控件属性 子控件相对于其它控件对齐方式 偏移（margin） 填充（padding） FrameLayout 注意事项 ConstrainLayout 三、自定义控件 控件和布局的继承结构 引入布局（自定义标题栏） 创建自定义控件 四、ListVIew ListView 的简单用法 定制 ListView 的界面 提升 ListView 的运行效率 ListView 的点击事件 五、RecyclerView RecyclerView 的基本用法 布局排列 线性布局 瀑布流布局 网格式布局 RecyclerView 的点击事件 UI 一、常见控件 TextView 用来显示字符串的组件，在手机上就是显示一块文本的区域。 部分XML属性 android:inputType：设置文本的数据类型，如果包含非该类型的文本则不显示。 android:gravity：设置控件中内容的对齐方向。注意与layout_gravity区分。 android:hint：当文本为空时提示文本显示。可通过textColorHint设置提示信息的颜色。 android:lines：设置文本的行数。 android:autoLink：设置是否当文本为 URL 链接 /email/ 电话号码 /map 时，文本显示为可点击的链接。 android:autoText：如果设置，将自动执行输入值的拼写纠正。 android:ellipsize：当字符内容太长显示不下时可以省略号代替未显示的字符。可设置如下值： start&quot;：省略号在开头 middle：省略号在中间 end ：省略号在结尾 marquee：跑马灯显示 android:scrollHorizontally：设置文本超出TextView的宽度的情况下，是否出现横拉条。 android:shadowColor：指定文本阴影的颜色。 android:shadowDx：设置所有文本 x 轴即水平偏移，右为正，左为负。 android:shadowDy：设置所有文本 y 轴即垂直偏移，下为正，上为负。 android:shadowRadius：设置阴影的半径。 Button 允许用户通过单击来执行操作。由于 Button 是继承于 TextView 的，因此，TextView 中的常用属性，Button 一般也能使用。 常见XML 属性 android:text：设置显示的文本。 android:textStyle：设置文本样式。 android:textColorHighlight：设置文本被选中时，高亮显示的颜色。 android:textAllCaps：设置系统是否保留你指定的原始文字内容（比如英文大小写）。 Shape 属性 Selector 是背景选择器，主要控制按钮背景的一些变化，比如按下抬起选中状态。Shape 是设置按钮背景的，如圆形，矩形，渐变，圆角等。它们可以单独的用于 Button，也可以在 Selector 中内嵌 Shape，实现更多的按钮效果。 在res-&gt;drawable下创建个Drawable Resource File ，文件命名后设置Root element为shape。 shape内部标签属性： corners：定义四边圆角。 gradient：是用来定义渐变颜色的，和solid不同时出现。 solid：是用来绘制实心内部填充色的，和gradient不同时出现。 stroke：描边效果，定义描边的宽度，颜色，虚实线等。 size和padding：设置图形的大小及内边距，不常用。 Shape 自已是可以定义当前Shape的形状的，比如矩形、椭圆形、线形和环形；通过Shape标签的shape属性来定义的，如：android:shape= rectangle | oval | line | ring 在 XML 中，即通过android:background=&quot;@drawable/btn_shape&quot;引用。 EditText 程序用于和用户进行交互的另一个重要控件，它允许用户在控件里输入和编辑内容，并可以在程序中对这些内容进行处理。 常见 XML 属性 android:hint：当文本为空时提示文本显示。 android:selectAllOnFocus：获得焦点后全选组件内所有文本内容。 android:inputType：限制输入内容的类型。 android:maxLines：指定EditText的最大行数，这样当输入的内容超过限制时，文本就会向上滚动，EditText则不会再继续拉伸。 ImageView 用于在界面上展示图片，可以让我们的程序界面变得更加丰富多彩。 src 属性和 background 属性的区别 ImageView有两个可以设置图片的属性，分别是：src和background background通常指的都是背景,而src指的是内容。 当使用src属性填入图片时，是按照图片大小直接填充，并不会进行拉伸，而使用background属性填入图片，则是会根据ImageView给定的宽度来进行拉伸。 动态更改图片 在程序中通过调用ImageView的setImageResource()方法可以动态改变 ImageView 中所显示的图片。 设置图片的缩放类型 android:scaleType用于设置显示的图片如何缩放或者移动以适应ImageView的大小 。 绘制圆形的 ImageView 使用GitHub上的开源框架：RoundedImageView或CircleImageView。 ProgressBar 用于在界面上显示一个进度条，表示我们的程序正在加载一些数据。ProgressBar的应用场景很多，比如用户登录时，后台在发送请求，以及等待服务器返回信息，这个时候会用到进度条告知用户当前的进度。 常见 XML 属性 android:max：进度条的最大值。 android:progress：进度条已完成进度值。 android:indeterminate：如果设置成true，则进度条不精确显示进度。 android:indeterminateDuration：设置不精确显示进度的持续时间。 android:secondaryProgress：二级进度条，类似于视频播放的一条是当前播放进度，一条是缓冲进度，前者通过 progress 属性进行设置。 android:progressDrawable：设置轨道对应的Drawable对象。 android:indeterminateDrawable：设置不显示进度的进度条的Drawable对象。 Android 控件的可见属性 旋转的进度条表明我们的程序正在加载数据，那数据总会有加载完的时候，如何才能让进度条在数据加载完成时消失呢？ 所有的 Android 控件都具有可见属性，通过android:visibility进行指定，可选值有 3 种：visible、invisible和gone。 visible表示控件是可见的，这个值是默认值，不指定android:visibility时，控件都是可见的。 invisible表示控件不可见，但是它仍然占据着原来的位置和大小，可以理解成控件变成透明状态了。 gone则表示控件不仅不可见，而且不再占用任何屏幕空间。 通过代码来设置控件的可见性，使用的是setVisibility()方法，允许传入View.VISIBLE、View.INVISIBLE和View.GONE这 3 种值。 if (progressBar.getVisibility() == View.VISIBLE) { progressBar.setVisibility(View.GONE); } else { progressBar.setVisibility(View.VISIBLE); } 通过getVisibility()方法来判断ProgressBar是否可见，若可见就将其隐藏，否则就将其显示出来。 设置水平进度条 ProgressBar默认是圆形进度条，但我们可以为其指定不同的样式，通过style属性可以将它指定成水平进度条。 style=&quot;?android:attr/progressBarStyleHorizontal&quot; 常见方法 getMax()：返回这个进度条的范围的上限 getProgress()：返回进度 getSecondaryProgress()：返回次要进度 incrementProgressBy(int diff)：指定增加的进度 isIndeterminate()：指示进度条是否在不确定模式下 setIndeterminate(boolean indeterminate)：设置不确定模式下 AlertDialog 在当前界面弹出一个对话框，这个对话框是置顶于所有界面元素之上的，能够屏蔽其他控件的交互能力，因此AlertDialog一般用于提示一些非常重要的内容或者警告信息。比如为了防止用户误删重要内容，在删除前弹出一个确认对话框。 创建步骤 对话框是在某个时机才会被触发（比如用户点击了某个按钮）。所以AlertDialog并不需要到布局文件中创建，而是在代码中通过构造器AlertDialog.Builder来构造标题、图标和按钮等内容。 创建构造器AlertDialog.Builder的对象。 通过构造器对象调用相关方法构造对话框的标题、信息和图标等内容。 根据需要调用相关方法设置正面按钮、负面按钮和中立按钮。 显示对话框（两种方法）。 AlertDialog.Builder调用show()方法，显示对话框。 调用构造器对象的create方法创建AlertDialog对象，再调用其show方法，也能让对话框显示到界面上。 常用方法 setTitle：为对话框设置标题 setIcon：为对话框设置图标 setMessage：为对话框设置内容 setView：给对话框设置自定义样式 setNeutralButton：普通按钮 setPositiveButton：设置正面按钮，即“积极”、“确认”的意思，第一个参数为按钮上显示的文字。 setNegativeButton：设置反面按钮，即“消极”、“取消”的意思，第一个参数为按钮上显示的文字。 setItems：设置对话框要显示的一个List，一般用于显示几个选项时 setMultiChoiceItems：用来设置对话框显示一系列的复选框 setSingleChoiceItems：用来设置对话框显示一系列的单选框 create ：创建对话框 show ：显示对话框 普通对话框 AlertDialog.Builder dialog = new AlertDialog.Builder(MainActivity.this); dialog.setTitle(&quot;This is a Dialog&quot;); //标题 dialog.setMessage(&quot;Something important&quot;); //内容 dialog.setCancelable(false); //可否取消 false 即无法通过 Back 键取消掉 //确定按钮的点击事件 dialog.setPositiveButton(&quot;OK&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { } }); //取消按钮的点击事件 dialog.setNegativeButton(&quot;Cancel&quot;, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { } }); dialog.show(); 二、常见布局及其属性 LinearLayout 线性布局，将其所包含的控件在线性方向上依次排列。 常用属性 android:orientation：指定控件排列的方向，水平（horizontal）或者垂直（vertical）。默认的排列方向是 horizontal。需要注意的是，若排列方向是 horizontal，内部的控件就绝对不能将宽度指定为match_parent，否则单独的一个控件就会将整个水平方向占满，其他的控件就没有可放置的位置了。vertical 同理，不能将高度指定为match_parent。 android:layout_gravity：用于指定控件在布局中的对齐方式。需要注意，当布局排列方向是 horizontal 时，只有垂直方向上的对齐方式才会生效。因为此时水平方向上的长度是不固定的，每添加一个控件，水平方向上的长度都会改变，因而无法指定该方向上的对齐方式。 android:layout_weight：允许我们使用比例的方式来指定控件的大小，它在手机屏幕的适配性方面可以起到非常重要的作用。 &lt;EditText android:id=&quot;@+id/input_message&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:hint=&quot;Type something&quot; /&gt; &lt;Button android:id=&quot;@+id/send&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Send&quot; /&gt; 指定EditText的android:layout_weight属性为 1，其宽度属性为 0，而Button的长宽度自适应，这样Button的宽度按照wrap_content来计算，而EditText则会占满屏幕所有的剩余空间。使用这种方式编写的界面可以适配各种屏幕。 RelativeLayout 相对布局，通过相对定位的方式让控件出现在布局的任何位置。 子控件相对于父布局属性 属性值是Boolean类型。 android: layout_alignParentLeft：靠左边显示。 android: layout_alignParentTop：靠顶部显示。 android: layout_alignParentRight：靠右边显示。 android: layout_alignParentBottom：靠底部显示。 android: layout_centerInParent：居中显示。 android: layout_centerHorizontal：水平居中显示。 android: layout_centerVertical：垂直居中显示。 android: layout_alignWithParentIfMissing：如果对应的兄弟元素找不到的话就以父元素做参照物。 android: layout_alignParentStart：和layout_alignParentLeft的功能类似，Android 4.1 引入，为了更好支持 right-to-left 布局方式（适配从右到左的语言，如阿拉伯语）。 android: layout_alignParentEnd：和layout_alignParentRight的功能类似，Android 4.1 引入，为了更好支持 right-to-left 布局方式。 子控件相对于其它位置控件属性 属性值是其他兄弟控件的 id。 注意，当一个控件去引用另一个控件的 id 时，该控件一定要定义在引用控件的后面，不然会出现找不到 id 的情况。 android: layout_toLeftOf：在另外一个 View 的左边 android: layout_toRightOf：在另外一个 View 的右边 android: layout_above：在另外一个 View 的上方 android: layout_below：在另外一个 View 的下方 android: layout_toStartOf：和layout_toLeftOf用法类似，支持 right-to-left 布局 android: layout_toEndOf：和layout_toRightOf用法类似，支持 right-to-left 布局 子控件相对于其它控件对齐方式 属性值是其他兄弟控件的 id。 android: layout_alignBaseline：该 View 的 baseline 和另外一个 View 的 baseline 对齐。 android: layout_alignLeft：将该 View 的左边边缘与另外一个 View 的左边边缘对齐。 android: layout_alignTop：将该 View 的顶部边缘与另外一个 View 的顶部边缘对齐。 android: layout_alignRight：将该 View 的右边边缘与另外一个 View 的右边边缘对齐。 android: layout_alignBottom：将该 View 的底部边缘与另外一个 View 的底部边缘对齐。 android: layout_alignStart：和layout_alignLeft类似，支持 right-to-left 布局。 android: layout_alignEnd：和layout_alignRight类似，支持 right-to-left 布局。 偏移（margin） 设置组件与父容器的边距。即自身边框到另一个容器边框之间的距离。 android:margin：设置组件上下左右的偏移量 android:layout_marginLeft：设置组件离容器左边的偏移量 android:layout_marginRight：设置组件离容器右边的偏移量 android:layout_marginTop：设置组件离容器上面的偏移量 android:layout_marginBottom：设置组件离容器下面的偏移 一般设置margin的时候都习惯用正数， 其实也可以用负数，比如很常见的弹出广告页面的，右上角的cancle按钮的margin就是负数。 填充（padding） 设置组件内部元素间的边距。即自身边框到自身内部另一个元素边框之间的距离。 android:padding：往内部元素的上下左右填充一定边距 android:paddingLeft：往内部元素的左边填充一定边距 android:paddingRight：往内部元素的右边填充一定边距 android:paddingTop：往内部元素的上方填充一定边距 android:paddingBottom：往内部元素的下方填充一定边距 padding 是站在父 view 的角度描述问题，它规定它里面的内容与这个父 view 边界的距离。而 margin 则是站在自己的角度描述问题，规定自己和其他（上下左右）的 view 之间的距离。 FrameLayout 帧布局没有丰富的定位方式，所有的控件都会默认摆放在布局的左上角。 注意事项 帧布局的大小由控件中最大的子控件决定，如果控件的大小一样大的话，那么同一时刻就只能看到最上面的那个组件，后续添加的控件会覆盖前一个。虽然默认会将控件放置在左上角，但是我们也可以通过layout_gravity属性将控件指定到其他的位置。 ConstrainLayout ConstraintLayout 完全解析 三、自定义控件 控件和布局的继承结构 可以看到，我们所用的所有控件都是直接或间接继承自View的，所用的所有布局都是直接或间接继承自ViewGroup的。 View是 Android 中最基本的一种 UI 组件，它可以在屏幕上绘制一块矩形区域，并能响应这块区域的各种事件，因此，我们使用的各种控件其实就是在View的基础上又添加了各自特有的功能。ViewGroup则是一种特殊的View，它可以包含很多子View和子ViewGroup，是一个用于放置控件和布局的容器。 引入布局（自定义标题栏） 很多 Android 程序会在界面的顶部放置一个标题栏。虽然 Android 系统已经给每个 Activity 提供了标题栏功能，但这里我们决定先不使用它，而是创建一个自定义的标题栏。 但是一般我们的程序中可能有很多个 Activity 需要这样的标题栏，如果在每个 Activity 的布局中都编写一遍同样的标题栏代码，明显就会导致代码的大量重复。这时我们就可以使用引入布局的方式来解决这个问题 在layout目录下新建一个title.xml布局。关键代码如下： &lt;Button android:id=&quot;@+id/title_back&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:layout_margin=&quot;5dp&quot; android:text=&quot;Back&quot;/&gt; &lt;TextView android:id=&quot;@+id/title_text&quot; android:layout_width=&quot;0dp&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:gravity=&quot;center&quot; android:layout_gravity=&quot;center&quot; android:text=&quot;Title text&quot; android:textSize=&quot;24sp&quot; /&gt; &lt;Button android:id=&quot;@+id/title_edit&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center&quot; android:layout_margin=&quot;5dp&quot; android:text=&quot;Edit&quot; /&gt; &lt;/LinearLayout&gt; 在LinearLayout中分别加入了两个Button和一个TextView，左边的 Button 可用于返回，右边的 Button 可用于编辑，中间的 TextView 则可以显示一段标题文本。 现在标题栏布局已经编写完成了，剩下的就是如何在程序中使用这个标题栏了，修改activity_main.xml文件，关键代码如下： &lt;include layout=&quot;@layout/title&quot; /&gt; 可知只需要通过一行 include语句就可以引入标题栏布局。 记得在MainActivity中将系统自带的标题栏隐藏掉，关键代码如下： ActionBar actionBar = getSupportActionBar(); if(actionBar != null){ actionBar.hide(); } 这里调用了getSupportActionBar()方法来获得ActionBar的实例，然后再调用它的hide()方法将标题栏隐藏起来。 创建自定义控件 当系统自带的控件并不能满足我们的需求时，可以利用上面的继承结构来创建自定义控件。 引入布局的技巧解决了重复编写布局代码的问题，但是如果布局中有一些控件要求能够响应事件，我们仍需要在每个Activity中为这些控件单独编写一次事件注册的代码。 比如标题栏中的返回按钮，其实不管是在哪一个 Activity 中，这个按钮的功能都是相同的，即销毁当前 Activity。而如果在每一个Activity 中都需要重新注册一遍返回按钮的点击事件，无疑会增加很多重复代码，这种情况最好是使用自定义控件的方式来解决。 新建TitleLayout继承自LinearLayout，让它成为我们自定义的标题栏控件。关键代码如下： public class TitleLayout extends LinearLayout{ public TitleLayout(Context context, @Nullable AttributeSet attrs) { super(context, attrs); LayoutInflater.from(context).inflate(R.layout.title,this); } } 这里重写了LinearLayout中带有两个参数的构造函数，然后在构造函数中借助LayoutInflater对标题栏布局进行动态加载。通过它的from()方法可以构建出一个LayoutInflater 对象，然后调用其inflate()方法就可以动态加载一个布局文件，inflate() 方法接收两个参数，第一个参数是要加载的布局文件的 id，这里我们传入R.layout.title，第二个参数是给加载好的布局再添加一个父布局，这里我们想要指定为TitleLayout，于是直接传入this。 加深对 LayoutInflater 的理解，可以去看郭霖老师的博客：再看LayoutInflater，这次你可能又会有新的认识。 自定义控件已经创建好了，我们需要在布局文件中添加这个自定义控件，修改activity_main.xml，关键代码如下： &lt;com.example.uicustomviews.TitleLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;/&gt; 添加自定义控件和添加普通控件的方式基本是一样的，只不过在添加自定义控件的时候，我们需要指明控件的完整类名，包名在这里是不可以省略的。 然后在TitleLayout中通过调用setOnClickListener()方法为标题栏的按钮注册点击事件。这样每当我们在一个布局中引入 TitleLayout 时，返回按钮和编辑按钮的点击事件就已经自动实现好了，这就省去了很多编写重复代码的工作。 四、ListVIew 由于手机屏幕空间比较有限，能够一次性在屏幕上显示的内容并不多，当我们的程序中有大量的数据需要展示的时候，就可以借助ListView来实现。ListView 允许用户通过手指上下滑动的方式将屏幕外的数据滚动到屏幕内，同时屏幕上原有的数据会滚动出屏幕。 ListView 的简单用法 修改activity_main.xml，在其中添加一个ListVIew控件，代码如下所示： &lt;ListView android:id=&quot;@+id/list_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;/&gt; 这里为ListView指定一个id，然后将宽度和高度都设置为match_parent，这样 ListView 就占满了整个布局的空间。 然后修改MainActivity中的代码，如下所示： private String[] data = {&quot;Apple&quot;,&quot;Banana&quot;,&quot;Orange&quot;,&quot;...&quot;}; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;( MainActivity.this,android.R.layout.simple_list_item_1,data); ListView listView = (ListView)findViewById(R.id.list_view); listView.setAdapter(adapter); } 这里使用了一个data数组提供大量的数据，里面包含了很多水果的名称。不过，数组中的数据是无法直接传递给ListView的，我们还需要借助适配器来完成。 Android 中提供了很多适配器的实现类，这里使用的是ArrayAdapter。它可以通过泛型来指定要适配的数据类型，然后在构造函数中把要适配的数据传入。ArrayAdapter 有多个构造函数的重载，应该根据实际情况选择最合适的一种。由于提供的数据都是字符串，因此将 ArrayAdapter 的泛型指定为String，然后在 ArrayAdapter 的构造函数中依次传入当前上下文、ListView子项布局的id以及要适配的数据。 注意，这里使用了android.R.layout.simple_list_item_1作为ListView子项布局的id，这是一个 Android 内置的布局文件，里面只有一个TextView，可用于简单地显示一段文本。这样适配器对象就构建好了。 最后，调用ListView的setAdapter()方法，将构建好的适配器对象传递进去，这样 ListView 和数据之间的关联就建立完成了。 定制 ListView 的界面 你会发现上面只能显示一段文本的ListView实在是太单调了，现在就来对 ListView 的界面进行定制，让它可以显示更加丰富的内容。 定义一个实体类，作为ListView适配器的适配类型。新建类Fruit，代码如下所示： public class Fruit { private String name; //水果名 private int imageId; //水果对应图片的资源id public Fruit(String name,int imageId){ this.name = name; this.imageId = imageId; } public String getName(){ return name; } public int getImageId(){ return imageId; } } 然后为ListView的子项指定一个我们自定义的布局，在layout目录下新建fruit_item.xml，代码如下所示： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;ImageView android:id=&quot;@+id/fruit_image&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot;/&gt; &lt;TextView android:id=&quot;@+id/fruit_name&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_gravity=&quot;center_vertical&quot; android:layout_marginLeft=&quot;10dp&quot;/&gt; &lt;/LinearLayout&gt; 这里创建了一个高度自适应的线性布局，其中定义了一个ImageView用于显示水果的图片，又定义了一个TextView用于显示水果的名称，并让 TextView 在垂直方向上居中显示。 然后我们需要创建一个自定义的适配器，新建类FruitAdapter，继承自ArrayAdapter，并将泛型指定为Fruit，代码如下： public class FruitAdapter extends ArrayAdapter&lt;Fruit&gt; { private int resourceId; public FruitAdapter(Context context, int textViewResourceId, List&lt;Fruit&gt; objects) { super(context,textViewResourceId,objects); resourceId = textViewResourceId; } @Override public View getView(int position,View convertView,ViewGroup parent) { Fruit fruit = getItem(position);//获取当前项的Fruit实例 View view = LayoutInflater.from(getContext()).inflate(resourceId,parent,false); ImageView fruitImage = (ImageView) view.findViewById(R.id.fruit_image); TextView fruitName = (TextView) view.findViewById(R.id.fruit_name); fruitImage.setImageResource(fruit.getImageId()); fruitName.setText(fruit.getName()); return view; } } FruitAdapter重写了父类的一组构造函数，用于将上下文、ListView子项布局的id和数据都传递进来。 重写了getView()方法，这个方法在每个子项被滚动到屏幕内的时候会被调用。在这个方法中首先通过getItem()方法得到当前项的Fruit实例，然后使用LayoutInflater来为这个子项加载我们传入的布局。 LayoutInflater的inflate()方法第三个参数为false，表示只让在父布局中声明的layout属性生效，但不会为这个View添加父布局，因为一旦 View 有了父布局之后，它就不能再添加到ListView中了。详见：再看LayoutInflater，这次你可能又会有新的认识。 接着获取到ImageView和TextView的实例，并分别调用它们的setImageResource()和setText()方法来设置显示的图片和文字，最后将布局返回，这样我们自定义的适配器就完成了。 最后修改 MainActivity 中的代码，关键如下： private List&lt;Fruit&gt; fruitList = new ArrayList&lt;Fruit&gt;(); initFruits(); //初始化水果数据 //创建适配器对象 当前上下文、ListView子项布局的id以及要适配的数据 FruitAdapter fruitAdapter = new FruitAdapter(MainActivity.this, R.layout.fruit_item, fruitList); ListView listView = (ListView) findViewById(R.id.list_view); listView.setAdapter(fruitAdapter); 提升 ListView 的运行效率 目前我们编写的ListView很多细节可以优化，其中运行效率就是很重要的一点。目前我们 ListView 的运行效率是很低的，当 ListView 快速滚动的时候，这就会成为性能的瓶颈。 可优化的地方： 在FruitAdapter的getView()方法中，每次都将布局重新加载了一遍。 在FruitAdapter的getView()方法中，每次都会调用View的findViewById()方法来获取一次控件的实例。 我们发现getView()方法中还有一个convertView参数，这个参数用于将之前加好的布局进行缓存，以便之后进行重用，我们可以借助这个参数来进行性能优化。同时我们可以借助一个ViewHolder来对每次都要获取一次控件实例的问题进行优化。修改FruitAdapter中的代码，如下所示： //重写getView()方法 在每个子项被滚动到屏幕内的时候会被调用 @Override public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) { Fruit fruit = (Fruit) getItem(position); //获取当前项的Fruit实例 View view; ViewHolder viewHolder; //convertView参数用于将之前加载好的布局进行缓存 if (convertView == null) { //若为null 则使用LayoutInflater来为子项去加载布局 view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false); viewHolder = new ViewHolder(); //取出控件实例并存放在viewHolder中 viewHolder.fruitImage = view.findViewById(R.id.fruit_image); viewHolder.fruitName = view.findViewById(R.id.fruit_name); view.setTag(viewHolder); //将viewHolder存储在view中 } else { //否则重用convertView view = convertView; viewHolder = (ViewHolder) view.getTag(); //重新获取viewHolder } //设置显示的图片和文字 viewHolder.fruitImage.setImageResource(fruit.getImageId()); viewHolder.fruitName.setText(fruit.getName()); return view; } //创建内部类ViewHolder 用于对控件的实例进行缓存 class ViewHolder { ImageView fruitImage; TextView fruitName; } ListView 的点击事件 ListView的滚动毕竟只是满足了视觉上的效果。这里我们为 ListView 中的子项添加响应用户点击事件的逻辑。修改 MainActivity 中的代码，如下所示： listView.setOnItemClickListener(new AdapterView.OnItemClickListener() { @Override public void onItemClick(AdapterView&lt;?&gt; adapterView, View view, int position, long id) { //通过position参数判断出用户点击的是哪一个子项 并获取 Fruit fruit = fruitList.get(position); //返回动态数组中指定索引处的元素 Toast.makeText(MainActivity.this, fruit.getName(), Toast.LENGTH_SHORT).show(); } }); 这里使用setOnItemClickListener()方法为ListView注册一个监听器，当用户点击了ListView中的任何一个子项时，就会回调onItemClick()方法。在这个方法中通过position参数判断出用户点击的是哪一个子项，然后获取到相应的水果实例，并将水果名显示出来。 五、RecyclerView ListView并不是完美无缺的，比如如果不使用一些技巧来提升它的运行效率，那么它的性能就会非常差。还有它的扩展性也不够好，只能实现数据纵向滚动的效果。为此，Android 提供了一个更强大的滚动控件——RecyclerView。它可以说是一个增强版的 ListView，不仅可以轻松实现和 ListView 同样的效果，还优化了 ListView 存在的各种不足之处。 RecyclerView 的基本用法 修改activity_main.xml中的代码，加入一个RecyclerView控件，并让其占满整个布局空间。如下所示： &lt;androidx.recyclerview.widget.RecyclerView android:id=&quot;@+id/recycler_view&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; /&gt; 为RecyclerView准备一个适配器，新建FruitAdapter类，让其继承自RecyclerView.Adapter，并将泛型指定为FruitAdapter.ViewHolder。ViewHolder是我们在 FruitAdapter 中定义的一个内部类，代码如下所示： public class FruitAdapter extends RecyclerView.Adapter&lt;FruitAdapter.ViewHolder&gt; { private List&lt;Fruit&gt; mFruitList; //定义内部类 ViewHolder 继承自 RecyclerView.ViewHolder static class ViewHolder extends RecyclerView.ViewHolder { ImageView fruitImage; TextView fruitName; public ViewHolder(View view) { super(view); //view参数通常是RecyclerView子项的最外层布局 fruitView = view; fruitImage = (ImageView) view.findViewById(R.id.fruit_image); fruitName = (TextView) view.findViewById(R.id.fruit_name); } } //用于把要展示的数据源传进来 并赋值给一个全局变量mFruitList public FruitAdapter(List&lt;Fruit&gt; fruitList) { mFruitList = fruitList; //后续操作均在此数据源的基础上进行 } //用于创建ViewHolder实例 @NonNull @Override public ViewHolder onCreateViewHolder(@NonNull ViewGroup parent, int viewType) { View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.fruit_item, parent, false); //创建ViewHolder实例 并把加载出来的布局传入到构造函数中 final ViewHolder holder = new ViewHolder(view); //JVM会缓存final修饰的变量 提高性能 return holder; } //用于对RecyclerView子项的数据进行赋值 在每个子项被滚动到屏幕内时执行 @Override public void onBindViewHolder(@NonNull FruitAdapter.ViewHolder holder, int position) { //通过position参数得到当前项的Fruit实例 Fruit fruit = mFruitList.get(position); //将数据设置到ViewHolder的ImageView和TextView中 holder.fruitImage.setImageResource(fruit.getImageId()); holder.fruitName.setText(fruit.getName()); } //用于告诉RecyclerView一共有多少子项 @Override public int getItemCount() { return mFruitList.size(); //直接返回数据源长度 } } 由于 FruitAdapter 是继承自 RecyclerView.Adapter 的，因此必须重写onCreateViewHolder()、onBindViewHolder()和getItemCount()这 3 个方法。 onCreateViewHolder()：用于创建ViewHolder实例。在这个方法中将上下文，子项布局加载进来，得到一个 View 实例，并将其传入到构造函数中得到 ViewHolder 的实例，最后将其返回。 onBindViewHolder()：用于对RecyclerView子项的数据进行赋值，会在每个子项被滚动到屏幕内的时候执行。 getItemCount()方法就非常简单了，它用于告诉 RecyclerView 一共有多少子项，直接返回数据源的长度就可以了。 适配器准备好了之后，我们就可以开始使用RecyclerView了，在 MainActivity 中添加关键代码，如下所示： RecyclerView recyclerView = findViewById(R.id.recycler_view); LinearLayoutManager layoutManager = new LinearLayoutManager(this); recyclerView.setLayoutManager(layoutManager); FruitAdapter adapter = new FruitAdapter(fruitList); recyclerView.setAdapter(adapter); LayoutManager用于指定 RecyclerView 的布局方式，这里使用的 LinearLayoutManager 是线性布局的意思，可以实现和 ListView 类似的效果。 布局排列 ListView 的布局排列是由自身去管理，而RecyclerView则将这个工作交给LayoutManager，LayoutManager 中制定了一套可扩展的布局排列接口，子类只要按照接口的规范来实现，就能定制出各种不同排列方式的布局了。 线性布局 这种布局方式上面已经使用过，这里我们实现横向排列，修改 MainActivity 中的代码，如下所示： layoutManager.setOrientation(LinearLayoutManager.HORIZONTAL); 这里只添加了一行代码，通过setOrientation()方法来设置布局的排列方向。默认是纵向排列的，传入 LinearLayoutManager.HORIZONTAL 表示让布局横行排列。注意记得去修改fruit_item.xml，因为我们要实现横向滚动的话，应该把子项布局里的元素改成垂直排列才比较合理。 瀑布流布局 StaggeredGridLayoutManager layoutManager = new StaggeredGridLayoutManager(3, StaggeredGridLayoutManager.VERTICAL); recyclerView.setLayoutManager(layoutManager); StaggeredGridLayoutManager的构造函数接收两个参数， 第一个参数用于指定布局列数， 第二个参数用于指定布局的排列方向。注意瀑布流布局的宽度应该是布局的列数来自动适配的，而不是一个固定值。 网格式布局 GridLayoutManager layoutManager = new GridLayoutManager(this, 2); recyclerView.setLayoutManager(layoutManager); GridLayoutManager的构造函数接收两个参数， 第一个是 Context， 第二个是列数，这里我们希望每行中有两列数据。 RecyclerView 的点击事件 RecyclerView 并没有提供类似于setOnItemClickListener()这样的注册监听器，而是需要我们自己给子项具体的 View 去注册点击事件。 修改 FruitAdapter 中的代码，如下所示： static class ViewHolder extends RecyclerView.ViewHolder { View fruitView; //保存子项最外层布局的实例 ... } 这里在ViewHolder中添加了fruitView变量来保存子项最外层布局的实例，然后在onCreateViewHolder()方法中注册点击事件，代码如下： //为最外层布局注册点击事件 holder.fruitView.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { int position = holder.getAdapterPosition(); //获取用户点击的position Fruit fruit = mFruitList.get(position); //通过position拿到相应的Fruit实例 Toast.makeText(view.getContext(), &quot;you clicked view &quot; + fruit.getName(), Toast.LENGTH_SHORT).show(); } }); //为ImageView注册点击事件 holder.fruitImage.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { int position = holder.getAdapterPosition(); Fruit fruit = mFruitList.get(position); Toast.makeText(view.getContext(), &quot;you clicked image &quot; + fruit.getName(), Toast.LENGTH_SHORT).show(); } }); 这里为最外层布局的和 ImageView 都注册了点击事件，RecyclerView 的强大之处也在这里，它可以轻松实现子项中任意控件或布局的点击事件。由于 TextView 并没有注册点击事件，因此点击文字这个事件会被子项的最外层布局捕获到。 ","link":"https://Petrichoroo.github.io/post/lesslessdi-yi-xing-dai-ma-androidgreatergreater-bi-ji-ui/"},{"title":"《第一行代码 Android》笔记 — Activity","content":" Activity 一、在 Activity 中使用 Menu 二、使用 Intent 在 Activity 之间穿梭 1. 使用显示 Intent 2. 使用隐式 Intent 3. 更多隐式 Intent 的用法 4. 向下一个 Activity 传递数据 5. 返回数据给上一个 Activity 三、Activity 的生命周期 1. 返回栈 2. Activity 状态 3. Activity 的生存期 4. Activity 生命周期示意图 5. Activity 被回收了怎么办 onSaveInstanceState() 回调方法 四、Activity 的启动模式 standard singleTop singleTask singleInstance 五、Activity 的最佳实践 知晓当前是在哪一个活动 随时随地退出程序 启动 Activity 的最佳写法 Activity 一、在 Activity 中使用 Menu 当 Activity 中有大量的菜单需要显示时，界面设计就会比较尴尬，Android 给我们提供了一种方式，可以让菜单都能得到展示，还不占用任何屏幕空间。 在res目录下新建一个menu文件夹，并在其下创建 &quot;main&quot; 菜单文件，添加如下内容： &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:id=&quot;@+id/add_item&quot; android:title=&quot;Add&quot;/&gt; &lt;item android:id=&quot;@+id/remove_item&quot; android:title=&quot;Remove&quot;/&gt; &lt;/menu&gt; 其中&lt;item&gt;标签用来创建具体的某一个菜单项，然后通过android:id给这个菜单项指定一个唯一的标识符，通过android:title给这个菜单项指定一个名称。 2. 在 Activity 中重写 onCreateOptionsMenu() 方法 @Override public boolean onCreateOptionsMenu(Menu menu) { //得到 MenuInflater 对象 调用其 inflate() 方法给当前活动创建菜单 getMenuInflater().inflate(R.menu.main, menu); return true; } inflate()方法接收两个参数：第一个参数用于指定我们通过哪一个资源文件来创建菜单，这里当然是传入R.menu.main；第二个参数用于指定我们的菜单项将添加到哪一个 Menu 对象当中。 3. 定义菜单响应事件。在Activity 中重写onOptionsItemSelected()方法 public boolean onOptionsItemSelected(@NonNull MenuItem item) { switch (item.getItemId()) { case R.id.add_item: Toast.makeText(this, &quot;You clicked Add&quot;, Toast.LENGTH_LONG).show(); break; case R.id.remove_item: Toast.makeText(this, &quot;You clicked Remove&quot;, Toast.LENGTH_LONG).show(); break; default: } return true; } 通过调用item.getItemId()来判断点击的是哪一个菜单项，再分别去处理具体逻辑。 二、使用 Intent 在 Activity 之间穿梭 Intent是 Android 程序中各组件之间进行交互的一种重要方式，它不仅可以指明当前组件想要执行的动作，还可以在不同组件之间传递数据。Intent 一般可用于启动 Activity 、启动 Service 以及发送广播等场景。 1. 使用显示 Intent Intent 有多个构造函数的重载，其中一个是Intent(Context packageContext, Class&lt;?&gt;cls)，其接收两个参数：第一个参数Context要求提供一个启动 Activity 的上下文；第二个参数Class用于指定想要启动的目标 Activity。 Intent intent = new Intent(FirstActivity.this, SecondActivity.class); startActivity(intent); 2. 使用隐式 Intent 隐式 Intent 指定了一系列更为抽象的action和category等信息，然后交由系统去分析这个 Intent，并帮们找出合适的 Activity 去启动。 打开AndroidManifest.xml，通过在&lt;activity&gt;标签下配置&lt;intent-filter&gt;的内容，可以指定当前 Activity 能够响应的 action 和 category。 &lt;activity android:name=&quot;.SecondActivity&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;com.example.activitytest.ACTION_START&quot;/&gt; &lt;category android:name=&quot;android.intent.category.DEFAULT&quot;/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; 只有&lt;action&gt;和&lt;category&gt;中的内容同时匹配 Intent 中指定的 action 和 category 时，这个 Activity 才能响应该 Intent。 修改 FirstActivity 中按钮的点击事件： Intent intent = new Intent(&quot;com.example.activitytest.ACTION_START&quot;); startActivity(intent); 这里使用了 Intent 的另一个构造函数，传入了一个 action 的字符串。需要注意的是，这里只指定了 action，因为在AndroidManifest.xml中定义的android.intent.category.DEFAULT是一种默认的 category，在调用startActivity()方法的时候会自动将这个 category 添加到 Intent 中。 每个 Intent 中只能指定一个 action，但能指定多个 category。修改刚刚的代码： Intent intent = new Intent(&quot;com.example.activitytest.ACTION_START&quot;); intent.addCategory(&quot;com.example.activitytest.MY_CATEGORY&quot;); startActivity(intent); 这里调用addCategory()方法来添加一个我们自定义的 category。记得要在AndroidManifest.xml中给相应活动的&lt;intent-filter&gt;标签中再添加一个自定义 category 的声明。否则会出现没有任何 Activity 可以响应该 Intent 的情况。 3. 更多隐式 Intent 的用法 当你的应用程序中需要展示一个网页时，这时你没有必要自己去实现一个浏览器，只需要调用系统的浏览器来打开这个网页就行了。 Intent intent = new Intent(Intent.ACTION_VIEW); //系统内置动作 intent.setData(Uri.parse(&quot;https://www.baidu.com&quot;)); startActivity(intent); 这里指定了 Intent 的 action 是Intent.ACTION_VIEW，这是一个 Android 系统内置的动作。然后通过Uri.parse()方法将一个网址字符串解析成一个 Uri 对象，再调用 Intent 的setData()方法将这个 Uri 对象传递进去。 我们还可以在&lt;intent-filter&gt;标签中再配置一个&lt;data&gt;标签，用于更精确地指定当前 Activity 能够响应的数据。&lt;data&gt;标签中主要可以配置以下内容： android:scheme。用于指定数据的协议部分，如上例中的 https 部分。 android:host。用于指定数据的主机名部分，如上例中的 www.baidu.com 部分。 android:port。用于指定数据的端口部分，一般紧随在主机名之后。 android:path。用于指定主机名和端口之后的部分，如一段网址中跟在域名之后的内容。 android:mimeType。用于指定可以处理的数据类型，允许使用通配符的方式进行指定。 只有当&lt;data&gt;标签中指定的内容和 Intent 中携带的 Data 完全一致时，当前 Activity 才能够响应该 Intent。不过在&lt;data&gt;标签中一般不会指定过多的内容。例如在上面的浏览器示例中，其实只需要指定android:scheme为 https，就可以响应所有 https 协议的 Intent 了。 除了 https 协议外，我们还可以指定很多其他协议，比如geo表示显示地理位置、tel表示拨打电话。 Intent intent = new Intent(Intent.ACTION_DIAL); intent.setData(Uri.parse(&quot;tel:10086&quot;)); startActivity(intent); 这里指定了 Intent 的 action 是Intent.ACTION_DIAL，这又是一个 Android 系统的内置动作。然后在 data 部分指定了协议是tel，号码是10086。 4. 向下一个 Activity 传递数据 Intent 中提供了一系列putExtra()方法的重载，可以把想要传递的数据暂存在 Intent 中，启动了另一个活动后，只需要把这些数据再从 Intent 中取出就可以了。 如在 FirstActivity 中发送一个字符串 data ： String data = &quot;Hello SecondActivity!&quot;; Intent intent = new Intent(FirstActivity.this, SecondActivity.class); intent.putExtra(&quot;extra_data&quot;, data); startActivity(intent); putExtra()方法接收两个参数，第一个参数是键，用于后面从 Intent 中取值，第二个参数是传递的数据。 在 SecondActivity 中取出数据 ： Intent intent = getIntent(); String data = intent.getStringExtra(&quot;extra_data&quot;); 传递字符串，使用getStringExtra()方法来获取传递的数据。 传递整型数据，使用getIntExtra()方法来获取传递的数据。 传递布尔型数据，使用getBooleanExtra()方法来获取传递的数据。 以此类推 5. 返回数据给上一个 Activity Activity 中有一个startActivityForResult()方法也是用于启动活动的，但这个方法期望在活动销毁的时候能够返回一个结果给上一个活动。 修改 FirstActivity 中按钮的点击事件： Intent intent = new Intent(FirstActivity.this, SecondActivity.class); startActivityForResult(intent, 1); startActivityForResult()方法接收两个参数，第一个参数是 Intent ，第二个参数是请求码，用于在之后的回调中判断数据的来源。 修改 SecondActivity 中返回按钮的点击事件： Intent intent = new Intent(); intent.putExtra(&quot;data_return&quot;, &quot;Hello FirstActivity!&quot;); setResult(RESULT_OK, intent); 构建一个 Intent，注意这个 Intent 没有“意图”，只是将传递的数据存放在其中。setResult()方法接收两个参数，第一个参数用于向上一个活动返回处理结果，一般使用RESULT_OK或RESULT_CANCELED这两个值，第二个参数则把带有数据的 Intent 传递回去。 SecondActivity 销毁后，程序回调到上一个活动的onActivityResult()方法中。在 FirstActivity 中重写这个方法来得到返回的数据： @Override protected void onActivityResult(int requestCode, int resultCode,@Nullable Intent data) { super.onActivityResult(requestCode, resultCode, data); switch (requestCode) { //检查 requestCode 的值来判断数据来源 case 1: if (resultCode == RESULT_OK) { //通过 resultCode 的值来判断处理结果是否成功 String returnData = data.getStringExtra(&quot;data_return&quot;); Log.d(&quot;FirstActivity&quot;, returnData); } break; default: } } onActivityResult()方法带有三个参数，第一个参数requestCode，即在启动活动时传入的请求码。第二个参数resultCode，即在返回数据时传入的处理结果。第三个参数data，即携带着返回数据的 Intent。由于在一个活动中有可能调用startActivityForResult()方法去启动很多不同的活动，每一个活动返回的数据都会回调到onActivityResult()这个方法中。 为防止用户通过按下 Back 键返回到上一个活动导致数据无法返回，我们需要重写onBackPressed()方法。 @Override public void onBackPressed() { super.onBackPressed(); Intent intent = new Intent(); intent.putExtra(&quot;data_return&quot;, &quot;Hello FirstActivity!&quot;); setResult(RESULT_OK, intent); //用于向上一个活动返回数据 finish(); //销毁当前活动 } 三、Activity 的生命周期 1. 返回栈 Android 是使用任务（Task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈（Back Stack）。 栈是一种后进先出的数据结构，在默认情况下，每当我们启动了一个新的活动，它会在返回栈中入栈，并处于栈顶的位置。而每当按下 Back 键或调用finish()方法去销毁一个活动时，处于栈顶的活动会出栈，这时前一个入栈的活动就会重新处于栈顶的位置。系统总是会显示处于栈顶的活动给用户。 2. Activity 状态 每个活动在其生命周期中最多可能会有 4 种状态。 运行状态 当一个 Activity 位于返回栈的栈顶时，Activity 就处于运行状态。 暂停状态 当一个 Activity 不再处于栈顶位置，但仍然可见时，Activity 就进入了暂停状态。之所以可见是因为并不是每一个 Activity 都会占满整个屏幕，比如对话框形式的 Activity 只会占用屏幕中间的部分区域。处于暂停状态的 Activity 仍然是完全存活着的，只有在内存极低的情况下，系统才会去考虑回收这种 Activity。 停止状态 当一个 Activity 不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态。系统仍然会为这种 Activity 保存相应的状态和成员变量，但是这并不是完全可靠的，当其他地方需要内存时，处于停止状态的 Activity 有可能会被系统回收。 销毁状态 一个 Activity 从返回栈中移除后就变成了销毁状态。系统最倾向于回收这种状态的Activity，以保证手机的内存充足。 3. Activity 的生存期 Activity 类中定义了 7 个回调方法，覆盖了活动生命周期的每一个环节。 onCreate() 在 Activity 第一次被创建的时候调用。你应该在这个方法中完成 Activity 的初始化操作，比如加载布局、绑定事件等。 onStart() 这个方法在 Activity 由不可见变为可见的时候调用。 onResume() 这个方法在 Activity 准备好和用户进行交互的时候调用。此时的 Activity 一定位于返回栈的栈顶，并且处于运行状态。 onPause() 这个方法在系统准备去启动或者恢复另一个 Activity 的时候调用。通常会在这个方法中将一些消耗 CPU 的资源释放掉，以及保存一些关键数据，但这个方法的执行速度一定要快，不然会影响到新的栈顶 Activity 的使用。 onStop() 这个方法在 Activity 完全不可见的时候调用。它和onPause()方法的主要区别在于，若启动的新 Activity 是一个对话框式的 Activity，则onPause()方法会得到执行，而onStop()方法并不会执行。 onDestroy() 这个方法在 Activity 被销毁之前调用，之后 Activity 的状态将变为销毁状态。 onRestart() 这个方法在 Activity 由停止状态变为运行状态之前调用，也就是 Activity 被重新启动了。 以上7个方法中除了onRestart()方法，其他都是两两相对的，从而又可以将 Activity 分为以下3种生存期。 完整生存期 Activity 在onCreate()方法和onDestroy()方法之间所经历的就是完整生存期。一般情况下，一个 Activity 会在onCreate()方法中完成各种初始化操作，而在onDestroy()方法中完成释放内存的操作。 可见生存期 Activity 在onStart()方法和onStop()方法之间所经历的就是可见生存期。 在可见生存期内，Activity 对于用户总是可见的，即便有可能无法和用户进行交互。我们可以通过这两个方法合理地管理那些对用户可见的资源。 前台生存期 Activity 在onResume()方法和onPause()方法之间所经历的就是前台生存期。 在前台生存期内，Activity 总是处于运行状态，此时的 Activity 是可以和用户进行交互的，我们平时看到和接触最多的就是这个状态下的 Activity。 4. Activity 生命周期示意图 5. Activity 被回收了怎么办 当一个活动进入到了停止状态，是有可能被系统回收的。那么想象以下场景：应用中有一个活动 A，用户在活动 A 的基础上启动了活动 B，活动 A 就进入了停止状态，这个时候由于系统内存不足，将活动 A 回收掉了，然后用户按下 Back 键返回活动 A，会出现什么情况呢？ 其实还是会正常显示活动 A 的，只不过这时并不会执行onRestart()方法，而是会执行活动 A 的onCreate()方法，因为活动 A 在这种情况下会被重新创建一次。但是活动 A 中是可能存在临时数据和状态的。这样就有可能导致数据的丢失。 onSaveInstanceState() 回调方法 Activity 中还提供了一个onSaveInstanceState()回调方法，这个方法可以保证在 Activity 被回收之前一定会被调用，因此我们可以通过这个方法来解决问题。 在 MainActivity 中添加如下代码就可以将临时数据进行保存： @Override protected void onSaveInstanceState(@NonNull Bundle outState) { super.onSaveInstanceState(outState); String tempData = &quot;Something you just typed&quot;; outState.putString(&quot;dta_key&quot;, tempData); } onSaveInstanceState()方法会携带一个Bundle类型的参数，Bundle提供了一系列的方法用于保存数据，比如使用putString()方法保存字符串，使用putInt()方法保存整型数据等，每个保存方法需要传入两个参数，第一个参数是键，用于后面从Bundle中取值，第二个参数是真正要保存的内容。 数据已经保存下来了，那么我们应该在哪里进行恢复呢？可以发现我们一直使用的onCreate()方法其实也有一个Bundle类型的参数。这个参数在一般情况下都是null，但是如果在Activity 被系统回收之前，你通过onSaveInstanceState()方法保存数据，这个参数就会带有之前保存的全部数据，我们只需要再通过相应的取值方法将数据取出即可。 修改 MainActivity 的onCreate()方法： protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if (savedInstanceState != null) { String tempData = savedInstanceState.getString(&quot;data_key&quot;); Log.d(TAG,tempData); } } Intent 还可以结合 Bundle 一起用于传递数据。首先我们可以把需要传递的数据都保存在 Bundle 对象中，然后再将 Bundle 对象存放在 Intent 里。到了目标 Activity 之后，先从Intent 中取出 Bundle，再从 Bundle 中取出数据。 四、Activity 的启动模式 在实际项目中我们应该根据特定的需求为每个 Activity 指定恰当的启动模式。启动模式一共有 4 种，分别是 standard、singleTop、singleTask 和 singleInstance。 可以在AndroidManifest.xml中通过给&lt;activity&gt;标签指定android:launchMode属性来选择启动模式。 standard standard是 Activity 默认的启动模式，在不进行显式指定的情况下，所有Activity 都会自动使用这种启动模式。在standard模式下，每当启动一个新的 Activity，它就会在返回栈中入栈，并处于栈顶的位置。对于使用standard模式的 Activity，系统不会在乎这个Activity 是否已经在返回栈中存在，每次启动都会创建一个该 Activity 的新实例。 standard模式的原理如图： singleTop 可能在有些情况下，我们会觉得 standard 模式不太合理。Activity 明明已经在栈顶了，为什么再次启动的时候还要创建一个新的 Activity 实例呢？但我们可以根据自己的需要进行修改，比如使用singleTop模式。当 Activity 的启动模式指定为singleTop时，在启动 Activity 时如果发现返回栈的栈顶已经是该 Activity ，则认为可以直接使用它，不会再创建新的Activity 实例。 singleTop模式的原理如图： 不过当 Activity 并未处于栈顶位置时，再启动 Activity 还是会创建新的实例的。 singleTask 使用 singleTop 模式可以很好地解决重复创建栈顶 Activity 的问题，但是如果该Activity 并没有处于栈顶的位置，还是可能会创建多个 Activity 实例的。 如何实现某个 Activity 在整个应用程序的上下文中只存在一个实例？这就要借助singleTask模式。将 Activity 的启动模式指定为singleTask，每次启动该 Activity 时，系统首先会在返回栈中检查是否存在该 Activity 的实例，如果发现已经存在则直接使用该实例，并把在这个 Activity 之上的所有其他 Activity 统统出栈，如果没有发现就会创建一个新的 Activity 实例。 singleTask模式的原理如图： singleInstance 想象以下场景，假设我们的程序中有一个 Activity 是允许其他程序调用的，如果想实现其他程序和我们的程序可以共享这个 Activity 的实例，应该如何实现呢？使用前面 3 种启动模式肯定是做不到的，因为每个应用程序都会有自己的返回栈，同一个 Activity 在不同的返回栈中入栈时必然创建了新的实例。 singleInstance模式应该算是 4 种启动模式中最特殊也最复杂的一个了。不同于以上 3 种启动模式，指定为singleInstance模式的 Activity 会启用一个新的返回栈来管理这个 Activity（其实如果singleTask模式指定了不同的taskAffinity，也会启动一个新的返回栈），不管是哪个应用程序来访问这个 Activity，都共用同一个返回栈，也就解决了共享 Activity 实例的问题。 singleInstance模式的原理如图： 五、Activity 的最佳实践 知晓当前是在哪一个活动 如何根据程序当前的界面就能判断出这是哪一个 Activity？在你进入一家公司之后，更有可能的是接手一份别人写的代码。阅读别人的代码时有一个很头疼的问题，就是当你需要在某个界面上修改一些非常简单的东西时，却半天找不到这个界面对应的 Activity 是哪一个。 新建一个 BaseActivity 类，创建类型选择 Class，然后让其继承自 AppCompatActivity，并重写onCreate()方法： public class BaseActivity extends AppCompatActivity { @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); Log.d(&quot;BaseActivity&quot;, getClass().getSimpleName()); //获取当前实例的类名 } } getclass()获取了当前实例的Class对象，然后再调用getSimpleName()获取当前实例的类名。 接下来我们需要让 BaseActivity 成为项目中所有 Activity 的父类，即修改每个 Activity 的继承结构。这样每当我们进入一个 Activity 的界面时，该 Activity 的类名就会被打印出来，这样我们就可以时刻知晓当前界面对应的是哪一个 Activity 了。 随时随地退出程序 如果目前你手机的界面还停留在某个 Activity，你会发现当前想退出程序是非常不方便的，可能需要连按多次 Back 键才行。而按 Home 键只是把程序挂起，并没有退出程序。如果我们的程序需要注销或者退出的功能该怎么办呢？ 其实解决思路也很简单，只需要用一个专门的集合类对所有的活动进行管理就可以了。新建一个ActivityCollector类作为活动管理器，代码如下所示： public class ActivityCollector { public static List&lt;Activity&gt; activities = new ArrayList&lt;&gt;(); //加上static声明成为静态函数 可直接访问或者通过类名访问 否则需用对象的实例来调用 public static void addActivity(Activity activity) { //添加活动 activities.add(activity); } public static void removeActivity(Activity activity) { //删除活动 activities.remove(activity); } public static void finishAll() { //销毁活动 for (Activity activity : activities) { if (!activity.isFinishing()) { //活动是否正在销毁中 activity.finish(); //Activity.finish()方法调用Activity.onDestroy() } } } } 在活动管理器中，我们通过一个 List 来暂存活动，然后提供了一个addActivity()方法用于向 List 中添加一个活动，提供了一个removeActivity()方法用于从List中移除活动，最后提供了一个finishAll()方法用于将 List 中存储的活动全部销毁掉。 接下来修改BaseActivity中的代码，如下所示： public class BaseActivity extends AppCompatActivity { @Override protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); Log.d(&quot;BaseActivity&quot;, getClass().getSimpleName()); //获取当前实例的类名 ActivityCollector.addActivity(this); //将当前正在创建的活动添加到活动管理器内 } @Override protected void onDestroy() { super.onDestroy(); ActivityCollector.removeActivity(this); //将一个马上要销毁的活动从活动管理器里移除 } } 从此以后，不管你想在什么地方退出程序，只需要调用ActivityCollector.finishAll()方法就可以了。 当然你还可以在销毁所有 Activity 的代码后面再加上杀掉当前进程的代码，以保证程序完全退 出，杀掉进程的代码如下所示： android.os.Process.killProcess(android.os.Process.myPid()); killProcess()方法用于杀掉一个进程，它接收一个进程 id 参数，我们可以通过myPid()方法来获得当前程序的进程 id。需要注意的是，killProcess()方法只能用于杀掉当前程序的进程，不能用于杀掉其他程序。 启动 Activity 的最佳写法 在真正的项目开发中经常会出现对接的问题。比如某个 Activity 并不是由你开发的，但现在你负责开发的部分需要启动这个 Activity，而你却不清楚启动这个 Activity 需要传递哪些数据。这时无非就有两个办法：一个是你自己去阅读这个 Activity 中的代码，另一个是询问负责编写此 Activity 的同事。 假设 SecondActivity 中需要用到两个非常重要的字符串参数，在启动 SecondActivity 的时候必须要传递过来，修改 SecondActivity 中的代码如下： //所有SecondActivity中需要的数据都是通过actionStart()方法的参数传递过来的 public static void actionStart(Context context, String data1, String data2) { Intent intent = new Intent(context, SecondActivity.class); intent.putExtra(&quot;param1&quot;, data1); intent.putExtra(&quot;param2&quot;, data2); context.startActivity(intent); } SecondActivity 所需要的数据在方法参数中全部体现出来了，这样即使不用阅读源代码，不去询问负责编写 SecondActivity 的同事，你也可以非常清晰地知道启动 SecondActivity 需要传递哪些数据。 另外，这样写还简化了启动活动的代码，现在只需要一行代码就可以启动 SecondActivity，如下所示： SecondActivity.actionStart(FirstActivity.this, &quot;data1&quot;, &quot;data2&quot;); 给我们编写的每个活动都添加类似的启动方法，不仅可以让启动活动变得非常简单，还可以节省别人来询问你的时间。 ","link":"https://Petrichoroo.github.io/post/lesslessdi-yi-xing-dai-ma-androidgreatergreater-bi-ji-activity/"},{"title":"《第一行代码 Android》笔记 — 了解Android","content":" 了解 Android 一、Android 系统架构 1. Linux 内核层 2. 系统运行库存 3. 应用框架层 4. 应用层 二、Android 应用开发特色 1. 四大组件 2. 丰富的系统控件 3. SQLite 数据库 4. 强大的多媒体 三、Project 模式的项目结构 app 目录下的结构 build.gradle 文件（app 目录）中的相关配置及属性 四、Android的日志工具 Log 了解 Android 一、Android 系统架构 1. Linux 内核层 Android系统是基于Linux内核的，这一层为 Android 设备的各种硬件提供了底层的驱动、如显示驱动、音频驱动、蓝牙驱动等。 2. 系统运行库存 通过一些C/C++库为 Android 系统提供了主要的特性支持。在这一层还有 Android 运行时库，它主要提供了一些核心库，允许开发者使用 Java 语言来编写 Android 应用。另外还包含了Dalvik虚拟机（5.0 系统之后改为ART运行环境），它使得每一个 Android 应用都能运行在独立的进程中，并且拥有一个自己的虚拟机实例。 3. 应用框架层 主要提供了构建应用程序时可能用到的各种 API，Android 自带的一些核心应用就是使用这些 API 完成的，开发者可以使用这些 API 来构建自己的应用程序。 4. 应用层 所有安装在手机上的应用程序都是属于这一层的，比如系统自带的联系人、短信等程序。 二、Android 应用开发特色 1. 四大组件 Activity：凡是在应用中你看得到的东西，都是放在 Activity 中的。 Service：在后台默默地运行，即使用户退出了应用，Service 仍然是可以继续运行的。 BroadcastReceiver：允许应用接收来自各处的广播消息，比如电话、短信等，也可以向外发出广播消息。 ContentProvider：则为应用程序之间共享数据提供了可能。 2. 丰富的系统控件 Android 系统为开发者提供了丰富的系统控件，也允许开发者定制属于自己的控件。 3. SQLite 数据库 Android 系统自带了这种轻量级、运算速度极快的嵌入式关系型数据库。 4. 强大的多媒体 Android 系统还提供了丰富的多媒体服务，如音乐、视频、录音、拍照等。 三、Project 模式的项目结构 .gradle和.idea Android Studio 自动生成的一些文件。 app 放置项目中的代码、资源等内容。 build 主要包含了一些在编译时自动生成的文件。 gradle 这个目录下包含了gradle wrapper的配置文件。 .gitignore 将指定的目录或文件排除在版本控制之外的。 build.gradle 项目全局的 gradle 构建脚本。 gradle.properties 全局的 gradle 配置文件，在这里配置的属性将会影响到项目中所有的 gradle 编译脚本。 gradlew和gradlew.bat 用于在命令行界面中执行gradle命令，前者是在 Linux 或 Mac 系统中使用的，后者是在 Windows 系统中使用的。 HelloWorld.iml 用于标识这是一个IntelliJ IDEA项目。 local.properties 用于指定本机中的Android SDK路径。 settings.gradle 用于指定项目中所有引入的模块。通常情况下，模块的引入是自动完成的。 app 目录下的结构 build 这个目录和外层的 build 目录类似，也包含了一些在编译时自动生成的文件。 libs 项目中所使用到的第三方jar包都放在 libs 目录下，它会被自动添加到项目的构建路径里。 androidTest 编写 Android Test 测试用例的，可以对项目进行一些自动化测试。 java 放置我们所有Java代码的地方（Kotlin代码也放在这里）。 res 项目中使用到的所有图片、布局、字符串等资源都要存放在这个目录下。 AndroidManifest.xml 整个 Android 项目的配置文件，程序中定义的所有四大组件都需要在这个文件里注 册，另外还可以在这个文件中给应用程序添加权限声明。 test 编写Unit Test测试用例的，是对项目进行自动化测试的另一种方式。 .gitignore 用于将app模块内指定的目录或文件排除在版本控制之外，作用和外层的.gitignore文件类似。 app.iml IntelliJ IDEA项目自动生成的文件。 build.gradle app模块的gradle构建脚本，会指定很多项目构建相关的配置。 proguard-rules.pro 用于指定项目代码的混淆规则。 build.gradle 文件（app 目录）中的相关配置及属性 compileSdkVersion用于指定项目的编译版本。 buildToolsVersion用于指定项目构建工具的版本。 defaultConfig闭包：对项目的更多细节进行配置。 applicationId是每一个应用的唯一标识符，默认会使用创建项目时指定的包。 minSdkVersion用于指定项目最低兼容的 Android 系统版本。 targetSdkVersion指定的值表示你在该目标版本上已经做过了充分的测试，系统将会为你的应用程序启用一些最新的功能和特性。 versionCode用于指定项目的版本号。 versionName用于指定项目的版本名。 testInstrumentationRunner用于在当前项目中启用JUnit测试，你可以为当前项目编写测试用例，以保证功能的正确性和稳定性。 buildTypes闭包：用于指定生成安装文件的相关配置 minifyEnabled用于指定是否对项目的代码进行混淆。 proguardFiles用于指定混淆时使用的规则文件。 dependencies闭包：指定当前项目所有的依赖关系。 本地依赖：对本地的 jar 包或目录添加依赖关系。 库依赖：对项目中的库模块添加依赖关系。 远程依赖：可以对jcenter仓库上的开源项目添加依赖关系。 testImplementation 和androidTestImplementation都是用于声明测试用例库。 四、Android的日志工具 Log Log.v()：用于打印那些最为琐碎的、意义最小的日志信息。对应级别verbose，是 Android 日志里面级别最低的一种。 Log.d()：用于打印一些调试信息，对你调试程序和分析问题应该是有帮助的。对应级别debug。 Log.i()：用于打印一些比较重要的数据，这些数据应该是你非常想看到的、可以帮你分析用户行为。对应级别info。 Log.w()：用于打印一些警告信息，提示程序在这个地方可能会有潜在的风险，最好去修复一下这些出现警告的地方。对应级别warn。 Log.e()：用于打印程序中的错误信息，比如程序进入了catch语句中。错误信息一般代表程序出现严重问题了，必须尽快修复。对应级别error。 ","link":"https://Petrichoroo.github.io/post/lesslessdi-yi-xing-dai-ma-androidgreatergreater-bi-ji-liao-jie-android/"}]}
<html>
<head>
    <meta charset="utf-8" />
<meta name="description" content="" />
<meta name="viewport" content="width=device-width, initial-scale=1" />

<title>Kotlin 基础 | Petrichor</title>

<link rel="shortcut icon" href="https://Petrichoroo.github.io/favicon.ico?v=1662363647663">

<link href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" rel="stylesheet">
<link rel="stylesheet" href="https://Petrichoroo.github.io/styles/main.css">
<!-- <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css"> -->

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages/dockerfile.min.js"></script>
<script src="https://cdn.bootcdn.net/ajax/libs/highlight.js/9.12.0/languages//dart.min.js"></script>

<!-- <script src="https://cdn.jsdelivr.net/npm/moment@2.27.0/moment.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.slim.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js"></script> -->
<!-- <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/js/bootstrap.min.js"></script> -->
<!-- DEMO JS -->
<!--<script src="media/scripts/index.js"></script>-->



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.css">
    
</head>
<body>
<div class="main gt-bg-theme-color-first">
    <nav class="navbar navbar-expand-lg">
    <a class="navbar-brand" href="/">
        <img class="user-avatar" src="/images/avatar.png" alt="头像">
        <div class="site-name gt-c-content-color-first">
            Petrichor
        </div>
    </a>
    <button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent"
        aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation" id="changeNavbar">
        <i class="fas fa-bars gt-c-content-color-first" style="font-size: 18px"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
        <div class="navbar-nav mr-auto" style="text-align: center">
            
            <div class="nav-item">
                
                <a href="/" class="menu gt-a-link">
                    首页
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/archives" class="menu gt-a-link">
                    归档
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/tags" class="menu gt-a-link">
                    标签
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="/post/about" class="menu gt-a-link">
                    关于
                </a>
                
            </div>
            
            <div class="nav-item">
                
                <a href="https://github.com/Petrichoroo?tab=repositories" class="menu gt-a-link" target="_blank">
                    友链
                </a>
                
            </div>
            
        </div>
        <div style="text-align: center">
            <form id="gridea-search-form" style="position: relative" data-update="1662363647663"
                action="/search/">
                <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
                <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
        </div>
    </div>
</nav>
<script>
    /* 移动端导航栏展开/收起切换 */
    document.getElementById('changeNavbar').onclick = () => {
        var element = document.getElementById('navbarSupportedContent');
        if (element.style.display === 'none' || element.style.display === '') {
            element.style.display = 'block';
        } else {
            element.style.display = 'none';
        }
    }
</script>

    <div class="post-container">
        <div class="post-detail gt-bg-theme-color-second">
            <article class="gt-post-content">
                <h2 class="post-title">
                    Kotlin 基础
                </h2>
                <div class="post-info">
                    <time class="post-time gt-c-content-color-first">
                        · 2022-08-15 ·
                    </time>
                    
                        <a href="https://Petrichoroo.github.io/tag/f0WJ2wxNg/" class="post-tags">
                            # Kotlin
                        </a>
                    
                </div>
                <div class="post-content">
                    <p><ul class="markdownIt-TOC">
<li><a href="#kotlin">Kotlin</a>
<ul>
<li><a href="#kotlin-%E8%AF%AD%E8%A8%80%E7%AE%80%E4%BB%8B">Kotlin 语言简介</a></li>
<li><a href="#%E5%8F%98%E9%87%8F%E5%92%8C%E5%87%BD%E6%95%B0">变量和函数</a>
<ul>
<li><a href="#%E5%8F%98%E9%87%8F">变量</a></li>
<li><a href="#%E5%87%BD%E6%95%B0">函数</a>
<ul>
<li><a href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%AF%E8%A7%81%E6%80%A7%E4%BF%AE%E9%A5%B0%E7%AC%A6">函数的可见性修饰符</a></li>
<li><a href="#kotlin-%E5%87%BD%E6%95%B0%E7%9A%84%E8%AF%AD%E6%B3%95%E7%B3%96">Kotlin 函数的语法糖</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E7%A8%8B%E5%BA%8F%E7%9A%84%E9%80%BB%E8%BE%91%E6%8E%A7%E5%88%B6">程序的逻辑控制</a>
<ul>
<li><a href="#if-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5">if 条件语句</a></li>
<li><a href="#when-%E6%9D%A1%E4%BB%B6%E8%AF%AD%E5%8F%A5">when 条件语句</a></li>
<li><a href="#%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5">循环语句</a></li>
</ul>
</li>
<li><a href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B">面向对象编程</a>
<ul>
<li><a href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1">类与对象</a></li>
<li><a href="#%E7%BB%A7%E6%89%BF%E4%B8%8E%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0">继承与构造函数</a></li>
<li><a href="#%E6%8E%A5%E5%8F%A3">接口</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E4%B8%8E%E5%8D%95%E4%BE%8B%E7%B1%BB">数据类与单例类</a></li>
</ul>
</li>
<li><a href="#lambda-%E7%BC%96%E7%A8%8B">Lambda 编程</a>
<ul>
<li><a href="#%E9%9B%86%E5%90%88%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E9%81%8D%E5%8E%86">集合的创建与遍历</a>
<ul>
<li><a href="#list">List</a></li>
<li><a href="#set">Set</a></li>
<li><a href="#map">Map</a></li>
</ul>
</li>
<li><a href="#%E9%9B%86%E5%90%88%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F-api">集合的函数式 API</a></li>
<li><a href="#java-%E5%87%BD%E6%95%B0%E5%BC%8F-api-%E7%9A%84%E4%BD%BF%E7%94%A8">Java 函数式 API 的使用</a></li>
</ul>
</li>
<li><a href="#%E7%A9%BA%E6%8C%87%E9%92%88%E6%A3%80%E6%9F%A5">空指针检查</a>
<ul>
<li><a href="#%E5%8F%AF%E7%A9%BA%E7%B1%BB%E5%9E%8B%E7%B3%BB%E7%BB%9F">可空类型系统</a></li>
<li><a href="#%E5%88%A4%E7%A9%BA%E8%BE%85%E5%8A%A9%E5%B7%A5%E5%85%B7">判空辅助工具</a></li>
</ul>
</li>
<li><a href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%86%85%E5%B5%8C%E8%A1%A8%E8%BE%BE%E5%BC%8F">字符串内嵌表达式</a></li>
<li><a href="#%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0%E9%BB%98%E8%AE%A4%E5%80%BC">函数的参数默认值</a></li>
</ul>
</li>
</ul>
</p>
<h1 id="kotlin">Kotlin</h1>
<hr>
<h2 id="kotlin-语言简介">Kotlin 语言简介</h2>
<blockquote>
<p>  Google 在 2017 年的 I/O 大会上宣布，Kotlin 正式成为 Android 的一级开发语言，和 Java 平起平坐，Android Studio 也对 Kotlin 进行了全面的支持。<br>
　　两年之后，Google 又在 2019 年的 I/O 大会上宣布，Kotlin 已经成为 Android 的第一开发语言，虽然 Java 仍然可以继续使用，但 Google 更加推荐开发者使用 Kotlin 来编写 Android 应用程序，并且未来提供的官方 API 也将会优先考虑 Kotlin 版本。</p>
</blockquote>
<p>  编程语言大致可以分为两类：编译型语言和解释型语言。<br>
　　编译型语言的特点是编译器会将我们编写的源代码一次性地编译成计算机可识别的二进制文件，然后计算机直接执行，像 C 和 C++ 都属于编译型语言。<br>
　　解释型语言则完全不一样，它有一个解释器，在程序运行时，解释器会一行行地读取我们编写的源代码，然后实时地将这些源代码解释成计算机可识别的二进制数据后再执行，因此解释型语言通常效率会差一些，像 Python 和 JavaScript 都属于解释型语言。<br>
　　虽然 Java 代码是要先编译再运行的，但是 Java 代码编译之后生成的并不是计算机可识别的二进制文件，而是一种特殊的<code>class</code>文件，这种 class 文件只有 Java 虚拟机才能识别，而这个虚拟机担当的其实就是解释器的角色，它会在程序运行时将编译后的 class 文件解释成计算机可识别的二进制数据后再执行。因此，准确来讲，Java 属于解释型语言。<br>
　　Java 虚拟机（Android 中叫 ART，一种移动优化版的虚拟机）不关心 class 文件是从 Java 编译来的，还是从 Kotlin 编译来的，只要是符合规格的 class 文件，它都能识别。因此，JetBrains 才能以一个第三方公司的身份设计出一门用来开发 Android 应用程序的编程语言。<br>
　　Kotlin 的语法更加简洁，对于同样的功能，使用 Kotlin 开发的代码量，可能会比使用 Java 开发的减少 50% 甚至更多。<br>
　　Kotlin 的语法更加高级，相比于 Java 比较老旧的语法，Kotlin 增加了很多现代高级语言的语法特性，使得开发效率大大提升。还有，Kotlin 在语言安全性方面下了很多工夫，几乎杜绝了空指针这个全球崩溃率最高的异常。<br>
　　Kotlin 和 Java 是 100% 兼容的。Kotlin 可以直接调用使用 Java 编写的代码，也可以无缝使用 Java 第三方的开源库。</p>
<h2 id="变量和函数">变量和函数</h2>
<h3 id="变量">变量</h3>
<p>  Kotlin 中定义一个变量，只允许在变量前声明两种关键字：<code>val</code>和<code>var</code>。</p>
<ul>
<li>
<p><code>val</code>（value 的简写）：用来声明一个不可变的变量，这种变量在初始赋值之后就再也不能重新赋值，对应 Java 中的<code>final</code>变量。</p>
</li>
<li>
<p><code>var</code>（variable 的简写）：用来声明一个可变的变量，这种变量在初始赋值之后仍然可以再被重新赋值，对应 Java 中的非 final 变量。</p>
</li>
</ul>
<p>  Kotlin 拥有出色的类型推导机制。若你要把一个整数赋值给 a，那么 a 就只能是整型变量，而如果你要把一个字符串赋值给 a 的话，那么 a 就会被自动推导成字符串变量。</p>
<pre><code class="language-java">    fun main() {
        val a = 10
        println(&quot;a = &quot; + a)
    }
</code></pre>
<blockquote>
<p>  注意，Kotlin 每一行代码的结尾是不用加分号的。</p>
</blockquote>
<p>  如果我们对一个变量延迟赋值的话，Kotlin 就无法自动推导它的类型了。这时候就需要显式地声明变量类型。</p>
<pre><code class="language-java">    val a: Int = 10
</code></pre>
<blockquote>
<p>  使用 val 关键字声明的变量无法被重新赋值，改用 var 即可。</p>
</blockquote>
<p>  Kotlin 完全抛弃了 Java 中的基本数据类型，全部使用了对象数据类型。在 Java 中int 是关键字，而在 Kotlin 中 Int 变成了一个类，它拥有自己的方法和继承结构。</p>
<blockquote>
<p>  永远优先使用 val 来声明一个变量，而当 val 没有办法满足你的需求时再使用 var。这样设计出来的程序会更加健壮，也更加符合高质量的编码规范。</p>
</blockquote>
<h3 id="函数">函数</h3>
<p>  Kotlin 允许我们自由地定义函数，语法规则如下：</p>
<pre><code class="language-java">    fun methodName(param1: Int, param2: Int): Int {
        return 0
    }
</code></pre>
<p>  <code>fun</code>（function的简写）是定义函数的关键字，无论你定义什么函数，都一定要使用 fun 来声明。<br>
　　 参数的声明格式是“参数名: 参数类型”。<br>
　　 参数括号后面的那部分是可选的，用于声明该函数会返回什么类型的数据。</p>
<h4 id="函数的可见性修饰符">函数的可见性修饰符</h4>
<p>  Kotlin 中有 4 种函数的可见性修饰符，分别是<code>public</code>、<code>private</code>、<code>protected</code>和<code>internal</code>，需要使用哪种修饰符时，直接定义在 fun 关键字的前面即可。<br>
　　Java 和 Kotlin 函数可见性修饰符对照表：<br>
<img src="https://Petrichoroo.github.io/post-images/1660553474774.png" alt="" loading="lazy"></p>
<h4 id="kotlin-函数的语法糖">Kotlin 函数的语法糖</h4>
<p>  编写一个名为 largerNumber() 的函数，其作用是：接收两个整型参数，然后总是返回两个参数中更大的那个数，如下所示：</p>
<pre><code class="language-java">    fun largerNumber(num1: Int, num2: Int): Int {
        return max(num1, num2)
    }
</code></pre>
<blockquote>
<p>  max() 函数是 Kotlin 提供的一个内置函数，它的作用就是返回两个参数中更大的那个数，这里给其做了一层封装而已。</p>
</blockquote>
<p>  Kotlin 函数的语法糖：当一个函数中只有一行代码时，Kotlin 允许我们不必编写函数体，可以直接将唯一的一行代码写在函数定义的尾部，中间用等号连接即可。因此可以将代码简化成如下形式：</p>
<pre><code class="language-java">    fun largerNumber(num1: Int, num2: Int): Int = max(num1, num2)
</code></pre>
<p>  使用这种语法，由于 Kotlin 出色的类型推导机制，return 关键字也可以省略了，等号足以表达返回值的意思。代码可以进一步简化成如下形式：</p>
<pre><code class="language-java">    fun largerNumber(num1: Int, num2: Int) = max(num1, num2)
</code></pre>
<h2 id="程序的逻辑控制">程序的逻辑控制</h2>
<blockquote>
<p>  Kotlin 中的条件语句主要有两种实现方式：if 和 when。</p>
</blockquote>
<h3 id="if-条件语句">if 条件语句</h3>
<p>  使用 if 判断用来实现 largerNumber() 函数，写法如下：</p>
<pre><code class="language-java">    fun largerNumber(num1: Int, num2: Int): Int {
        var value = 0
        if (num1 &gt; num2) {
            value = num1
        } else {
            value = num2
        }
        return value
    }
</code></pre>
<p>  这里使用了 var 关键字来声明 value 这个变量，因为其涉及到了重新赋值。<br>
　　Kotlin 中的 if 语句相比于 Java 有一个额外的功能，它是可以有返回值的，返回值就是 if 语句每一个条件中最后一行代码的返回值。因此，上述代码就可以简化成如下形式：</p>
<pre><code class="language-java">    fun largerNumber(num1: Int, num2: Int): Int {
        val value = if (num1 &gt; num2) {
            num1
        } else {
            num2
        }
        return value
    }
</code></pre>
<p>  你会发现其实 value 变量也是多余的，同时根据之前所学的语法糖，可以将代码进一步简化：</p>
<pre><code class="language-java">    fun largerNumber(num1: Int, num2: Int) = if (num1 &gt; num2) num1 else num2
</code></pre>
<h3 id="when-条件语句">when 条件语句</h3>
<p>  Kotlin 中的 when 语句有点类似于 Java 中的 switch 语句，但它又远比 switch 语句强大得多。<br>
　　这里编写一个查询考试成绩的功能，输入一个学生的姓名，返回该学生考试的分数。如果使用 if 语句实现，代码会比较冗余，因此当判断条件非常多的时候，应该考虑使用 when 语句。如下所示：</p>
<pre><code class="language-java">    fun getScore(name: String) = when (name) {
        &quot;Tom&quot; -&gt; 86
        &quot;Jim&quot; -&gt; 77
        &quot;Jack&quot; -&gt; 95
        &quot;Lily&quot; -&gt; 100
        else -&gt; 0
    }
</code></pre>
<p>  when 语句和 if 语句一样，也是可以有返回值的，因此仍然可以使用单行代码函数的语法糖。<br>
　　when 语句允许传入一个任意类型的参数，然后可以在 when 的结构体中定义一系列的条件，格式是：</p>
<pre><code class="language-java">    匹配值 -&gt; { 执行逻辑 }
</code></pre>
<p>  除了精确匹配之外，when 语句还允许进行类型匹配，如下：</p>
<pre><code class="language-java">    fun checkNumber(num: Number) {
        when (num) {
            is Int -&gt; println(&quot;number is Int&quot;)
            is Double -&gt; println(&quot;number is Double&quot;)
            else -&gt; println(&quot;number not support&quot;)
        }
    }
</code></pre>
<p>  <code>is</code>关键字就是类型匹配的核心，它相当于 Java 中的 instanceof 关键字。<br>
　　when 语句还有一种不带参数的用法，虽然这种用法可能不太常用，但有的时候却能发挥很强的扩展性，如下所示：</p>
<pre><code class="language-java">    fun getScore(name: String) = when {
        name == &quot;Tom&quot; -&gt; 86
        name == &quot;Jim&quot; -&gt; 77
        name == &quot;Jack&quot; -&gt; 95
        name == &quot;Lily&quot; -&gt; 100
        else -&gt; 0
    }
</code></pre>
<blockquote>
<p>  Kotlin 中判断字符串或对象是否相等可以直接使用<code>==</code>关键字。</p>
</blockquote>
<p>  这种用法是将判断的表达式完整地写在 when 的结构体当中。这种无参数的 when 语句写起来比较冗余，但有些场景必须使用这种写法才能实现。<br>
　　假设所有名字以 Tom 开头的人，他的分数都是 86 分，这种场景如果用带参数的 when 语句来写就无法实现，而使用不带参数的when语句就可以这样写：</p>
<pre><code class="language-java">    fun getScore(name: String) = when {
        name.startsWith(&quot;Tom&quot;) -&gt; 86
        ...
        else -&gt; 0
    }
</code></pre>
<p>  现在不管你传入的名字是 Tom 还是 Tommy，只要是以 Tom 开头的名字，他的分数就是 86 分。</p>
<h3 id="循环语句">循环语句</h3>
<p>  Kotlin 提供了 while 循环和 for 循环，其中 while 循环不管是在语法还是使用技巧上都和 Java 中的 while 循环没有任何区别。<br>
　　Java 中常用的 for-i 循环在 Kotlin 中直接被舍弃了，而 Java 的另一种 for-each 循环则被 Kotlin 进行了大幅度的加强，变成了<code>for-in</code>循环。<br>
　　首先可以使用如下 Kotlin 代码来表示一个区间：</p>
<pre><code class="language-java">    val range = 0..10
</code></pre>
<blockquote>
<p>  两端都是闭区间，即 [0,10]。</p>
</blockquote>
<p>  其中，<code>..</code>是创建两端闭区间的关键字，在其两边指定区间的左右端点就可以创建一个区间。<br>
　　有了区间之后，我们就可以通过<code>for-in</code>循环来遍历这个区间：</p>
<pre><code class="language-java">    fun main() {
        for (i in 0..10) {
            println(i)
        }
    }
</code></pre>
<p>  Kotlin 中可以使用<code>until</code>关键字来创建一个左闭右开的区间，如下所示：</p>
<pre><code class="language-java">    val range = 0 until 10
</code></pre>
<blockquote>
<p>  左闭右开，即 [0,10)。</p>
</blockquote>
<p>  默认情况下，for-in 循环每次执行循环时会在区间范围内递增 1，可以使用<code>step</code>关键字跳过其中的一些元素，如下：</p>
<pre><code class="language-java">    fun main() {
        for (i in 0 until 10 step 2) {
            println(i)
        }
    }
</code></pre>
<p>  若想创建一个降序的区间，可以使用<code>downTo</code>关键字，如下：</p>
<pre><code class="language-java">    fun main() {
        for (i in 10 downTo 1) {
            println(i)
        }
    }
</code></pre>
<blockquote>
<p>  [10, 1] 的降序区间</p>
</blockquote>
<p>  若有一些特殊场景使用<code>for-in</code>循环无法实现，可以改用<code>while</code>循环。</p>
<h2 id="面向对象编程">面向对象编程</h2>
<blockquote>
<p>  面向对象的语言是可以创建类的。类就是对事物的一种封装，类中可以拥有自己的字段和函数，字段表示该类所拥有的属性，函数则表示该类可以有哪些行为。</p>
</blockquote>
<h3 id="类与对象">类与对象</h3>
<p>  Kotlin 中也是使用<code>class</code>关键字来声明一个类的。创建一个 Person 类，并为其加入字段和函数，如下：</p>
<pre><code class="language-java">    class Person {
        var name = &quot;&quot;
        var age = 0
        fun eat() {
            println(name + &quot; is eating. He is &quot; + age + &quot; years old.&quot;)
        }
    }
</code></pre>
<p>  这里使用<code>var</code>关键字创建两个字段，因为需要在创建对象之后再指定具体的姓名和年龄。<br>
　　对这个类进行实例化，如下：</p>
<pre><code class="language-java">    val p = Person()
</code></pre>
<p>  Kotlin 中实例化一个类的方式和 Java 是基本类似的，只是去掉了 new 关键字而已。</p>
<h3 id="继承与构造函数">继承与构造函数</h3>
<blockquote>
<p>  Student 类去继承 Person 类，这样 Student 就自动拥有了 Person 中的字段和函数，另外还可以定义自己独有的字段和函数。</p>
</blockquote>
<p>  创建一个 Student 类，并为其加入字段，如下：</p>
<pre><code class="language-java">    class Student {
        var sno = &quot;&quot;    //学号
        var grade = 0   //年级
    }
</code></pre>
<p>  现在两个类之间是没有任何继承关系的，想要让 Student 类继承 Person 类，需要做两件事：</p>
<ol>
<li>使 Person 类可以被继承。在 Kotlin 中任何一个非抽象类默认都是不可以被继承的，相当于 Java 中给类声明了 final 关键字。</li>
</ol>
<blockquote>
<p>  抽象类本身是无法创建实例的，一定要由子类去继承它才能创建实例。</p>
</blockquote>
<p>可以给类加上<code>open</code>关键字，就是在主动告诉 Kotlin 编译器，这个类是专门为继承而设计的，如下：</p>
<pre><code class="language-java"> open class Person {
     ...
 }
</code></pre>
<ol start="2">
<li>要让 Student 类继承 Person 类。在 Java 中继承的关键字是<code>extends</code>，而在 Kotlin中变成了一个冒号，写法如下：</li>
</ol>
<pre><code class="language-java">    class Student : Person() {
        var sno = &quot;&quot;
        var grade = 0
    }
</code></pre>
<p>  Person 类的后面要加上一对括号是因为涉及了主构造函数、次构造函数等方面的知识。</p>
<p>  Kotlin 将构造函数分成了两种：主构造函数和次构造函数。<br>
　　主构造函数将会是你最常用的构造函数，每个类默认都会有一个不带参数的主构造函数，当然也可以显式地给它指明参数。主构造函数的特点是没有函数体，直接定义在类名的后面即可。比如下面这种写法：</p>
<pre><code class="language-java">    class Student(val sno: String, val grade: Int) : Person() {
    }
</code></pre>
<p>  这里将学号和年级这两个字段都放到了主构造函数当中，这就表明在对 Student 类进行实例化的时候，必须传入构造函数中要求的所有参数。比如：</p>
<pre><code class="language-java">    val student = Student(&quot;a123&quot;, 5)
</code></pre>
<blockquote>
<p>  由于构造函数中的参数是在创建实例的时候传入的，不像之前的写法那样还得重新赋值，因此可以将参数全部声明成 val。</p>
</blockquote>
<p>  主构造函数没有函数体，但可以通过<code>init</code>结构体在主构造函数中编写一些逻辑，如下：</p>
<pre><code class="language-java">    class Student(val sno: String, val grade: Int) : Person() {
        init {
            println(&quot;sno is &quot; + sno)
            println(&quot;grade is &quot; + grade)
        }
    }
</code></pre>
<p>  在 Kotlin 中，子类中的构造函数必须调用父类中的构造函数。可是主构造函数并没有函数体，怎样去调用父类的构造函数呢？<br>
　　Kotlin 采用的设计方式是：子类的主构造函数调用父类中的哪个构造函数，在继承的时候通过括号来指定。因此，对于之前的那段代码，如下：</p>
<pre><code class="language-java">    class Student(val sno: String, val grade: Int) : Person() {
    }
</code></pre>
<p>  在这里，Person 类后面的一对空括号表示 Student 类的主构造函数在初始化的时候会调用 Person 类的无参数构造函数，即使在无参数的情况下，这对括号也不能省略。<br>
　　如果将 Person 改造一下，将 name 和 age 字段都放到主构造函数当中，如下所示：</p>
<pre><code class="language-java">    open class Person(val name: String, val age: Int) {
        ...
    }
</code></pre>
<p>  此时 Student 类一定会报错，因为 Person 类后面的空括号表示要去调用 Person 类中无参的构造函数，但是 Person 类现在已经没有无参的构造函数了。<br>
　　为了解决这个问题，可以在 Student 类的主构造函数中加上 name 和 age 这两个参数，再将这两个参数传给 Person 类的构造函数，代码如下所示：</p>
<pre><code class="language-java">    class Student(val sno: String, val grade: Int, name: String, age: Int): Person(name, age) {
        ...
    }
</code></pre>
<p>  注意，在 Student 类的主构造函数中增加 name 和 age 这两个字段时，不能再将它们声明成<code>val</code>，因为在主构造函数中声明成 val 或者 var 的参数将自动成为该类的字段，这就会导致和父类中同名的 name 和 age 字段造成冲突。<br>
　　现在就可以通过如下代码来创建一个 Student 类的实例：</p>
<pre><code class="language-java">    val student = Student(&quot;a123&quot;, 5, &quot;Jack&quot;, 19)
</code></pre>
<p>  下面来说次构造函数，其实我们几乎是用不到次构造函数的，Kotlin 提供了一个给函数设定参数默认值的功能，基本上可以替代次构造函数的作用。<br>
　　任何一个类只能有一个主构造函数，但是可以有多个次构造函数。次构造函数也可以用于实例化一个类，这一点和主构造函数没有什么不同，只不过它是有函数体的。<br>
　　Kotlin 规定，当一个类既有主构造函数又有次构造函数时，所有的次构造函数都必须调用主构造函数（包括间接调用），示例代码如下：</p>
<pre><code class="language-java">    class Student(val sno: String, val grade: Int, name: String, age: Int) : Person(name, age) {
        constructor(name: String, age: Int) : this(&quot;&quot;, 0, name, age) {
        }
        constructor() : this(&quot;&quot;, 0) {
        }
    }
</code></pre>
<p>  次构造函数是通过<code>constructor</code>关键字来定义的，这里我们定义了两个次构造函数：</p>
<ul>
<li>
<p>第一个次构造函数接收 name 和 age 参数，然后它又通过<code>this</code>关键字调用了主构造函数，并将 sno 和 grade 这两个参数赋值成初始值。</p>
</li>
<li>
<p>第二个次构造函数不接收任何参数，它通过<code>this</code>关键字调用了我们刚才定义的第一个次构造函数，并将 name 和 age 参数也赋值成初始值，由于第二个次构造函数间接调用了主构造函数，因此这仍然是合法的。</p>
</li>
</ul>
<p>  这样就有 3 种方式来对 Student 类进行实体化，分别是：</p>
<ul>
<li>
<p>通过不带参数的构造函数。</p>
</li>
<li>
<p>通过带两个参数的构造函数。</p>
</li>
<li>
<p>通过带 4 个参数的构造函数。</p>
</li>
</ul>
<p>  对应代码如下所示：</p>
<pre><code class="language-java">    val student1 = Student()
    val student2 = Student(&quot;Jack&quot;, 19)
    val student3 = Student(&quot;a123&quot;, 5, &quot;Jack&quot;, 19)
</code></pre>
<p>  有一种非常特殊的情况：类中只有次构造函数，没有主构造函数。<br>
　　这种情况真的十分少见，但在 Kotlin 中是允许的。当一个类没有显式地定义主构造函数且定义了次构造函数时，它就是没有主构造函数的。示例代码如下：</p>
<pre><code class="language-java">    class Student : Person {
        constructor(name: String, age: Int) : super(name, age) {
        }
    }
</code></pre>
<p>  这里 Student 类的后面没有显式地定义主构造函数且定义了次构造函数，因此它是没有主构造函数的，所以继承 Person 类的时候也就不需要再加上括号了。<br>
　　由于没有主构造函数，次构造函数只能直接调用父类的构造函数，上述代码也是将 this关键字换成了<code>super</code>关键字。</p>
<h3 id="接口">接口</h3>
<blockquote>
<p>  接口是用于实现多态编程的重要组成部分，可以在接口中定义一系列的抽象行为，然后由具体的类去实现。</p>
</blockquote>
<p>  创建一个 Study 接口，并在其中添加几个学习相关的函数，注意接口中的函数不要求有函数体，代码如下所示：</p>
<pre><code class="language-java">    interface Study {
        fun readBooks()
        fun doHomework()
    }
</code></pre>
<p>  接下来就可以让 Student 类去实现 Study 接口，代码如下：</p>
<pre><code class="language-java">    class Student(name: String, age: Int) : Person(name, age), Study {
        override fun readBooks() {
            println(name + &quot; is reading.&quot;)
        }
        override fun doHomework() {
            println(name + &quot; is doing homework.&quot;)
        }
    }
</code></pre>
<blockquote>
<p>  Kotlin 中使用 override 关键字来重写父类或者实现接口中的函数。</p>
</blockquote>
<p>  Java 中继承使用的关键字是 extends，实现接口使用的关键字是 implements，而 Kotlin 中统一使用冒号，中间用逗号进行分隔。上述代码就表示 Student 类继承了 Person 类，同时还实现了 Study 接口。</p>
<p>  Kotlin 还增加了一个额外的功能：允许对接口中定义的函数进行默认实现，修改 Study 接口中的代码，如下所示：</p>
<pre><code class="language-java">    interface Study {
        fun readBooks()
        fun doHomework() {
            println(&quot;do homework default implementation.&quot;)
        }
    }
</code></pre>
<p>  如果接口中的一个函数拥有了函数体，这个函数体中的内容就是它的默认实现。现在当一个类去实现 Study 接口时，只会强制要求实现<code>readBooks()</code>函数，而<code>doHomework()</code>函数则可以自由选择实现或者不实现，不实现时就会自动使用默认的实现逻辑。</p>
<h3 id="数据类与单例类">数据类与单例类</h3>
<blockquote>
<p>  在一个规范的系统架构中，数据类通常占据着非常重要的角色，它们用于将服务器端或数据库中的数据映射到内存中，为编程逻辑提供数据模型的支持。</p>
</blockquote>
<p>  数据类通常需要重写<code>equals()</code>、<code>hashCode()</code>、<code>toString()</code>这几个方法。其中：</p>
<ul>
<li>
<p><code>equals()</code>：用于判断两个数据类是否相等。</p>
</li>
<li>
<p><code>hashCode()</code>：作为 equals() 的配套方法，也需要一起重写，否则会导致 HashMap、HashSet 等 hash 相关的系统类无法正常工作。</p>
</li>
<li>
<p><code>toString()</code>：用于提供更清晰的输入日志，否则一个数据类默认打印出来的就是一行内存地址。</p>
</li>
</ul>
<p>  这里新构建一个手机数据类，只有品牌和价格这两个字段，若使用 Java 来实现是比较复杂的，关键是这些代码还是一些没有实际逻辑意义的代码，只是为了让它拥有数据类的功能而已。<br>
　　而同样的功能使用 Kotlin 来实现就会变得极其简单，新建一个 Cellphone 类，并编写如下代码：</p>
<pre><code class="language-java">    data class Cellphone(val brand: String, val price: Double)
</code></pre>
<p>  神奇的地方就在于<code>data</code>这个关键字，当在一个类前面声明了 data 关键字时，就表明你希望这个类是一个数据类，Kotlin 会根据主构造函数中的参数帮你将 equals()、hashCode()、toString() 等固定且无实际逻辑意义的方法自动生成，从而大大减少了开发的工作量。</p>
<p>  单例模式是最常用、最基础的设计模式之一，它可以用于避免创建重复的对象。比如我们希望某个类在全局最多只能拥有一个实例，这时就可以使用单例模式。<br>
　　在 Kotlin 中创建一个单例类的方式极其简单，在创建类的时候，创建类型选择<code>Object</code>即可，生成的代码如下：</p>
<pre><code class="language-java">    object Singleton {
    }
</code></pre>
<p>  现在<code>Singleton</code>就已经是一个单例类了，可以直接在这个类中编写需要的函数，示例如下：</p>
<pre><code class="language-java">    object Singleton {
        fun singletonTest() {
            println(&quot;singletonTest is called.&quot;)
        }
    }
</code></pre>
<p>  而调用单例类中的函数也很简单，如下：</p>
<pre><code class="language-java">    Singleton.singletonTest()
</code></pre>
<p>  这种写法看上去像是静态方法的调用，但其实 Kotlin 在背后自动帮我们创建了一个<code>Singleton</code>类的实例，并且保证全局只会存在一个 Singleton 实例。</p>
<h2 id="lambda-编程">Lambda 编程</h2>
<h3 id="集合的创建与遍历">集合的创建与遍历</h3>
<blockquote>
<p>  传统意义上的集合主要就是 List 和 Set，再广泛一点的话，像 Map 这样的键值对数据结构也可以包含进来。</p>
</blockquote>
<h4 id="list">List</h4>
<p>  现在创建一个包含许多水果名称的集合。若使用 Java 实现，首先会创建一个 ArrayList 的实例，然后将水果的名称一个个添加到集合中。当然，在 Kotlin 中也可以这么做：</p>
<pre><code class="language-java">    val list = ArrayList&lt;String&gt;()
    list.add(&quot;Apple&quot;)
    list.add(&quot;Banana&quot;)
    list.add(&quot;Orange&quot;)
    list.add(&quot;Pear&quot;)
    list.add(&quot;Grape&quot;)
</code></pre>
<p>  但是这种初始化集合的方式比较烦琐，为此 Kotlin 专门提供了一个内置的<code>listOf()</code>函数来简化初始化集合的写法，如下所示：</p>
<pre><code class="language-java">    val list = listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;)
</code></pre>
<p>  <code>for-in</code>循环不仅可以用来遍历区间，还可以用来遍历集合，如下：</p>
<pre><code class="language-java">    fun main() {
        val list = listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;)
        for (fruit in list) {
            println(fruit)
        }
    }
</code></pre>
<p>  需要注意的是，<code>listOf()</code>函数创建的是一个不可变的 List 集合。</p>
<blockquote>
<p>  不可变的集合指的就是该集合只能用于读取，无法对集合进行添加、修改或删除操作。</p>
</blockquote>
<p>  可以使用<code>mutableListOf()</code>函数创建一个可变的 List 集合。</p>
<h4 id="set">Set</h4>
<blockquote>
<p>  Set 集合的用法几乎与 List 一模一样。<br>
　　<br>
  创建 Set 集合的方式：<code>setOf()</code>和<code>mutableSetOf()</code>函数。</p>
</blockquote>
<blockquote>
<p>  注意，Set 集合中不可以存放重复元素，若存放了多个相同的元素，只会保留其中一份。</p>
</blockquote>
<h4 id="map">Map</h4>
<p>  Map 是一种键值对形式的数据结构，因此在用法上和 List、Set 集合有较大的不同。传统的 Map 用法是先创建一个 HashMap 的实例，然后将一个个键值对数据添加到 Map 中。比如这里给每种水果设置一个对应的编号，如下：</p>
<pre><code class="language-java">    val map = HashMap&lt;String, Int&gt;()
    map.put(&quot;Apple&quot;, 1)
    map.put(&quot;Banana&quot;, 2)
    map.put(&quot;Orange&quot;, 3)
    map.put(&quot;Pear&quot;, 4)
    map.put(&quot;Grape&quot;, 5)
</code></pre>
<p>  这种写法和 Java 比较相似，但在 Kotlin 中并不建议使用<code>put()</code>和<code>get()</code>方法来对 Map 进行添加和读取数据操作，而是更加推荐使用一种类似于数组下标的语法结构，如下：</p>
<pre><code class="language-java">    val map = HashMap&lt;String, Int&gt;()
    map[&quot;Apple&quot;] = 1
    map[&quot;Banana&quot;] = 2
    map[&quot;Orange&quot;] = 3
    map[&quot;Pear&quot;] = 4
    map[&quot;Grape&quot;] = 5
</code></pre>
<p>  Kotlin 毫无疑问地提供了一对<code>mapOf()</code>和<code>mutableMapOf()</code>函数来继续简化 Map 的用法。我们可以直接传入初始化的键值对组合来完成对 Map 集合的创建，如下：</p>
<pre><code class="language-java">    val map = mapOf(&quot;Apple&quot; to 1, &quot;Banana&quot; to 2, &quot;Orange&quot; to 3, &quot;Pear&quot; to 4, &quot;Grape&quot; to 5)
</code></pre>
<blockquote>
<p>  <code>to</code>并不是关键字，而是一个<code>infix</code>函数。</p>
</blockquote>
<p>  使用<code>for-in</code>循环遍历 Map 集合中的数据，如下：</p>
<pre><code class="language-java">    fun main() {
        ...
        for ((fruit, number) in map) {
            println(&quot;fruit is &quot; + fruit + &quot;, number is &quot; + number)
        }
    }
</code></pre>
<p>  这里将 Map 的键值对变量一起声明到了一对括号里面，这样当进行循环遍历时，每次遍历的结果就会赋值给这两个键值对变量。</p>
<h3 id="集合的函数式-api">集合的函数式 API</h3>
<p>  Lambda 就是一小段可以作为参数传递的代码，但是通常不建议在 Lambda 表达式中编写太长的代码，否则可能会影响代码的可读性。<br>
　　Lambda 表达式的语法结构：</p>
<pre><code class="language-java">    {参数名1: 参数类型, 参数名2: 参数类型 -&gt; 函数体}
</code></pre>
<p>  最外层是一对大括号，如果有参数传入到 Lambda 表达式中的话，我们还需要声明参数列表，参数列表的结尾使用一个<code>-&gt;</code>符号，表示参数列表的结束以及函数体的开始，函数体中可以编写任意行代码，并且最后一行代码会自动作为 Lambda 表达式的返回值。<br>
　　在一个水果集合里面找到单词最长的那个水果，如下所示：</p>
<pre><code class="language-java">    val list = listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;, &quot;Watermelon&quot;)
    val lambda = { fruit: String -&gt; fruit.length }
    val maxLengthFruit = list.maxBy(lambda)
</code></pre>
<p>  <code>maxBy</code>就是一个普通的函数，只不过它接收的是一个 Lambda 类型的参数，并且会在遍历集合时将每次遍历的值作为参数传递给 Lambda 表达式。</p>
<blockquote>
<p>  maxBy 函数的工作原理是根据传入的条件来遍历集合，从而找到该条件下的最大值。</p>
</blockquote>
<p>  上面的代码需要简化的地方很多，首先，我们不需要专门定义一个 lambda 变量，而是可以直接将 lambda 表达式传入 maxBy 函数当中，因此第一步简化如下所示：</p>
<pre><code class="language-java">    val maxLengthFruit = list.maxBy({ fruit: String -&gt; fruit.length })
</code></pre>
<p>  然后 Kotlin 规定，当 Lambda 参数是函数的最后一个参数时，可以将 Lambda 表达式移到函数括号的外面，如下所示：</p>
<pre><code class="language-java">    val maxLengthFruit = list.maxBy() { fruit: String -&gt; fruit.length }
</code></pre>
<p>  接下来，如果 Lambda 参数是函数的唯一一个参数的话，还可以将函数的括号省略：</p>
<pre><code class="language-java">    val maxLengthFruit = list.maxBy { fruit: String -&gt; fruit.length }
</code></pre>
<p>  由于 Kotlin 拥有出色的类型推导机制，Lambda 表达式中的参数列表其实在大多数情况下不必声明参数类型，因此代码可以进一步简化成：</p>
<pre><code class="language-java">    val maxLengthFruit = list.maxBy { fruit -&gt; fruit.length }
</code></pre>
<p>  最后，当 Lambda 表达式的参数列表中只有一个参数时，也不必声明参数名，而是可以使用 it 关键字来代替，那么代码就变成了：</p>
<pre><code class="language-java">    val maxLengthFruit = list.maxBy { it.length }
</code></pre>
<p>  集合中的 map 函数是最常用的一种函数式 API，它用于将集合中的每个元素都映射成一个另外的值，映射的规则在 Lambda 表达式中指定，最终生成一个新的集合。比如，这里希望让所有的水果名都变成大写模式，就可以这样写：</p>
<pre><code class="language-java">    fun main() {
        val list = listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;, &quot;Watermelon&quot;)
        val newList = list.map { it.toUpperCase() }
        for (fruit in newList) {
            println(fruit)
        }
    }
</code></pre>
<blockquote>
<p>  map 函数的功能非常强大，它可以按照需求对集合中的元素进行任意的映射转换。</p>
</blockquote>
<p>  <code>filter</code>函数是用来过滤集合中的数据的，它可以单独使用，也可以配合刚才的 map 函数一起使用。比如保留 5 个字母以内的水果，就可以借助 filter 函数来实现，代码如下所示：</p>
<pre><code class="language-java">    fun main() {
        val list = listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;, &quot;Watermelon&quot;)
        val newList = list.filter { it.length &lt;= 5 }.map { it.toUpperCase() }
        for (fruit in newList) {
            println(fruit)
        }
    }
</code></pre>
<blockquote>
<p>  先进行过滤操作，再对过滤后的元素进行映射转换，效率会更高。</p>
</blockquote>
<p>  <code>any</code>函数用于判断集合中是否至少存在一个元素满足指定条件。<code>all</code>函数用于判断集合中是否所有元素都满足指定条件。示例代码如下：</p>
<pre><code class="language-java">    fun main() {
        val list = listOf(&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;, &quot;Pear&quot;, &quot;Grape&quot;, &quot;Watermelon&quot;)
        val anyResult = list.any { it.length &lt;= 5 }
        val allResult = list.all { it.length &lt;= 5 }
        println(&quot;anyResult is &quot; + anyResult + &quot;, allResult is &quot; + allResult)
    }
</code></pre>
<h3 id="java-函数式-api-的使用">Java 函数式 API 的使用</h3>
<p>  上面学习的都是 Kotlin 中函数式 API 的用法，但实际上在 Kotlin 中调用 Java 方法时也可以使用函数式 API，只不过这是有一定条件限制的。<br>
　　具体来讲，如果我们在 Kotlin 代码中调用了一个 Java 方法，并且该方法接收一个 Java 单抽象方法接口参数，就可以使用函数式 API。</p>
<blockquote>
<p>  Java 单抽象方法接口指的是接口中只有一个待实现方法，如果接口中有多个待实现方法，则无法使用函数式 API。</p>
</blockquote>
<p>  Java 原生 API 中有一个最为常见的单抽象方法接口——<code>Runnable</code>接口。这个接口中只有一个待实现的<code>run()</code>方法，定义如下：</p>
<pre><code class="language-java">    public interface Runnable {
        void run();
    }
</code></pre>
<p>  对于任何一个 Java 方法，只要它接收<code>Runnable</code>参数，就可以使用函数式 API。不过 Runnable 接口主要还是结合线程来一起使用的，可以使用如下 Java 代码创建并执行一个子线程：</p>
<pre><code class="language-java">    new Thread(new Runnable() {
        @Override
        public void run() {
            System.out.println(&quot;Thread is running&quot;);
        }
    }).start();
</code></pre>
<p>  若直接使用 Kotlin 来实现，写法如下所示：</p>
<pre><code class="language-java">    Thread(object : Runnable {
        override fun run() {
            println(&quot;Thread is running&quot;)
        }
    }).start()
</code></pre>
<p>  由于 Kotlin 完全舍弃了 new 关键字，因此创建匿名类实例时使用<code>object</code>关键字。注意，目前 Thread 类的构造方法是符合 Java 函数式 API 的使用条件的，因此可以对代码进行精简，如下所示：</p>
<pre><code class="language-java">    Thread(Runnable {
        println(&quot;Thread is running&quot;)
    }).start()
</code></pre>
<blockquote>
<p>  即使这里没有显式地重写 run() 方法，Kotlin 也能自动明白 Runnable 后面的 Lambda 表达式就是要在 run() 方法中实现的内容。</p>
</blockquote>
<p>  另外，如果一个 Java 方法的参数列表中有且仅有一个 Java 单抽象方法接口参数，我们还可以将接口名进行省略，如下：</p>
<pre><code class="language-java">    Thread({
        println(&quot;Thread is running&quot;)
    }).start()
</code></pre>
<p>  而且，当 Lambda 表达式是方法的最后一个参数时，可以将 Lambda 表达式移到方法括号的外面。同时，如果 Lambda 表达式还是方法的唯一一个参数，还可以将方法的括号省略，最终简化结果如下：</p>
<pre><code class="language-java">    Thread {
        println(&quot;Thread is running&quot;)
    }.start()
</code></pre>
<p>  由于 Android SDK 还是使用 Java 语言编写的，因此当我们在 Kotlin 中调用这些 SDK 接口时，就很可能会用到这种 Java 函数式 API 的写法。<br>
　　比如 Android 中有一个极为常用的点击事件接口<code>OnClickListener</code>，定义如下：</p>
<pre><code class="language-java">    public interface OnClickListener {
        void onClick(View v);
    }
</code></pre>
<p>  这显然是一个单抽象方法接口。这里使用 Kotlin 代码来给按钮注册点击事件，就可以使用函数式 API 的写法来对代码进行简化，如下：</p>
<pre><code class="language-java">    button.setOnClickListener {
    }
</code></pre>
<h2 id="空指针检查">空指针检查</h2>
<blockquote>
<p>  空指针是一种不受编程语言检查的运行时异常，只能由程序员主动通过逻辑判断来避免。</p>
</blockquote>
<h3 id="可空类型系统">可空类型系统</h3>
<p>  Kotlin 将空指针异常的检查提前到了编译时期，如果我们的程序存在空指针异常的风险，那么在编译的时候会直接报错，修正之后才能成功运行，这样就可以保证程序在运行时期不会出现空指针异常。</p>
<blockquote>
<p>  Kotlin 默认所有的参数和变量都不可为空。</p>
</blockquote>
<p>  Kotlin 也提供了另外一套可为空的类型系统，只不过在使用可为空的类型系统时，我们需要在编译时期就将所有潜在的空指针异常都处理掉，否则代码将无法编译通过。<br>
　　可为空的类型系统就是在类名的后面加上一个问号，比如，<code>Int</code>表示不可为空的整型，而<code>Int?</code>就表示可为空的整型。如果我们希望传入的参数可以为空，那么就应该将参数的类型改为可为空。</p>
<h3 id="判空辅助工具">判空辅助工具</h3>
<blockquote>
<p>  但是为了在编译时期就处理掉所有的空指针异常，通常需要编写很多额外的检查代码才行。如果每处检查代码都使用 if 判断语句，则会让代码变得比较啰嗦，而且 if 判断语句还处理不了全局变量的判空问题。为此，Kotlin 专门提供了一系列的辅助工具，使开发者能够更轻松地进行判空处理。</p>
</blockquote>
<p>  首先是最常用的<code>?.</code>操作符。这个操作符的作用就是当对象不为空时正常调用相应的方法，当对象为空时则什么都不做。比如以下的判空处理代码：</p>
<pre><code class="language-java">    if (a != null) {
        a.doSomething()
    }
</code></pre>
<p>  使用<code>?.</code>就可以简化成：</p>
<pre><code class="language-java">    a?.doSomething()
</code></pre>
<p>  <code>?:</code>操作符也是比较常用的。这个操作符的左右两边都接收一个表达式，如果左边表达式的结果不为空就返回左边表达式的结果，否则就返回右边表达式的结果。比如以下代码：</p>
<pre><code class="language-java">    val c = if (a ! = null) {
        a
    } else {
        b
    }
</code></pre>
<p>  使用<code>?:</code>操作符就可以简化成：</p>
<pre><code class="language-java">    val c = a ?: b
</code></pre>
<p>  不过 Kotlin 的空指针检查机制也并非总是那么智能，有的时候我们可能从逻辑上已经将空指针异常处理了，但是 Kotlin 的编译器并不知道，这个时候它还是会编译失败。示例代码如下：</p>
<pre><code class="language-java">    var content: String? = &quot;hello&quot;
    fun main() {
        if (content != null) {
            printUpperCase()
        }
        fun printUpperCase() {
            val upperCase = content.toUpperCase()
            println(upperCase)
        }
    }
</code></pre>
<p>  这里我们定义了一个可为空的全局变量 content，然后在 main() 函数里先进行一次判空操作，当 content 不为空的时候才会调用<code>printUpperCase()</code>函数。<br>
　　看上去好像逻辑没什么问题，但是这段代码一定是无法运行的。因为<code>printUpperCase()</code>函数并不知道外部已经对 content 变量进行了非空检查，在调用<code>toUpperCase()</code>方法时，还认为这里存在空指针风险，从而无法编译通过。<br>
  在这种情况下，如果我们想要强行通过编译，可以使用非空断言工具，写法是在对象的后面加上<code>!!</code>，如下所示：</p>
<pre><code class="language-java">    fun printUpperCase() {
        val upperCase = content!!.toUpperCase()
        println(upperCase)
    }
</code></pre>
<p>  这是一种有风险的写法，意在告诉 Kotlin，我非常确信这里的对象不会为空，所以不用你来帮我做空指针检查。<br>
　　因此更好的实现方法是使用一个比较与众不同的辅助工具——let。<code>let</code>既不是操作符，也不是什么关键字，而是一个函数。它提供了函数式 API 的编程接口，并将原始调用对象作为参数传递到 Lambda 表达式中。示例代码如下：</p>
<pre><code class="language-java">    obj.let { obj2 -&gt;
        // 编写具体的业务逻辑
    }
</code></pre>
<p>  可以看到，这里调用了 obj 对象的<code>let</code>函数，然后 Lambda 表达式中的代码就会立即执行，并且这个 obj 对象本身还会作为参数传递到 Lambda 表达式中。不过为了防止变量重名，这里将参数名改成 obj2，但实际上它们是同一个对象，这就是 let 函数的作用。<br>
　　<code>let</code>函数的特性配合<code>?.</code>操作符可以在空指针检查的时候起到很大的作用。</p>
<pre><code class="language-java">    fun doStudy(study: Study?) {
        study?.let { stu -&gt;
            stu.readBooks()
            stu.doHomework()
        }
    }
</code></pre>
<p>  let 函数会将 study 对象本身作为参数传递到 Lambda 表达式中，由于使用了<code>?.</code>操作符，此时的 study 对象肯定不为空了，我们就能放心地调用它的任意方法。<br>
　　最后，当 Lambda 表达式的参数列表中只有一个参数时，可以不用声明参数名，直接使用<code>it</code>关键字来代替即可，那么代码就可以进一步简化成：</p>
<pre><code class="language-java">    fun doStudy(study: Study?) {
        study?.let {
            it.readBooks()
            it.doHomework()
        }
    }
</code></pre>
<blockquote>
<p>  let 函数是可以处理全局变量的判空问题的。</p>
</blockquote>
<h2 id="字符串内嵌表达式">字符串内嵌表达式</h2>
<blockquote>
<p>  Kotlin 从一开始就支持了字符串内嵌表达式的功能，弥补了 Java 在这一点上的遗憾。在 Kotlin 中，我们不需要再像使用 Java 时那样傻傻地拼接字符串了，而是可以直接将表达式写在字符串里面，即使是构建非常复杂的字符串，也会变得轻而易举。</p>
</blockquote>
<p>  Kotlin 中字符串内嵌表达式的语法规则：</p>
<pre><code class="language-java">    &quot;hello, ${obj.name}. nice to meet you!&quot;
</code></pre>
<p>  可以看到，Kotlin 允许我们在字符串里嵌入<code>${}</code>这种语法结构的表达式，并在运行时使用表达式执行的结果替代这一部分内容。<br>
　　另外，当表达式中仅有一个变量的时候，还可以将两边的大括号省略，如下所示：</p>
<pre><code class="language-java">    &quot;hello, $name. nice to meet you!&quot;
</code></pre>
<h2 id="函数的参数默认值">函数的参数默认值</h2>
<p>  之前已经提到过，Kotlin 提供了给函数设定参数默认值的功能，它在很大程度上能够替代次构造函数的作用。<br>
　　具体来讲，我们可以在定义函数的时候给任意参数设定一个默认值，这样当调用此函数时就不会强制要求调用方为此参数传值，在没有传值的情况下会自动使用参数的默认值。<br>
　　给参数设定默认值的方式也很简单，如下所示：</p>
<pre><code class="language-java">    fun printParams(num: Int, str: String = &quot;hello&quot;) {
        println(&quot;num is $num , str is $str&quot;)
    }
</code></pre>
<p>  Kotlin 提供了一种机制，就是可以通过键值对的方式来传参，从而不必像传统写法那样按照参数定义的顺序来传参。比如调用 printParams() 函数，可以这样写：</p>
<pre><code class="language-java">    printParams(str = &quot;world&quot;, num = 123)
</code></pre>
<p>  此时哪个参数在前哪个参数在后都无所谓，Kotlin 可以准确地将参数匹配上。</p>
<p>  回顾一下当初我们学习次构造函数时所编写的代码：</p>
<pre><code class="language-java">    class Student(val sno: String, val grade: Int, name: String, age: Int) : Person(name, age) {
        constructor(name: String, age: Int) : this(&quot;&quot;, 0, name, age) {
        }
        constructor() : this(&quot;&quot;, 0) {
        }
}
</code></pre>
<p>  次构造函数在这里的作用是提供了使用更少参数来对 Student 类进行实例化的方式。<br>
　　无参的次构造函数会调用两个参数的次构造函数，并将这两个参数赋值成初始值。两个参数的次构造函数会调用 4 个参数的主构造函数，并将缺失的两个参数也赋值成初始值。<br>
　　这种写法在 Kotlin 中其实是不必要的，因为完全可以通过只编写一个主构造函数，然后给参数设定默认值的方式来实现，代码如下所示：</p>
<pre><code class="language-java">    class Student(val sno: String = &quot;&quot;, val grade: Int = 0, name: String = &quot;&quot;, age: Int = 0) :
        Person(name, age) {
    }
</code></pre>
<p>  在给主构造函数的每个参数都设定了默认值之后，我们就可以使用任何传参组合的方式来对 Student 类进行实例化，当然也包含了刚才两种次构造函数的使用场景。</p>

                </div>
            </article>
        </div>

        
            <div class="next-post">
                <div class="next gt-c-content-color-first">下一篇</div>
                <a href="https://Petrichoroo.github.io/post/lesslessdi-yi-xing-dai-ma-androidgreatergreater-bi-ji-tan-jiu-service/" class="post-title gt-a-link">
                    《第一行代码 Android》笔记 — 探究 Service
                </a>
            </div>
        

        

        

        

        <div class="site-footer gt-c-content-color-first">
    <div class="slogan gt-c-content-color-first">Live well,love lots,and laugh often.</div>
    <div class="social-container">
        
            
        
            
        
            
        
            
        
            
        
            
        
    </div>
    <div class="footer-info">
            <div class="social-container">
                <a href="https://github.com/Petrichoroo?tab=repositories" 
target="_blank">
                    <i class="fab fa-github gt-c-content-color-first"></i>
                </a>
    </div>
    <div>
        Theme <a href="https://github.com/imhanjie/gridea-theme-pure" target="_blank">Pure</a>, Powered by <a
                href="https://gridea.dev" target="_blank">Gridea</a> | <a href="https://Petrichoroo.github.io/atom.xml" target="_blank">RSS</a>
    </div>
</div>

<script>
  hljs.highlightAll()
</script>

    </div>
</div>
</body>
</html>
